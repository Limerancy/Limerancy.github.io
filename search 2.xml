<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[形式幂级数]]></title>
    <url>%2F2019%2F11%2F%E5%BD%A2%E5%BC%8F%E5%B9%82%E7%BA%A7%E6%95%B0%2F</url>
    <content type="text"><![CDATA[定义与多项式的联系一个关于 $x$ 的多项式可以写作： A(x) = \sum \limits_{i = 0}^{n - 1} a_ix^i去掉项数的限制： A(x) = \sum \limits_{i \geq 0} a_ix^i普通生成函数对于一类无标号对象，使用普通生成函数： A(x) = \sum \limits_{i \geq 0} a_ix^i指数生成函数对于一类有标号对象，使用指数生成函数： A(x) = \sum \limits_{i \geq 0}a_i\frac{x^i}{i!}无标号是易于理解的，考虑有标号对象的合并：除以 $i!$ 不妨可以看作一次对于该对象内部元素的重标号，若要合并两个标号，则新的重标号方式为： \pmatrix{n + m \\ n}那么考虑一次卷积： C_k = \sum \limits_{i + j = k}A_iB_j \frac{k!}{i!j!}移项，发现其形式依然是： C(x) = A(x)B(x)组合生成函数对于一类特殊的对象——一般是有编号有向图的计数题中出现——使用组合生成函数： A(x) = \sum \limits_{i \geq 0} a_i\frac{x^i}{i!2^{\pmatrix{i\\2}}}乘法逆元定义$x$ 是形式化的，对于形式幂级数求和时，默认 $x^{\infty}$ 趋近于 $0$ 。 例如： \sum \limits_{i \geq 0}x^i = \frac{1}{1 -x}借助二项式系数，或者考虑一些组合意义，有： \sum \limits_{i \geq 0} \pmatrix{n + i \\ n}x^i = \frac{1}{(1 - x)^{n + 1}}逆元的求法，本处不作赘述。 应用例题1 有若干颜色不同的骨牌，其中大小为 $1\times i$ 的骨牌恰好有 $a_i$ 种，每种骨牌都能够无限使用，不重叠地铺满 $1\times n$ 的放个有几种方法？ $a_i, n \leq 10^5$ 这是一道十分基础的生成函数题，答案显然为： [x^n]\sum \limits_{k \geq 0}A(x)^k = [x^n]\frac{1}{1 - A(x)}例题2 字符集大小为 $m$ ，给定一个长为 $k$ 的字符串 $s$ ，求所有长为 $n$ 的串中，不包含子串 $s$ 的有多少个？ $n, m, k \leq 10^5$ 直接计数非常困难，需要二维表示状态，正难则反，尝试计算出所有的不合法串。 这时候需要设计一个状态，尽可能简单且能够转移，故令 $f_i$ 表示第一次匹配上 $s$ 的位置是 $[i - k + 1, i]$ 。 当 $i &lt; k$ 时： f_i = 0当 $i &gt;= k$ 时： f_i = m^{i - k} - \sum \limits_{j = 0}^{i - k}f_jm^{i - k - j} - \sum \limits_{d>0,d\in C}f_{i - d}集合 $C = {d \geq 0|s_{d + 1, k} = s_{1, k - d}}$。 第一项是全集；第二项是前面已经计算过的，第一次不在区间内的个数；第三次第一次匹配也在该区间内的，但是已经记入过答案。 $C$ 可以利用 $\mbox{KMP}$ 预处理出来，利用生成函数的思想优化之： \begin{align*} f(x) &= \frac{1}{1 - mx} - \frac{x^kf(x)}{1 - mx} - f(x)(c(x) - 1) \\ f(x) &= \frac{x^k}{x^k + (1 - mx)c(x)} \end{align*}令 $g_n = m^n - \sum \limits_{i = 0}^{n}f_im_{i - j}$ ，有： g(x) = \frac{c(x)}{x^k + (1 - mx)c(x)}对数与指数复合运算对于 $A(x) = \sum \limits_{i \geq 0}a_ix^i, B(x) = \sum \limits_{i \geq 1}b_ix^i$ ，有： C(x) = A(B(x)) = \sum \limits_{i \geq 0}a_i(B(x))^i显然可以整理为： C(x) = \sum \limits_{i \geq 0}c_ix^i注意，此处 $B(x)$ 并无常数项，所以复合运算成立，反之不成立。 形式导数对于 $A(x) = \sum \limits_{i \geq 0}a_ix^i$ ，其形式导数为： A'(x) = \sum \limits_{i \geq 1}ia_ix^{i - 1}基本求导法则对于形式导数依然成立。 对数函数对于 $A(x) = \sum \limits_{i \geq 1}a_ix^i$ ，其对数函数等价于将给定级数与其对应的麦克劳林级数复合，即： \ln(1 - A(x)) = -\sum \limits_{i \geq 1}\frac{A(x)^i}{i}通过导数，有一种简单的计算方式： 给定 $A(x) = 1 + \sum \limits_{i \leq 1}a_ix^i$，令： B(x) = \ln(A(x))则： B'(x) = \frac{A'(x)}{A(x)}$\ln$ 一般在已知不同集合个数，求不同元素个数时使用。 指数函数对于 $A(x) = \sum \limits_{i \geq 1}a_ix^i$ ，其对数函数等价于将给定级数与其对应的麦克劳林级数复合，即： \exp(A(x)) = \sum \limits_{i \geq0}\frac{A(x)^i}{i!}定义：$B(x) = \exp(A(x))$ ，有： \ln(B(x)) - A(x)=0利用牛顿迭代法求解。 $\exp$ 一般在已知不同元素个数，求不同集合个数时使用。 集合的计数有标号集合的计数集合内的元素没有顺序关系，所以有： B(x) = \sum \limits_{i \geq 0} \frac{A(x)^i}{i!}=\exp(A(x))有标号环的计数环内的元素旋转后相同会被认为相同，故： B(x) = \sum \limits_{i \geq 0}\frac{A(x)^i}{i}=-\ln(1-A(x))应用例题1 求出 $n$ 个顶点的连通无向图个数，顶点有编号，不允许重边和自环。 $n \leq 10^5$ 设 $G$ 为所有简单无向图，则： G(x) = \sum \limits_{i \geq 0}2^{\pmatrix{n \\ 2}}\frac{x^n}{n!}设 $C$ 为所有简单连通图，由于一个简单无向图可以看作若干个连通分量组成的集合，所以： G(x) = \sum \limits_{i \geq0}\frac{C(x)^i}{i!}即： G(x) = \exp(C(x))有： C(x) = \ln(G(x))例题2 你有若干种不同的物品，其中体积为 $i$ 的物品有 $a_i$ 种，每种物品有无限个，求物品恰好装满总体积为 $n$ 的背包的方案数。 $a_i, n \leq 10^5$ 有一个最基础的解法： (\sum \limits_{i \geq 0}a_ix^i)^n当然这在这里时不适用的，因为无标号集合中可能出现重复元素，而无法去重。 考虑对于每一个不同的体积写出其生成函数： \prod \limits_{i = 1}^n (\sum \limits_{j = 0}^{n / i}x^{ij})^{a_i}这里有一个启示：对于这种有求和式的计数题而言，更换求和方式不失为一种优秀的求解方式，而不是一味的尝试容斥。 对上式进行变换： \prod \limits_{i = 1}^n (\frac{1}{1 - x^i})^{a_i}使用对数函数化乘为加： \begin{align*} =&\exp(-\sum \limits_{i = 1}^na_i\ln(1-x^i)) \\ =&\exp(\sum \limits_{i = 1}^na_i\sum \limits_{j \geq 1}\frac{x^{ij}}{j}) \\ =&\exp(\sum \limits_{j \geq 1}\frac{1}{j}A(x^j)) \end{align*}$A(x^j)$ 只有 $\frac{n}{j}$ 项有用，故复杂度为调和级数：$O(n\log n)$ 。 此处的完全背包可以替换成 $01$ 背包，处理方式相同。 例题3 求包含 $n$ 个顶点的基环树个数。 $n \leq 10^5$ 根据 $\mbox{Carley}$ 定理，设 $T(x)$ 为有根树数量的生成函数，有： T(x) = \sum \limits_{i \geq 0}i^{i - 1}\frac{x^i}{i!}一棵基环树等价于若干棵树拼接在环上得到，故答案为： \begin{align*} &\frac{1}{2}\sum \limits_{i \geq 3}\frac{T(x)^i}{i} \\ &=-\frac{1}{2}\ln(1-T(x))-\frac{T(x)}{2} - \frac{T(x)^2}{4} \end{align*}例题4 给定集合 $S$ 和正整数 $n$，计算有多少个 $n$ 阶置换 $p$ ，满足 $p$ 分解后的每一个轮换的大小都在 $S$ 内。 $n\leq 10^5$ 每一个轮换等价于一个圆排列的方案数，那么对于每一个 $k \in S$，都可以有： (k-1)!一个置换就是若干个轮换的集合，于是有： S(x) = \sum \limits_{i \in S} (i - 1)!\frac{x^i}{i!}答案为： \begin{align*} &\sum \limits_{i \geq 0}\frac{S(x)^i}{i!}\\ =& \exp(S(x)) \end{align*}]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论定理套路小结]]></title>
    <url>%2F2019%2F11%2F%E5%9B%BE%E8%AE%BA%E5%AE%9A%E7%90%86%E5%A5%97%E8%B7%AF%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[二分图常用定理最小顶点覆盖 $=$ 最大匹配数 最大独立集 $=$ $n \ - $ 最小顶点覆盖 有向无环图最小路径覆盖 $ = $ $n \ - $ 拆点二分图的最大匹配数 最大权闭合子图最大权 $=$ 正权和 $ - $ 最小割 最大团 $= $ 补图最大独立集 必经边]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 2150 - [NOI2015]寿司晚宴]]></title>
    <url>%2F2019%2F11%2FLuogu-2150-NOI2015-%E5%AF%BF%E5%8F%B8%E6%99%9A%E5%AE%B4%2F</url>
    <content type="text"></content>
      <tags>
        <tag>solution/algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 1971 - [NOI2011]兔兔与蛋蛋游戏]]></title>
    <url>%2F2019%2F11%2FLuogu-1971-NOI2011-%E5%85%94%E5%85%94%E4%B8%8E%E8%9B%8B%E8%9B%8B%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"></content>
      <tags>
        <tag>solution/algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 5615 - [MtOI2019]时间跳跃]]></title>
    <url>%2F2019%2F11%2FLuogu-5615-MtOI2019-%E6%97%B6%E9%97%B4%E8%B7%B3%E8%B7%83%2F</url>
    <content type="text"></content>
      <tags>
        <tag>solution/algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 5527 - [Ynoi2012]D2T1]]></title>
    <url>%2F2019%2F11%2FLuogu-5527-Ynoi2012-D2T1%2F</url>
    <content type="text"></content>
      <tags>
        <tag>solution/algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 4747 - [CERC2017]Intrinsic Interval]]></title>
    <url>%2F2019%2F11%2FLuogu-4747-CERC2017-Intrinsic-Interval%2F</url>
    <content type="text"><![CDATA[非常有意思的一道线段树题，应该想出来的并不难？ 考虑离线，那么我们现在的问题便是在 $\log n$ 的时间内判断确定一个端点的情况下，其可能的区间的集合。 对于判定一个区间是否是题目所要求的“连续区间”，不难想到如此方法： r - l = \max - \min但是对于该题，在右端点固定的情况下，其区间 $\max$ 和 $\min$ 会随时变化的，难以维护以及查询。 在考虑“连续“区间的其他性质，不难发现其数字连续对（即在值域上连续）的个数一定是 $r - l$ 个，且对于一个区间 $[l, r]$ ，若其数字连续对的个数为 $r - l$ ，其一定是连续区间。 证明：其数字连续对个数为 $r - l$ ，则只有两个数只有一个数字连续对。则对于所有数字一定是连续的，反之不成立。 那么如何判定？令 $t_j = j$，每加入一个右端点 $a_i$ ，若 $a_i - 1,a_i + 1$ 已经在之前出现过，则在 $1 \sim p_{a_i - 1}$ 区间加一，$a_i + 1$ 同理，表明任意一个左端点取 $1 \sim p_{a_i - 1}$ 的点，都将多碰到一个数字连续对，判定条件即为：$t_j = i$ 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define ls x &lt;&lt; 1#define rs x &lt;&lt; 1 | 1using namespace std;typedef pair&lt;int, int&gt; pa;int n, m;int a[MAXN], p[MAXN];vector&lt;pa&gt; q[MAXN];priority_queue&lt;pa&gt; s;pa ans[MAXN];struct node &#123; int p, v; node(int p = 0, int v = 0):p(p), v(v) &#123;&#125; bool operator &lt; (const node b) const &#123; return v &lt; b.v || (v == b.v &amp;&amp; p &lt; b.p); &#125;&#125;v;struct segment &#123; int l, r, t; node v;&#125;t[MAXN &lt;&lt; 2];int read() &#123; char c = getchar(); int x = 0, s = 1; while (!isdigit(c)) &#123; s = c == '-' ? -1 : 1; c = getchar(); &#125; while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x * s;&#125;void pushdown(int x) &#123; if (t[x].t) &#123; t[ls].t += t[x].t; t[ls].v.v += t[x].t; t[rs].t += t[x].t; t[rs].v.v += t[x].t; t[x].t = 0; &#125;&#125;void pushup(int x) &#123; t[x].v = max(t[ls].v, t[rs].v);&#125;void build(int l = 1, int r = n, int x = 1) &#123; t[x].l = l; t[x].r = r; if (l == r) &#123; t[x].v = node(l, l); return ; &#125; int mid = (l + r) &gt;&gt; 1; build(l, mid, ls); build(mid + 1, r, rs); pushup(x);&#125;void modify(int l, int r, int v, int x = 1) &#123; if (l &lt;= t[x].l &amp;&amp; t[x].r &lt;= r) &#123; t[x].t += v; t[x].v.v += v; return ; &#125; pushdown(x); int mid = (t[x].l + t[x].r) &gt;&gt; 1; if (l &lt;= mid) modify(l, r, v, ls); if (r &gt; mid) modify(l, r, v, rs); pushup(x);&#125;node query(int l, int r, int x = 1) &#123; if (l &lt;= t[x].l &amp;&amp; t[x].r &lt;= r) return t[x].v; int mid = (t[x].l + t[x].r) &gt;&gt; 1; node res; pushdown(x); if (l &lt;= mid) res = max(res, query(l, r, ls)); if (r &gt; mid) res = max(res, query(l, r, rs)); pushup(x); return res;&#125;void solve() &#123; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt; (int)q[i].size(); ++j) s.push(q[i][j]); if (a[i] - 1 &gt;= 1 &amp;&amp; p[a[i] - 1] &lt;= i) modify(1, p[a[i] - 1], 1); if (a[i] + 1 &lt;= n &amp;&amp; p[a[i] + 1] &lt;= i) modify(1, p[a[i] + 1], 1); while (!s.empty()) &#123; pa u = s.top(); node v = query(1, u.first); if (v.v == i) ans[u.second] = make_pair(v.p, i); else break; s.pop(); &#125; &#125;&#125;int main() &#123; n = read(); for (int i = 1; i &lt;= n; ++i) p[a[i] = read()] = i; m = read(); for (int i = 1; i &lt;= m; ++i) &#123; int l = read(), r = read(); q[r].push_back(make_pair(l, i)); &#125; build(); solve(); for (int i = 1; i &lt;= m; ++i) printf("%d %d\n", ans[i].first, ans[i].second);&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>基础</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 4609 - [FJOI2016]建筑师]]></title>
    <url>%2F2019%2F11%2FLuogu-4609-FJOI2016-%E5%BB%BA%E7%AD%91%E5%B8%88%2F</url>
    <content type="text"><![CDATA[题目要求等价于将 $n$ 个城市划分成 $ａ + b - 1$ 个城市群，每一个城市群有一个最高的城市，只能看见之。 对于一个大小为 $k$ 的城市群，有 $(k - 1)!$的方案数，等价于将他们组成一个圆排列的方案数。 由于高度为 $n$ 的城市自成一个城市群，于是我们将 $n - 1$ 个城市分成 $a + b - 2$ 个城市群，即： \begin{bmatrix}n - 1 \\ a + b - 2\end{bmatrix}同时，还要计算哪 $a - 1$ 个城市群在左边，即： \pmatrix{a + b - 2 \\ a - 1}所以总答案为： \pmatrix{a + b - 2 \\ a - 1} \times \begin{bmatrix}n - 1 \\ a + b - 2\end{bmatrix}123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;#define MAXN 50005#define MAXM 205typedef long long lint;using namespace std;int t, n, a, b;lint C[MAXM][MAXM], S[MAXN][MAXM];const int M = 200, N = 50000, mod = 1e9 + 7;void init() &#123; S[0][0] = C[0][0] = 1; for (int i = 1; i &lt;= M; ++i) &#123; C[i][0] = 1; for (int j = 1; j &lt;= i; ++j) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod; &#125; for (int i = 1; i &lt;= N; ++i) for (int j = 1; j &lt;= M; ++j) S[i][j] = (S[i - 1][j - 1] + S[i - 1][j] * (i - 1) % mod) % mod;&#125;int main() &#123; init(); scanf("%d", &amp;t); while (t--) &#123; scanf("%d%d%d", &amp;n, &amp;a, &amp;b); printf("%lld\n", C[a + b - 2][a - 1] * S[n - 1][a + b - 2] % mod); &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>组合数学</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>solution/algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 3647 - [APIO2014]连珠线]]></title>
    <url>%2F2019%2F11%2FLuogu-3647-APIO2014-%E8%BF%9E%E7%8F%A0%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[较为繁琐的树形 $\mbox{DP}$ 。 不难发现除了根节点以外，不可能构成横向的蓝色三元组，一定是纵向的蓝色三元组。 令 $f_{i, 0/1}$ 表示以 $i$ 为根，其是否是三元组的中间点。三元组包括三个点，两条边，上下两点是可以和别的三元组重复的，关键是要记录两条边。 有方程： \begin{align*} f_{i, 0} &= \sum \limits_{j \in s_i} \max(f_{j, 0}, f_{j, 1} + w_{i, j}) \\ f_{i, 1} &= \sum \limits_{j \in s_i} f_{i, 0} + a_i \\ a_i &= \max \limits_{j \in s_i} w_{i, j} + f_{j, 0} - \max(f_{j, 0}, f_{j, 1} + w_{i, j}) \\ b_i &\leq a_i \end{align*}即 $b_i$ 为上式的次大值。 考虑换根： \begin{align*} g_{j, 0} &= f_{i, 0} - \max(f_{j, 0}, f_{j, 1} + w_{i, j}) + \max(g_{i, 0}, g_{i, 1} + w_{i, fa_i}) \\ g_{j, 1} &= g_{j, 0} + \max(a_i \ / \ b_i,w_{i, fa_i} + g_{i, 0} - \max(g_{i, 0}, g_{i, 1} + w_{i, fa_i})) \end{align*}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;#define MAXN 200005#define INF 0x3f3f3f3fusing namespace std;int n, ans;int head[MAXN], cnt;int fa[MAXN], back[MAXN], f[MAXN][2], g[MAXN][2], ultmax[MAXN], submax[MAXN];struct data &#123; int next, to, cost; data(int next = 0, int to = 0, int cost = 0):next(next), to(to), cost(cost) &#123;&#125;&#125;edge[MAXN &lt;&lt; 1];int read() &#123; char c = getchar(); int x = 0, s = 1; while (!isdigit(c)) &#123; s = c == '-' ? -1 : 1; c = getchar(); &#125; while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x * s;&#125;void connect(int u, int v, int w) &#123; edge[++cnt] = data(head[u], v, w); head[u] = cnt;&#125;void DFS1(int u, int pre) &#123; fa[u] = pre; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to, w = edge[i].cost; if (v == pre) &#123; back[u] = w; continue; &#125; DFS1(v, u); f[u][0] += max(f[v][0], f[v][1] + w); if (w + f[v][0] - max(f[v][0], f[v][1] + w) &gt; ultmax[u]) &#123; submax[u] = ultmax[u]; ultmax[u] = w + f[v][0] - max(f[v][0], f[v][1] + w); &#125; else if (w + f[v][0] - max(f[v][0], f[v][1] + w) &gt; submax[u]) submax[u] = w + f[v][0] - max(f[v][0], f[v][1] + w); &#125; f[u][1] = f[u][0] + ultmax[u];&#125;void DFS2(int u) &#123; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to, w = edge[i].cost; if (v == fa[u]) continue; g[v][0] = f[u][0] - max(f[v][0], f[v][1] + w) + max(g[u][0], g[u][1] + back[u]); int temp = max(w + f[v][0] - max(f[v][0], f[v][1] + w) == ultmax[u] ? submax[u] : ultmax[u], u == 1 ? -INF : back[u] + g[u][0] - max(g[u][0], g[u][1] + back[u])); g[v][1] = g[v][0] + temp; DFS2(v); &#125;&#125;int main() &#123; memset(ultmax, 0xcf, sizeof(ultmax)); memset(submax, 0xcf, sizeof(submax)); n = read(); for (int i = 1; i &lt; n; ++i) &#123; int u = read(), v = read(), w = read(); connect(u, v, w); connect(v, u, w); &#125; DFS1(1, 0); DFS2(1); for (int u = 1; u &lt;= n; ++u) &#123; vector&lt;int&gt; temp; int sum = 0; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to, w = edge[i].cost; if (v == fa[u]) &#123; temp.push_back(g[u][0] + w - max(g[u][0], g[u][1] + w)); sum += max(g[u][0], g[u][1] + w); &#125; else &#123; temp.push_back(f[v][0] + w - max(f[v][0], f[v][1] + w)); sum += max(f[v][0], f[v][1] + w); &#125; &#125; sort(temp.begin(), temp.end()); ans = max(ans, sum); if (temp.size() &gt;= 2) ans = max(ans, sum + temp[temp.size() - 1] + temp[temp.size() - 2]); &#125; printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>树形DP</category>
      </categories>
      <tags>
        <tag>solution/algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 1954 - [NOI2010]航空管制]]></title>
    <url>%2F2019%2F11%2FLuogu-1954-NOI2010-%E8%88%AA%E7%A9%BA%E7%AE%A1%E5%88%B6%2F</url>
    <content type="text"><![CDATA[对于该题，关键是要在反图中进行拓扑。对于一个问题，其出现在前面比出现在后面更优，都可以进行反图拓扑。 对于第一问来说，正确的贪心策略是在反图上进行的：尽可能地选取 $k_i$ 大的点进行拓扑排序。在正图上选择 $k_i$ 小的点是错的：可以有一个较大的 $k$ 去限制较小的 $k$ 。因为 $k_i$ 大的可以放在前面，小的却不能放在后面。 对于第二问，不妨在反图拓扑时，遇见这个点时暂不加入，直到出现非法解为止，此时的位置必然是最大位置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;#define MAXN 2005using namespace std;int n, m, t[MAXN];int rev[MAXN], deg[MAXN];vector&lt;int&gt; g[MAXN], res;struct node &#123; int u, t; node(int u = 0, int t = 0):u(u), t(t) &#123;&#125; bool operator &lt; (const node b) const &#123; return t &gt; b.t; &#125;&#125;;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void topo() &#123; priority_queue&lt;node&gt; q; memcpy(deg, rev, sizeof(rev)); for (int i = 1; i &lt;= n; ++i) if (!deg[i]) q.push(node(i, t[i])); while (!q.empty()) &#123; int u = q.top().u; q.pop(); res.push_back(u); for (int i = 0; i &lt; (int)g[u].size(); ++i) &#123; int v = g[u][i]; if (--deg[v] == 0) q.push(node(v, t[v])); &#125; &#125;&#125;int solve(int x) &#123; priority_queue&lt;node&gt; q; memcpy(deg, rev, sizeof(rev)); for (int i = 1; i &lt;= n; ++i) if (!deg[i] &amp;&amp; i != x) q.push(node(i, t[i])); int times = 0; while (!q.empty()) &#123; int u = q.top().u; q.pop(); if (times &lt; t[u]) break; ++times; for (int i = 0; i &lt; (int)g[u].size(); ++i) &#123; int v = g[u][i]; if (--deg[v] == 0 &amp;&amp; v != x) q.push(node(v, t[v])); &#125; &#125; return n - times;&#125;int main() &#123; n = read(); m = read(); for (int i = 1; i &lt;= n; ++i) t[i] = n - read(); for (int i = 1; i &lt;= m; ++i) &#123; int u = read(), v = read(); g[v].push_back(u); ++rev[u]; &#125; topo(); for (int i = (int)res.size() - 1; i &gt;= 0; --i) printf("%d ", res[i]); puts(""); for (int i = 1; i &lt;= n; ++i) printf("%d ", solve(i));&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>拓扑</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>拓扑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 3574 - [POI2014]FAR-FarmCraft]]></title>
    <url>%2F2019%2F11%2FLuogu-3574-POI2014-FAR-FarmCraft%2F</url>
    <content type="text"><![CDATA[一类非常经典的贪心题，在此处稍作记录。 首先，对于一棵子树，需要走完才能出来，于是不妨令 $s_i$ 为走完该子树所花费的时间，$f_i$ 为该子树所有人都安装上软件的时间。 考虑两棵子树，尝试找到一种方式确定其相对顺序： a_i + s_i, 2a_i + a_j + s_j \\ a_j + s_j, 2a_j + a_i + s_i \\决定上式安装时间的都是后者，若 $i$ 需在 $j$ 前，比较后者有： \begin{align*} 2a_i + a_j + s_j &< 2a_j + a_i + s_i \\ a_i - s_i &< a_j - s_j \end{align*}对于一棵子树的点，按照该不等式规划顺序即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;#define MAXN 500005using namespace std;int n, a[MAXN], s[MAXN], f[MAXN];int head[MAXN], cnt;vector&lt;int&gt; g[MAXN];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;bool comp(int a, int b) &#123; return s[a] - f[a] &lt; s[b] - f[b];&#125;void DFS(int u, int pre) &#123; f[u] = a[u]; for (int i = 0; i &lt; (int)g[u].size(); ++i) &#123; int v = g[u][i]; if (v == pre) continue; DFS(v, u); &#125; sort(g[u].begin(), g[u].end(), comp); for (int i = 0; i &lt; (int)g[u].size(); ++i) &#123; int v = g[u][i]; if (v == pre) continue; f[u] = max(f[u], f[v] + s[u] + 1); s[u] += s[v] + 2; &#125;&#125;int main() &#123; n = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); for (int i = 1; i &lt; n; ++i) &#123; int u = read(), v = read(); g[u].push_back(v); g[v].push_back(u); &#125; DFS(1, 0); printf("%d\n", max(f[1], s[1] + a[1]));&#125;]]></content>
      <categories>
        <category>思维</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder AGC012C - Tautonym Puzzle]]></title>
    <url>%2F2019%2F11%2FAtCoder-AGC012C-Tautonym-Puzzle%2F</url>
    <content type="text"><![CDATA[神仙构造题，做的构造题显然还不够多，只能想到一个长度为 $log^2 n$ 的构造方法，显然无法通过此题。 由于一定要两两成对才能给答案贡献，所以不妨将序列分成两个部分：前者是 $1 \sim m$ 的一个排列，后者就是 $1 \sim m$ 。 如此构造，对于左边的每一个上升子序列，我们都能在右边找到其对应的子串，从而贡献到答案中。 于是问题转化成了构造一个数列，使得其上升子序列的个数恰好等于 $n$ 。 倘若对于一个数列： 放最前面，上升子序列的个数 $+1$ ； 放最后面，上升子序列的个数 $\times 2 + 1$ 。 依据此规则构造即可。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;typedef long long lint;using namespace std;lint n;vector&lt;int&gt; opr;deque&lt;int&gt; ans;int main() &#123; scanf("%lld", &amp;n); while (n) &#123; if (n &amp; 1) &#123; n = (n - 1) &gt;&gt; 1; opr.push_back(1); continue; &#125; --n; opr.push_back(0); &#125; reverse(opr.begin(), opr.end()); for (int i = 0; i &lt; (int)opr.size(); ++i) if (!opr[i]) ans.push_front(i + 1); else ans.push_back(i + 1); for (int i = 0; i &lt; (int)opr.size(); ++i) ans.push_back(i + 1); printf("%d\n", (int)ans.size()); for (int i = 0; i &lt; (int)ans.size(); ++i) printf("%d ", ans[i]);&#125;]]></content>
      <categories>
        <category>思维</category>
        <category>构造</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder AGC011F - Train Service Planning]]></title>
    <url>%2F2019%2F11%2FAtCoder-AGC011F-Train-Service-Planning%2F</url>
    <content type="text"><![CDATA[本题的难点在于建立出数学模型。 对于这个问题，乍一看是难以分析的，不妨通过建立几个函数来形象地表达火车的到达： $a(i)$：上行火车在 $i$ 站的逗留时间； $b(i)$：下行火车在 $i$ 站的逗留时间； $t(i)$ ：火车从站台 $i$ 到站台 $i + 1$ 的行驶时间。 特别的，$a(0)$ 表示上行火车的出发时间，$b(n)$ 表示下行火车的出发时间。 那么对于上行火车，其到达 $i$ 站的时间区间为： (A(i) + T(i - 1), A(i) + T(i))对于下行火车，由于每隔时间 $k$ 又会有一辆下行火车，顺推所求的后缀和可以在模意义下变成逆推的前缀和，即： (-B(i) - T(i),-B(i) - T(i - 1))若当前区间是单向区间，则有： (A(i) + T(i - 1), A(i) + T(i)) \cap (-B(i) - T(i),-B(i) - T(i - 1)) = \empty有不等式： A(i) + T(i - 1) > -B(i) - T(i - 1) \\ -B(i) - T(i) < A(i) + T(i - 1)解得： A(i) + B(i) \notin (-2T(i),-2T(i - 1))在模意义下，不妨可以看成是： A(i) + B(i) \in [-2T(i - 1), -2T(i)]$A(i) + B(i)$ 都是前缀和，其和一定递增，问题转化为：每次移动 $x$ 步，要求第 $i$ 次必须落在区间 $[-2T(i - 1), -2T(i)]$ 内，要求 $A(n) + B(n) + 2T(n)$ 最小，等价于移动步数最小。 考虑贪心，每次走左端点，只需要用线段树转移一下要走几步即可。 注意需要从后往前坐：起点是任意的，终点是一定的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define ls x &lt;&lt; 1#define rs x &lt;&lt; 1 | 1#define INF 0x3f3f3f3f3f3f3f3ftypedef long long lint;using namespace std;int n, m, k;lint a[MAXN], suma[MAXN], b[MAXN], l[MAXN], r[MAXN], ele[MAXN &lt;&lt; 1];lint f[MAXN &lt;&lt; 1];struct segment &#123; int l, r, v;&#125;t[MAXN &lt;&lt; 3];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void build(int l = 1, int r = m, int x = 1) &#123; t[x].l = l; t[x].r = r; t[x].v = 0; if (l == r) return ; int mid = (l + r) &gt;&gt; 1; build(l, mid, ls); build(mid + 1, r, rs);&#125;void pushdown(int x) &#123; if (t[x].v) &#123; t[ls].v = t[rs].v = t[x].v; t[x].v = 0; &#125;&#125;void modify(int l, int r, int v, int x = 1) &#123; if (l &gt; r) return ; if (l &lt;= t[x].l &amp;&amp; t[x].r &lt;= r) &#123; t[x].v = v; return ; &#125; pushdown(x); int mid = (t[x].l + t[x].r) &gt;&gt; 1; if (l &lt;= mid) modify(l, r, v, ls); if (r &gt; mid) modify(l, r, v, rs);&#125;int query(int p, int x = 1) &#123; if (t[x].l == t[x].r) return t[x].v; pushdown(x); int mid = (t[x].l + t[x].r) &gt;&gt; 1; if (p &lt;= mid) return query(p, ls); return query(p, rs);&#125;int dis(int x, int y) &#123; return (ele[y] - ele[x] + k) % k;&#125;int main() &#123; n = read(); k = read(); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = read(); b[i] = read(); if (b[i] == 1 &amp;&amp; a[i] * 2 &gt; k) &#123; puts("-1"); return 0; &#125; suma[i] = suma[i - 1] + a[i]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (b[i] == 1) &#123; l[i] = (-suma[i - 1] * 2 % k + k) % k; r[i] = (-suma[i] * 2 % k + k) % k; &#125; else &#123; l[i] = 0; r[i] = k - 1; &#125; ele[++m] = l[i]; ele[++m] = r[i]; &#125; sort(ele + 1, ele + m + 1); m = unique(ele + 1, ele + m + 1) - ele - 1; build(); for (int i = 1; i &lt;= n; ++i) &#123; l[i] = lower_bound(ele + 1, ele + m + 1, l[i]) - ele; r[i] = lower_bound(ele + 1, ele + m + 1, r[i]) - ele; &#125; for (int i = n; i &gt;= 1; --i) &#123; int j = query(l[i]); if (!j) f[i] = 0; else f[i] = f[j] + dis(l[i], l[j]); if (l[i] &lt;= r[i]) &#123; modify(1, l[i] - 1, i); modify(r[i] + 1, m, i); &#125; else modify(r[i] + 1, l[i] - 1, i); &#125; lint ans = f[1]; for (int i = 1; i &lt;= m; ++i) &#123; int j = query(i); if (!j) ans = 0; ans = min(ans, f[j] + dis(i, l[j])); &#125; printf("%lld\n", ans + suma[n] * 2);&#125;]]></content>
      <categories>
        <category>思维</category>
        <category>数学模型</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 5597 - 【XR-4】复读]]></title>
    <url>%2F2019%2F10%2FLuogu-5597-%E3%80%90XR-4%E3%80%91%E5%A4%8D%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[一道小清新的构造题。 循环节可以看作是一次对于起点的位移，不难证明如果复读次数在两次以上，位移后的点一定仍在给定的子树上。 所以我们枚举位移方式，计算出对于所有复读的起点。 令起点为 $u$ ，经过一次复读后所能到达的点是 $v$ ，那么对于 $u$ 的子树中，除了 $v$ 的子树的部分，都必须遍历一次。由于复读的次数不止一次，此时 $v$ 又变成起点，于是计算 $v$ 的子树除其复读后到达的点 $w$ 的部分。 这样，每一个起点都会有一个必须遍历的连通块，给他们求一个并集，计算出他们的大小，答案就是： 2 \times s - o$o$ 为命令长度，枚举所有的位移方式就可以计算出所有的答案，复杂度 $O(n^2)$ 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;#define MAXN 2005#define INF 0x3f3f3f3fusing namespace std;int n, total, root, ans = INF;int ch[MAXN][2], size[MAXN], g[MAXN][2];void build(int u) &#123; int s; scanf("%1d", &amp;s); if (!s) return ; else if (s == 1) build(ch[u][0] = ++n); else if (s == 2) build(ch[u][1] = ++n); else if (s == 3) &#123; build(ch[u][0] = ++n); build(ch[u][1] = ++n); &#125;&#125;void merge(int&amp; u, int v, int limit) &#123; if (v == limit) return ; if (!u) &#123; size[u = ++total] = 1; g[u][0] = g[u][1] = 0; &#125; if (ch[v][0]) merge(g[u][0], ch[v][0], limit); if (ch[v][1]) merge(g[u][1], ch[v][1], limit); size[u] = size[g[u][0]] + size[g[u][1]] + 1;&#125;int calc(string order) &#123; int u = 1; root = total = 0; while (u) &#123; int origin = u; for (int i = 0; i &lt; order.size(); ++i) u = ch[u][order[i] == 'R']; merge(root, origin, u); &#125; return size[root];&#125;void solve(int u, string order) &#123; if (ch[u][0]) solve(ch[u][0], order + "L"); if (ch[u][1]) solve(ch[u][1], order + "R"); if (u != 1) &#123; int size = calc(order); ans = min(2 * size - (int)order.size(), ans); &#125;&#125;int main() &#123; build(++n); solve(1, ""); printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>思维</category>
        <category>构造</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder AGC001F - Wide Swap]]></title>
    <url>%2F2019%2F10%2FAtCoder-AGC001F-Wide-Swap%2F</url>
    <content type="text"><![CDATA[对于交换，题目有如下限制： |i - j| \geq k \\ |p_i - p_j| = 1不妨令 $p_i$ 交换位置，$i$ 为权值，则可以交换的条件，变成了相邻两个数 $i, j$ 有： |a_i - a_j| \geq k由于下标和权值互换，同时，为了使字典序最小，我们需要最小化 $a_1$，再最小化 $a_2$ …… 对于两个数 $i, j$ ，若： |a_i - a_j| < k则 $i, j$ 的相对顺序不变，我们可以进行 $O(n^2)$ 的连边，拓扑排序确定相对顺序解决问题。这个复杂度是不优秀的，原因是存在一些冗余边：$(i, j), (j, k)$ 存在时，就不需要 $(i, k)$ 了。 因此，我们从后往前遍历时，只需要向已有的 $(a_i - k + 1, a_i)$ 中的下标最小的点和 $(a_i, a_i + k - 1)$ 中下标最小的点连边即可，原因是 $(a_i - k + 1, a_i)$ 和 $(a_i, a_i + k - 1)$ 中的元素已经确定顺序了，此时再向其中连其他连边，是无意义的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;bits/stdc++.h&gt;#define MAXN 500005#define ls x &lt;&lt; 1#define rs x &lt;&lt; 1 | 1#define INF 0x3f3f3f3fusing namespace std;typedef greater&lt;int&gt; gr;typedef vector&lt;int&gt; ve;int n, k;int a[MAXN], deg[MAXN], ans[MAXN], total;vector&lt;int&gt; g[MAXN];struct segment &#123; int l, r, v;&#125;t[MAXN &lt;&lt; 2];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void build(int l = 1, int r = n, int x = 1) &#123; t[x].l = l; t[x].r = r; t[x].v = INF; if (l == r) return ; int mid = (l + r) &gt;&gt; 1; build(l, mid, ls); build(mid + 1, r, rs);&#125;void pushup(int x) &#123; t[x].v = min(t[ls].v, t[rs].v);&#125;void modify(int p, int v, int x = 1) &#123; if (t[x].l == t[x].r) &#123; t[x].v = v; return ; &#125; int mid = (t[x].l + t[x].r) &gt;&gt; 1; if (p &lt;= mid) modify(p, v, ls); else modify(p, v, rs); pushup(x);&#125;int query(int l, int r, int x = 1) &#123; if (l &lt;= t[x].l &amp;&amp; t[x].r &lt;= r) return t[x].v; int mid = (t[x].l + t[x].r) &gt;&gt; 1, res = INF; if (l &lt;= mid) res = min(res, query(l, r, ls)); if (r &gt; mid) res = min(res, query(l, r, rs)); return res;&#125;void construct(int u, int l, int r) &#123; int v = query(l, r); if (v != INF) &#123; g[u].push_back(a[v]); ++deg[a[v]]; &#125;&#125;void topsort() &#123; priority_queue&lt;int, ve, gr&gt; q; for (int i = 1; i &lt;= n; ++i) if (!deg[i]) q.push(i); while (!q.empty()) &#123; int u = q.top(); ans[u] = ++total; q.pop(); for (int i = 0; i &lt; (int)g[u].size(); ++i) &#123; int v = g[u][i]; if (--deg[v] == 0) q.push(v); &#125; &#125;&#125;int main() &#123; n = read(); k = read(); build(); for (int i = 1; i &lt;= n; ++i) a[read()] = i; for (int i = n; i &gt;= 1; --i) &#123; construct(a[i], max(1, a[i] - k + 1), a[i]); construct(a[i], a[i], min(a[i] + k - 1, n)); modify(a[i], i); &#125; topsort(); for (int i = 1; i &lt;= n; ++i) printf("%d\n", ans[i]);&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>拓扑</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>线段树</tag>
        <tag>堆</tag>
        <tag>拓扑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1239E - Turtle]]></title>
    <url>%2F2019%2F10%2FCodeforces-1239E-Turtle%2F</url>
    <content type="text"><![CDATA[首先，有一个事实：左上和右下填的一定是最小的两个元素。 令最终排序后，两行元素分别为：$x_i, y_i$。 0 \ 1\ 2 \ 3 \ 4 \ 5 \\1 \ 2 \ 3 \ 4 \ 5 \ 0第一行是 $x$ ，第二行是 $y$ ，其中 $0$一开始就确定了。 \underline{0 \ 1 \ 2 \ 3 \ 4 \ 5} \\1 \ 2 \ 3 \ 4 \ 5 \ \underline0不妨假设一开始只走 $x$ ，即走上图。不妨用路径去推及别的，不难发现，每次减去第一行的 $i$ ，加上第二行的 $i$ 。即我们从一条路径可以加上 $y_i - x_i$，转变到下一条路径。如下图： \underline{0 \ 1 \ 2 \ 3 \ 4} \ \bold5 \\1 \ 2 \ 3 \ 4 \ \underline{\bold5 \ 0}对于这样的一个过程，对于终态和初态，显然贡献是：$\sum \limits_i x_i$ 和 $\sum \limits_i y_i$ ，那么减去一个 $x_i$ ，加上一个 $y_i$ ，我们希望尽可能小，此时 $x_i$ 递减， $y_i$ 递增一定是最优的——保证路径权值尽可能小。同时，由于 $y_i - x_i$ 的大小关系，会让路径权值呈以下情况： 所以海龟只走 $x$ 或者只走 $y$ 一定最优。 于是转化成了将所有的数划分成两个集合，使之最大值最小，背包即可解决，复杂度 $O(\frac{n^3a}{32})$ 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;#define MAXN 26#define MAXM 1200005using namespace std;int n, a[MAXN &lt;&lt; 1];int v[MAXN];vector&lt;int&gt; x, y;bitset&lt;MAXM&gt; f[MAXN &lt;&lt; 1][MAXN];int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= (n &lt;&lt; 1); ++i) scanf("%d", &amp;a[i]); sort(a + 1, a + (n &lt;&lt; 1) + 1); reverse(a + 1, a + (n &lt;&lt; 1) + 1); f[0][0][0] = 1; int sum = 0; for (int i = 1; i &lt;= (n - 1) &lt;&lt; 1; ++i) &#123; f[i][0][0] = 1; sum += a[i]; for (int j = 1; j &lt;= i &amp;&amp; j &lt;= n - 1; ++j) f[i][j] = f[i - 1][j] | (f[i - 1][j - 1] &lt;&lt; a[i]); &#125; int state = (n - 1) &lt;&lt; 1, rest = n - 1, half = sum &gt;&gt; 1; while (!f[state][n - 1][half]) --half; for (int i = (n - 1) &lt;&lt; 1; i &gt;= 1; --i) if (half &gt;= a[i] &amp;&amp; f[i - 1][rest - 1][half - a[i]] &amp;&amp; rest) &#123; x.push_back(a[i]); half -= a[i]; --rest; &#125; else y.push_back(a[i]); printf("%d ", a[(n &lt;&lt; 1) - 1]); for (int i = 0; i &lt; (int)x.size(); ++i) printf("%d ", x[i]); puts(""); for (int i = (int)y.size() - 1; i &gt;= 0; --i) printf("%d ", y[i]); printf("%d\n", a[n &lt;&lt; 1]);&#125;]]></content>
      <categories>
        <category>思维</category>
        <category>最优解</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1236E - Alice and the Unfair Game]]></title>
    <url>%2F2019%2F10%2FCodeforces-1236E-Alice-and-the-Unfair-Game%2F</url>
    <content type="text"><![CDATA[倍增不难发现，对于一个出发点，可行区间一定是连续的，于是变成了找左界和右界的问题。 贪心地看，需要尽可能的往左/往右走，同时，路途中，可能会遇到 $\mbox{Alice}$ 猜的格子，此时被阻挡，此轮无法向前，即： |s - i| = a_i被阻挡后继续向前时，容易发现可能会被阻挡更多次，即： j - i = a_i - a_j - 1其中 $j &gt; i$ 。 如此构成一个树形结构，]]></content>
      <categories>
        <category>思维</category>
        <category>集合</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>并查集</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1239A - Ivan the Fool and the Probability Theory]]></title>
    <url>%2F2019%2F10%2FCodeforces-1239A-Ivan-the-Fool-and-the-Probability-Theory%2F</url>
    <content type="text"><![CDATA[惭愧，这题都没有想出来。 主要原因在于手玩性质玩错了结果想不出来。 题目的要求等价于最多只能有大小为 $2$ 的连通块，其有两种形状，竖状和横状。 手玩的时候可以发现，对于一张图，只会出现竖状或者横状。 于是我们可以规定当前考虑的只有竖状，横状与之时等价的。 因为横状与竖状不会同时出现，大致有方程： f_i = f_{i - 1} + f_{i - 2}即枚举当前行/列是否使用大小为 $2$ 的块进行转移。 最终答案为： 2f_n + 2f_m - 2123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;#define MAXN 100005typedef long long lint;using namespace std;const int mod = 1e9 + 7;int n, m;lint f[MAXN];int main() &#123; f[0] = 1; f[1] = 1; scanf("%d%d", &amp;n, &amp;m); for (int i = 2; i &lt;= max(n, m); ++i) f[i] = (f[i - 1] + f[i - 2]) % mod; printf("%lld\n", (f[n] + f[m] - 1) * 2 % mod);&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>普通</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>Fibonacci</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu T103518 - 取数游戏]]></title>
    <url>%2F2019%2F10%2FLuogu-T103518-%E5%8F%96%E6%95%B0%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>思维</category>
        <category>倍增</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder AGC008F - Black Radius]]></title>
    <url>%2F2019%2F10%2FAtCoder-AGC008F-Black-Radius%2F</url>
    <content type="text"></content>
      <tags>
        <tag>solution/algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder AGC008E - Next or Nextnext]]></title>
    <url>%2F2019%2F10%2FAtCoder-AGC008E-Next-or-Nextnext%2F</url>
    <content type="text"><![CDATA[很有意思的一道题目。 这题需要逆向思考，假设已知 $p_i$ ，我们作 $i \rightarrow p_i$ ，由于 $p_i$ 是个排列，一定会得到若干个环。]]></content>
      <categories>
        <category>DP</category>
        <category>计数DP</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>solution</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder AGC007F - Shik and Copying String]]></title>
    <url>%2F2019%2F10%2FAtCoder-AGC007F-Shik-and-Copying-String%2F</url>
    <content type="text"><![CDATA[对于 $T$ 串上的每一个颜色段，都必须在 $S$ 串上和其依次对应。 一个很明显的贪心策略：对于每一个颜色段，从其在 $S$ 的最右边走起，直至其在 $T$ 的最左端。 对于每一层，即 $S_i$ ，我们一定尽可能靠着右边走，显然是最优的。 在这样的前提下，每一种颜色的的走法都会存在一个向右的拐点。对于一个颜色段左边的颜色段，其拐点的位置将会受到右边颜色段拐点的限制，也就是说一个拐点的影响是深远的。 于是用队列来维护拐点，队列中的每一个拐点都会产生一个褶皱： 褶皱的实质也是拐点，但他不在最上面。新添一个颜色就会新增一个拐点，对于一种颜色，我们只记录其最高的拐点： 首先，这个图是有假拐点的：$(1, 6),(2, 5),\cdots$ 他们是不对答案产生影响的，只是长得像，不能入队。 $(1, 4)$ 是真拐点，应入队。由此他产生了 $(2, 3), (3, 2)$ 两个褶皱，不需要入队。 只要一个拐点产生的褶皱能够延伸到当前列，则该拐点仍然产生影响。 队列里维护着对当前列产生影响的拐点，显然每有一个拐点都会使当前行产生一个褶皱，有多少个褶皱就必须拐弯几次，每一行只能拐一次，$s$ 为队列大小，答案为 $s + 1$ 。 新添一个颜色就会使所有的队列中拐点多一个褶皱，可以用此判断其是否能够影响到该列。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;#define MAXN 1000005using namespace std;int n;char s[MAXN], t[MAXN];int ans, head = 1, tail, q[MAXN];int main() &#123; scanf("%d", &amp;n); scanf("%s%s", s + 1, t + 1); if (!strcmp(s + 1, t + 1)) &#123; puts("0"); return 0; &#125; for (int i = n, j = n; i &gt;= 1; --i) &#123; if (t[i] == t[i - 1]) continue; j = min(j, i); while (j &amp;&amp; s[j] != t[i]) --j; if (!j) &#123; puts("-1"); return 0; &#125; while (head &lt;= tail &amp;&amp; q[head] - (tail - head + 1) + 1 &gt; i) ++head; q[++tail] = j; if (i != j) ans = max(ans, tail - head + 1); &#125; printf("%d\n", ans + 1);&#125;]]></content>
      <categories>
        <category>思维</category>
        <category>最优解</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>贪心</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder AGC007C - Pushing Balls]]></title>
    <url>%2F2019%2F10%2FAtCoder-AGC007C-Pushing-Balls%2F</url>
    <content type="text"><![CDATA[有一个不同的解法，写出来分享一下。 我的 定义 $h_i$ 为洞到原点的距离。 考虑计算一个路径被经过的期望次数，分两种情况讨论： 必然经过的距离 $2$ 号向左走的 $3$ 和向右走的 $4$ 就是必然经过的距离，贡献为： \sum \limits_{i - 1}^n\frac{1}{2}(h_i - h_{i - 1}) 可能经过的距离 即 $3$ 号向左可能会经过 $3+4$ 。 手模一下能够发现，倘若 $i$ 号小球能够到达 $j$ 号洞 $(j &lt; i)$ ，只需要满足 $i$ 方向向左，$j$ 方向向右即可，同时 $i \sim j$ 号球，$i$ 最后开始走。当 $j &gt; i$ 时同理，贡献为： \sum \limits_{i = 1}^n \sum \limits_{j \neq i} \frac{1}{4|i - j + 1|}(h_i - h_{i - 1})这个式子可以优化到 $O(n)$ 。 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;#define MAXN 200005using namespace std;int n, x;int d[MAXN &lt;&lt; 1], h[MAXN];int main() &#123; scanf("%d%d%d", &amp;n, &amp;d[1], &amp;x); for (int i = 2; i &lt;= (n &lt;&lt; 1); ++i) d[i] = d[i - 1] + x; for (int i = 1; i &lt;= (n &lt;&lt; 1); ++i) d[i] += d[i - 1]; for (int i = 1; i &lt;= n; ++i) h[i] = d[i &lt;&lt; 1]; long double ans = 0, sum = 0; for (int i = 2; i &lt;= n; ++i) sum += 1.0 / i; for (int i = 1; i &lt;= n; ++i) &#123; ans += (0.5 + 0.25 * sum) * (h[i] - h[i - 1]); sum = sum + 1.0 / (i + 1) - 1.0 / (n - i + 1); &#125; printf("%.10Lf\n", ans);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>期望</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 3934 - Nephren Ruq Insania]]></title>
    <url>%2F2019%2F10%2FLuogu-3934-Nephren-Ruq-Insania%2F</url>
    <content type="text"><![CDATA[题目要求： a_l^{a_{l + 1}^{a_{l + 2}^{\cdots^{a_{r}}}}}有欧拉定理，当 $x &lt; \varphi(p)$ 时： a^x \equiv a^x \mod p当 $x &gt; \varphi(p)$ 时： a^x = a^{x \bmod \varphi(p) + \varphi(p)} \mod p那么对于每一层，我们都可以进行如上形式的化简。 那么每进行一次扩展欧拉定理，模数都会变成 $\varphi(p)$ ，就算是 $x &lt; \varphi(p)$ 我们也可以进行如此的等价处理。 也就是说，我们会计算到一个值：$\varphi(\varphi(\varphi(\cdots)))$ ，不难发现其其最多做 $\log n$ 次。 小小的证明一下： $p$ 为奇数时，假设其为质数，则 $\varphi(p) = p - 1$ ，若其为偶数，则 $\varphi(p)$ 至多为 $\frac{p}{2}$ ，所以最多做 $\log n$ 次。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;bits/stdc++.h&gt;#define MAXN 500005#define lowbit(x) x &amp; -x#define MAXP 20000005typedef long long lint;using namespace std;const int P = 20000000;int n, m, phi[MAXP], v[MAXP], prime[MAXP], total;lint t[MAXN], a[MAXN];struct node &#123; lint v; bool isex; node(lint v = 0, bool isex = 0):v(v), isex(isex) &#123;&#125;&#125;;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void add(int x, int v) &#123; while (x &lt;= n) &#123; t[x] += v; x += lowbit(x); &#125;&#125;lint query(int x) &#123; lint res = 0; while (x) &#123; res += t[x]; x -= lowbit(x); &#125; return res;&#125;void init() &#123; phi[1] = 1; for (int i = 2; i &lt;= P; ++i) &#123; if (!v[i]) &#123; v[i] = 1; prime[++total] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= total &amp;&amp; 1ll * i * prime[j] &lt;= P; ++j) &#123; v[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; phi[i * prime[j]] = phi[i] * (prime[j] - 1); &#125; &#125;&#125;node power(lint a, int b, int p) &#123; node res(1, 0); if (a &gt;= p &amp;&amp; b) &#123; res.isex = 1; a %= p; &#125; while (b) &#123; if (b &amp; 1) res.v = res.v * a; if (res.v &gt;= p) &#123; res.v %= p; res.isex = true; &#125; a = a * a; if (a &gt;= p &amp;&amp; b) &#123; a %= p; res.isex = true; &#125; b &gt;&gt;= 1; &#125; return res;&#125;node DFS(int i, int limit, int p) &#123; lint v = query(i); if (p == 1) return node(0, 1); if (v == 1) return node(1, 0); if (i == limit) return v &lt; p ? node(v, 0) : node(v % p, 1); node res = DFS(i + 1, limit, phi[p]); return power(v, res.v + res.isex * phi[p], p);&#125;int main() &#123; n = read(); m = read(); init(); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = read(); add(i, a[i] - a[i - 1]); &#125; while (m--) &#123; int opt = read(), l = read(), r = read(), x = read(); if (opt == 1) &#123; add(l, x); add(r + 1, -x); &#125; else &#123; lint ans = DFS(l, r, x).v; printf("%lld\n", ans); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>数论</category>
        <category>欧拉定理</category>
        <category>扩展欧拉定理</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>扩展欧拉定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder AGC007E - Shik and Travel]]></title>
    <url>%2F2019%2F10%2FAtCoder-AGC007E-Shik-and-Travel%2F</url>
    <content type="text"><![CDATA[求最大值最小，先二分答案，然后进行决策。 考虑对每一个点，记录一个三元组 $(i, j, k)$ 表示点 $i$ 作为根，进去花费 $j$ ，出来花费 $k$ ，且子树中的点在花费二分的值以内可以互达。 对于每一个相同的 $j$，我们只保存最小的 $k$ ，对于 $k$ 我们只保存最小的 $j$ ，这样，由于以 $i$ 作为根节点时，$j$ 只有 $2\mbox{size}_i$ 种取值，即只有 $2\mbox{size}_i$ 个不同的三元组。于是，利用启发式合并的方法即可保证复杂度正确。 比较纳闷，我没有写启发式合并就过了？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;#define MAXN 150005typedef long long lint;using namespace std;int n;int ch[MAXN][2], val[MAXN][2], size[MAXN];struct node &#123; lint p, q; node(lint p = 0, lint q = 0):p(p), q(q) &#123;&#125; bool operator &lt; (const node b) const &#123; return p &lt; b.p || (p == b.p &amp;&amp; q &lt; b.q); &#125;&#125;;vector&lt;node&gt; a[MAXN];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void merge(lint limit, vector&lt;node&gt;&amp; u, vector&lt;node&gt;&amp; v, vector&lt;node&gt;&amp; w) &#123; if (!v.size() || !u.size()) return ; for (int i = 0, j = 0; i &lt; (int)u.size(); ++i) &#123; while (j + 1 &lt; (int)v.size() &amp;&amp; u[i].q + v[j + 1].p &lt;= limit) ++j; if (u[i].q + v[j].p &lt;= limit) &#123; node temp(u[i].p, v[j].q); if (w.size() &amp;&amp; temp.p &gt;= w[w.size() - 1].p &amp;&amp; temp.q &gt;= w[w.size() - 1].q) continue; w.push_back(temp); &#125; &#125;&#125;void DFS(int u, lint limit) &#123; a[u].clear(); if (!size[u]) &#123; a[u].push_back(node()); return ; &#125; for (int i = 0; i &lt; 2; ++i) &#123; int v = ch[u][i], w = val[u][i]; DFS(v, limit); for (int j = 0; j &lt; (int)a[v].size(); ++j) &#123; a[v][j].p += w; a[v][j].q += w; &#125; &#125; int ls = ch[u][0], rs = ch[u][1]; sort(a[ls].begin(), a[ls].end()); sort(a[rs].begin(), a[rs].end()); merge(limit, a[ls], a[rs], a[u]); merge(limit, a[rs], a[ls], a[u]);&#125;bool check(lint limit) &#123; DFS(1, limit); return a[1].size();&#125;int solve() &#123; lint l = 0, r = 1ll &lt;&lt; 34, res = -1; while (l &lt;= r) &#123; lint mid = (l + r) &gt;&gt; 1; if (check(mid)) &#123; res = mid; r = mid - 1; &#125; else l = mid + 1; &#125; return res;&#125;int main() &#123; n = read(); for (int i = 2; i &lt;= n; ++i) &#123; int f = read(), v = read(); ch[f][size[f]] = i; val[f][size[f]] = v; ++size[f]; &#125; lint ans = solve(); printf("%lld\n", ans);&#125;]]></content>
      <categories>
        <category>思维</category>
        <category>启发式合并</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>二分</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder AGC006E - Rotate 3x3]]></title>
    <url>%2F2019%2F10%2FAtCoder-AGC006E-Rotate-3x3%2F</url>
    <content type="text"><![CDATA[一类特殊的问题，索性给他分一个专门的类，感觉应该是与构造一样重要的。 首先可以发现奇数行只能和奇数行交换，偶数行只能和偶数行交换。 现在需要推几个结论，推之前先给每一列一个标号 $1 \sim n$ ，同时下划线表示翻转，反之未翻转。 中间两间隔行颠倒其他不变 12345 \rightarrow \underline{321}45 \rightarrow \underline{3254}1 \rightarrow 523\underline{4}1 \rightarrow 52\underline{1}4\underline{3} \rightarrow 1\underline{25}4\underline3 \rightarrow 1\underline23\underline{4}5 左边两间隔行颠倒其他不变 1\underline23\underline45 \rightarrow \underline32\underline{14}5 \rightarrow \underline341\underline25\rightarrow\underline{14}3\underline25 \rightarrow \underline12\underline345 右边两间隔行颠倒其他不变 该情况与前者相同，不再模拟。 于是，奇数行之间的交换只会对偶数行产生影响，偶数行同理。同时不难发现，奇数行的交换次数即为奇数行中逆序对的出现次数，偶数行同理，故我们可以确定奇数行/偶数行被改变了几次，若为奇数则无解，若为偶数则一定有方法使之消除影响。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define lowbit(x) x &amp; -xusing namespace std;int n, N;int a[MAXN][4], b[MAXN], c[MAXN], t[2][MAXN * 3], sum[2];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void add(int c, int x, int v) &#123; while (x &lt;= N) &#123; t[c][x] += v; x += lowbit(x); &#125;&#125;int query(int c,int x) &#123; int res = 0; while (x) &#123; res += t[c][x]; x -= lowbit(x); &#125; return res;&#125;int main() &#123; n = read(); N = n * 3; for (int j = 1; j &lt;= 3; ++j) for (int i = 1; i &lt;= n; ++i) a[i][j] = read(); for (int i = 1; i &lt;= n; ++i) &#123; if (a[i][1] &gt; a[i][2]) &#123; sum[i &amp; 1] ^= 1; swap(a[i][1], a[i][3]); &#125; b[i] = a[i][3]; if (a[i][1] != a[i][2] - 1 || a[i][2] != a[i][3] - 1 || b[i] % 3 != 0 || ((b[i] / 3) &amp; 1) != (i &amp; 1)) &#123; puts("No"); return 0; &#125; &#125; for (int i = n; i &gt;= 1; --i) &#123; sum[(i &amp; 1) ^ 1] ^= query(i &amp; 1, b[i] / 3) &amp; 1; add(i &amp; 1, b[i] / 3, 1); &#125; if ((sum[0] &amp; 1) || (sum[1] &amp; 1)) puts("No"); else puts("Yes");&#125;]]></content>
      <categories>
        <category>思维</category>
        <category>存在性</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>逆序对</tag>
        <tag>存在性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder AGC006D - Median Pyramid Hard]]></title>
    <url>%2F2019%2F10%2FAtCoder-AGC006D-Median-Pyramid-Hard%2F</url>
    <content type="text"><![CDATA[乍一看思路全无，还是由于对中位数这一类关键词的不够敏感所致。 首先一定要二分答案，将大于等于答案的数置为 $1$ ，小于答案的置为 $0$ 。 这样，在金字塔中的一位为 $1$ ，当且仅当其下面的三个节点至少有两个为 $1$ 。 这一套题全都要手模，实在令人着恼，但随后可以迅速发现，对于最下面一行的两个相邻的 $1$ 或 $0$ ，是可以“直线”上传的，证明是显然的。 1\\ 011\\ 00110\\ 0001100\\ 000011000以上是一个较为极端的情况，但可以帮助理解。 所以如果中间有两个相邻的 $0/1$ 马上可以判断答案正误，反之一定在有相邻的 $0/1$ 之前他们是相异的： 1\\ 011\\ 00111\\ 0010111\\ 001010111再出现右边两个相邻的 $1$ 之前中间是相异的，出现之后因为中间部分的相异性，即能向上“斜着”传递，同时也是满足“直线”传递的，如果 $0$ 离中间更近，显然无解。 最后，如果没有出现相邻的，只需要判断最左下为 $0/1$ ，防止： 0\\ 010\\ 01010\\ 0101010\\ 010101010\\12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define MAXN 200005using namespace std;int n, a[MAXN], b[MAXN], maxi;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;bool check(int w) &#123; for (int i = 1; i &lt;= 2 * n - 1; ++i) b[i] = a[i] &gt;= w; for (int i = 0; i &lt; n - 1; ++i) if ((b[n - i] &amp;&amp; b[n - i - 1]) || (b[n + i] &amp;&amp; b[n + i + 1])) return true; else if ((!b[n - i] &amp;&amp; !b[n - i - 1]) || (!b[n + i] &amp;&amp; !b[n + i + 1])) return false; return b[1];&#125;int solve() &#123; int l = 1, r = 2 * n - 1, res = -1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid)) &#123; res = mid; l = mid + 1; &#125; else r = mid - 1; &#125; return res;&#125;int main() &#123; n = read(); for (int i = 1; i &lt;= 2 * n - 1; ++i) maxi = max(maxi, a[i] = read()); int ans = solve(); printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>思维</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>二分</tag>
        <tag>中位数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[容斥]]></title>
    <url>%2F2019%2F10%2F%E5%AE%B9%E6%96%A5%2F</url>
    <content type="text"><![CDATA[咕了好久的一个知识点，稍微学习一下。 容斥原理公式 \left|\bigcup _{i=1}^{n}a_{i}\right|=\sum _{\emptyset \neq J\subseteq \{1,2,\ldots ,n\}}(-1)^{|J|-1}{\Biggl |}\bigcap _{j\in J}a_{j}{\Biggr |}证明换而言之，我们需要证明每一个 $a_j$ 只被计算一次，有以下证明： 首先 $a_j$ 被计算的次数应该是： \sum \limits_{i = 1}^n (-1)^{i - 1}\pmatrix{n \\ i}所以需要证明该式恒等 $1$ ： \begin{align*} &= \sum \limits_{i = 1}^n (-1)^{i - 1} \times \bigg(\pmatrix{n - 1 \\ i} + \pmatrix{n - 1 \\ i - 1}\bigg) \\ &= \sum \limits_{i = 1}^{n - 1} (-1)^{i - 1}\pmatrix{n - 1 \\ i} + \sum \limits_{i = 1}^{n - 1} (-1)^{i}\pmatrix{n - 1 \\ i} + \pmatrix{n - 1 \\ 0} \\ &= 1 \end{align*}容斥系数对于以上的 $(-1)^{i - 1}$ ，本质上就是一个容斥系数，而 $n$ 就是满足限制条件的个数。 一般对于一个题目，我们需要构造： \sum \limits_{i = 1}^n \pmatrix{n \\ i} f(i) = s$s$ 应为满足 $n$ 个条件所带来的权值，在普通容斥原理中 $s = 1$ ，可以用 $n^2$ 的方法得出 $f(i)$ 。]]></content>
      <categories>
        <category>思维</category>
        <category>容斥</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder AGC005F - Many Easy Problems]]></title>
    <url>%2F2019%2F10%2FAtCoder-AGC005F-Many-Easy-Problems%2F</url>
    <content type="text"><![CDATA[有一说一，这题一开始最难。 如果强算连通块的大小，利用 $\mbox{DP}$ 进行转移，无论如何优化最后复杂度一定是 $O(n^2)$ 的，对于这题显然不适用。 正难则反，不如计算一个点的贡献——这样就将问题转化为了计算一个点存在与多少不同的连通块中。 这个问题是显然的，容斥一下有： \begin{align*} f(k) &= \sum \limits_{i = 1}^n\bigg(\pmatrix{n \\ k} - \sum \limits_{j\in s_i} \pmatrix{s_j \\ k} \bigg) \\ f(k) &= n \pmatrix{n \\ k} - \sum \limits_{i = 1}^n\sum \limits_{j\in s_i} \pmatrix{s_j \\ k} \end{align*}观察后面的式子，每一个节点显然只会被统计到一次，我们令 $g(k)$ 表示后面的式子，有： \begin{align*} g(k) &= \sum \limits_{i = 1}^n \lambda(i) \pmatrix{i \\ k} \\ g(k)k! &= \sum \limits_{i = 1}^n \lambda(i) i! \frac{1}{(i - k)!} \end{align*}$\lambda(i)$ 表示有 $\lambda(i)$ 个节点的子树大小为 $i$ 。 后面是卷积的形式，卷积即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;bits/stdc++.h&gt;#define MAXN 800005typedef long long lint;using namespace std;const int G = 5, mod = 924844033;int n;int size[MAXN], times[MAXN], head[MAXN], cnt;lint fac[MAXN], inf[MAXN], a[MAXN], b[MAXN];int r[MAXN];struct data &#123; int next, to; data(int next = 0, int to = 0):next(next), to(to) &#123;&#125;&#125;edge[MAXN &lt;&lt; 1];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void connect(int u, int v) &#123; edge[++cnt] = data(head[u], v); head[u] = cnt;&#125;void DFS(int u, int pre) &#123; size[u] = 1; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to; if (v == pre) continue; DFS(v, u); size[u] += size[v]; ++times[size[v]]; &#125; ++times[n - size[u]];&#125;lint power(lint a, int b) &#123; lint res = 1; while (b) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;void NTT(lint* a, int n, int opt) &#123; for (int i = 0; i &lt; n; ++i) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int i = 1; i &lt; n; i &lt;&lt;= 1) &#123; lint gn = power(opt == 1 ? G : power(G, mod - 2), (mod - 1) / (i &lt;&lt; 1)); for (int j = 0; j &lt; n; j += (i &lt;&lt; 1)) &#123; lint g = 1; for (int k = 0; k &lt; i; ++k) &#123; lint x = a[j + k], y = a[j + k + i] * g % mod; a[j + k] = (x + y) % mod; a[j + k + i] = (x - y + mod) % mod; g = g * gn % mod; &#125; &#125; &#125; if (opt == -1) &#123; lint inv = power(n, mod - 2); for (int i = 0; i &lt; n; ++i) a[i] = inv * a[i] % mod; &#125;&#125;int getr(int n) &#123; int limit = 1, size = 0; while (limit &lt;= n) &#123; limit &lt;&lt;= 1; ++size; &#125; for (int i = 0; i &lt; limit; ++i) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (size - 1)); return limit;&#125;void init() &#123; inf[0] = fac[0] = 1; for (int i = 1; i &lt;= n; ++i) fac[i] = fac[i - 1] * i % mod; inf[n] = power(fac[n], mod - 2); for (int i = n - 1; i &gt;= 1; --i) inf[i] = inf[i + 1] * (i + 1) % mod;&#125;lint C(int n, int m) &#123; return fac[n] * inf[n - m] % mod * inf[m] % mod;&#125;int main() &#123; n = read(); for (int i = 1; i &lt; n; ++i) &#123; int u = read(), v = read(); connect(u, v); connect(v, u); &#125; DFS(1, 0); init(); for (int i = 0; i &lt;= n; ++i) &#123; a[i] = fac[n - i] * times[n - i] % mod; b[i] = inf[i]; &#125; int limit = getr(n &lt;&lt; 1); NTT(a, limit, 1); NTT(b, limit, 1); for (int i = 0; i &lt; limit; ++i) a[i] = a[i] * b[i] % mod; NTT(a, limit, -1); for (int i = 0; i &lt; n; ++i) printf("%lld\n", (C(n, i + 1) * n % mod - a[n - i - 1] * power(fac[i + 1], mod - 2) % mod + mod) % mod);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>组合数学</category>
        <category>生成函数</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder AGC005E - Sugigma: The Showdown]]></title>
    <url>%2F2019%2F10%2FAtCoder-AGC005E-Sugigma-The-Showdown%2F</url>
    <content type="text"><![CDATA[$E$ 题比 $D$ 题简单系列？ 考虑一种情况使得 $A$ 一定必胜，模拟一下就可以发现对于 $A$ 树上的一条边，倘若其两点在 $B$ 树上的距离大于 $2$ ，则小 $A$ 在这一条边上必胜——当然小 $A$ 必须能够走到这条边。我们称这些边为必胜边。 那么如何判断 $A$ 树上，小 $A$ 是否能够到达其上的某一个点？能到达该点当且仅当小 $A$ 从初始点到该点路径上的任意一个点所花费的时间都大于小 $B$ 到该点所花费的时间。于是能够判断小 $A$ 是否能够到达一个必胜点或者小 $A$ 最久能够撑多久。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;#define MAXN 200005using namespace std;int n, s, t, ans;struct graph &#123; vector&lt;int&gt; g[MAXN]; int fa[MAXN][19], dep[MAXN]; void connect(int u, int v) &#123; g[u].push_back(v); g[v].push_back(u); &#125; void build(int u = s, int pre = 0) &#123; fa[u][0] = pre; dep[u] = dep[pre] + 1; for (int i = 1; i &lt;= 18; ++i) fa[u][i] = fa[fa[u][i - 1]][i - 1]; for (int i = 0; i &lt; (int)g[u].size(); ++i) &#123; int v = g[u][i]; if (v == pre) continue; build(v, u); &#125; &#125; int query(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); for (int i = 18; i &gt;= 0; --i) if (dep[fa[u][i]] &gt;= dep[v]) u = fa[u][i]; if (u == v) return u; for (int i = 18; i &gt;= 0; --i) if (fa[u][i] != fa[v][i]) &#123; u = fa[u][i]; v = fa[v][i]; &#125; return fa[u][0]; &#125; int calc(int u, int v) &#123; return dep[u] + dep[v] - dep[query(u, v)] * 2; &#125;&#125;A, B;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;bool DFS(int u, int pre) &#123; if (A.dep[u] - 1 &gt;= B.calc(t, u)) return false; for (int i = 0; i &lt; (int)A.g[u].size(); ++i) &#123; int v = A.g[u][i]; if (v == pre) continue; if (B.calc(u, v) &gt; 2 || DFS(v, u)) return true; &#125; return false;&#125;void find(int u, int pre) &#123; if (A.dep[u] - 1 &gt; B.calc(t, u)) return ; ans = max(ans, B.calc(t, u) * 2); for (int i = 0; i &lt; (int)A.g[u].size(); ++i) &#123; int v = A.g[u][i]; if (v == pre) continue; find(v, u); &#125;&#125;int main() &#123; n = read(); s = read(); t = read(); for (int i = 1; i &lt; n; ++i) A.connect(read(), read()); for (int i = 1; i &lt; n; ++i) B.connect(read(), read()); A.build(); B.build(); bool isinfinity = DFS(s, 0); if (isinfinity) puts("-1"); else &#123; find(s, 0); printf("%d\n", ans); &#125;&#125;]]></content>
      <categories>
        <category>思维</category>
        <category>博弈论</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder AGC005D - ~K Perm Counting]]></title>
    <url>%2F2019%2F10%2FAtCoder-AGC005D-K-Perm-Counting%2F</url>
    <content type="text"><![CDATA[$D$ 题比 $E$ 题难系列？ 对于这种限制严格的，一般用容斥解决。 所以我们可以设 $f(k)$ 表示恰有 $k$ 个条件不被满足的，不好计算，所以转而设 $g(k)$ 表示至少有 $k$ 个条件不被满足的。这样是好转移的，我们稍后再讲。 那么显然有一个式子： f(k) = \sum \limits_{i = k}^n \pmatrix{i \\ k}g(i)二项式反演显然有： g(k) = \sum \limits_{i = k}^n (-1)^{i - k}\pmatrix{i \\ k}f(i)我们所求的答案为 $g(0)$ ，所以随便算一下就行了。 关于如何计算 $f(k)$ 的，不妨形象地把图想象为二分图，那么有： 我们可以把相距 $k$ 的点看作一条链，然后把互不相关的几条链强行拼接起来 $\mbox{DP}$ ，但是保证拼接的地方不相连，本质还是分开做，但这样算快些。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;#define MAXN 4005typedef long long lint;using namespace std;int n, m, total;lint f[MAXN][MAXN][2], ans;lint fac[MAXN];bool illegal[MAXN];const int mod = 924844033;void init() &#123; fac[0] = 1; for (int i = 1; i &lt;= n; ++i) fac[i] = fac[i - 1] * i % mod;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); init(); for (int i = 1; i &lt;= m; ++i) for (int j = 0; j &lt;= 1; ++j) for (int k = i; k &lt;= n; k += m) &#123; ++total; if (k == i) illegal[total] = true; &#125; f[0][0][0] = 1; for (int i = 1; i &lt;= total; ++i) for (int j = 0; j &lt;= i; ++j) &#123; f[i][j][0] = (f[i - 1][j][0] + f[i - 1][j][1]) % mod; if (!illegal[i]) f[i][j][1] = f[i - 1][j - 1][0]; &#125; for (int i = 0; i &lt;= n; ++i) if (i &amp; 1) ans = (ans - fac[n - i] % mod * (f[total][i][0] + f[total][i][1]) % mod) % mod; else ans = (ans + fac[n - i] % mod * (f[total][i][0] + f[total][i][1]) % mod) % mod; printf("%lld\n", (ans + mod) % mod);&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>计数DP</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>solution</tag>
        <tag>二项式反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder AGC004F - Namori]]></title>
    <url>%2F2019%2F09%2FAtCoder-AGC004F-Namori%2F</url>
    <content type="text"><![CDATA[好神仙的一道题，一定要好好的记录一下。 首先考虑一棵树的情况，倘若直接 $\mbox{DP}$ 必然是行不通的，转移是由后效性的。 树有一个性质：树是一张二分图，按照深度的奇偶性，可以将其分为两个集合。倘若把集合 $1$ 中的元素想象成一颗颗球，集合 $2$ 中的元素想象成一个个盒子，那么题目的对边取反则意味着小球的转移，所以最终态为小球全部转移到集合 $2$ 的最小步数，即小球与盒子对应后的最短距离。 将有小球的点置为 $1$ ，有盒子的点置为 $-1$ ，那么设其子树和为 $s_i$ ，总答案就是： \sum \limits_{i = 1}^n |s_i|当然，根节点的点权和一定为 $0$ 。 现在来考虑基环树的情况。由于树的深度的奇偶性对答案是产生影响的，所以需要对基环的长度分开来讨论： 偶环 偶环是不对深度的奇偶性产生影响的。先去掉环 $c$ 上一条边 $(s, t)$ ，按照树的方式做。考虑到 $s_i$ 就是多出的小球数量/缺少的小球数量，所以每一条边上都是有小球数量的转移的。那么设 $(s, t)$ 这条边经过了 $x$ 个小球，方向由 $x$ 的正负决定，那么环 $c$ 上的点 $i$ 的子树和就会变成：$s_i - x$ ，所以环上的点的总贡献有： \sum \limits_{i \in c} |s_i - x|这显然是求 $s_i$ 的中位数了， 奇环 奇环是对深度的奇偶性产生影响的。显然，每一个点是自行可以选择自己的奇偶的，于是当且仅当点的个数是奇数时无解。 那么只要改变一半点的奇偶性，根节点的权值就是 $0$ 。同时，对除环上的节点的点权和是不会影响的：改变奇偶性势必需要走到环上，一定较之前更劣。 所以会有 $\frac{p}{2}$ 的小球从这条边上经过，所以环上其他边少走了 $\frac{p}{2}$ 的小球，此处小球仍然是有方向的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;int n, m;int f[MAXN], fa[MAXN], anc[MAXN], dep[MAXN], s = 1, t;vector&lt;int&gt; g[MAXN];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;int find(int x) &#123; return anc[x] == x ? x : anc[x] = find(anc[x]);&#125;void DFS(int u, int pre, int type) &#123; f[u] = type; fa[u] = pre; dep[u] = dep[pre] + 1; for (int i = 0; i &lt; (int)g[u].size(); ++i) &#123; int v = g[u][i]; if (v == pre) continue; DFS(v, u, -type); f[u] += f[v]; &#125;&#125;int main() &#123; n = read(); m = read(); for (int i = 1; i &lt;= n; ++i) anc[i] = i; for (int i = 1; i &lt;= m; ++i) &#123; int u = read(), v = read(); if (find(u) == find(v)) &#123; s = u; t = v; continue; &#125; anc[find(u)] = find(v); g[u].push_back(v); g[v].push_back(u); &#125; DFS(s, 0, 1); if (m == n - 1) &#123; if (f[s] != 0) &#123; puts("-1"); return 0; &#125; int res = 0; for (int i = 1; i &lt;= n; ++i) res += abs(f[i]); printf("%d\n", res); &#125; else if (dep[t] &amp; 1) &#123; int minus = f[s], res = 0; if (minus &amp; 1) &#123; puts("-1"); return 0; &#125; res += abs(minus &gt;&gt; 1); f[s] = 0; for (int i = t; i != s; i = fa[i]) f[i] -= (minus &gt;&gt; 1); for (int i = 1; i &lt;= n; ++i) res += abs(f[i]); printf("%d\n", res); &#125; else &#123; if (f[s] != 0) &#123; puts("-1"); return 0; &#125; vector&lt;int&gt; circle; for (int i = t; i != s; i = fa[i]) &#123; circle.push_back(f[i]); f[i] = 0; &#125; circle.push_back(0); sort(circle.begin(), circle.end()); int v = circle[((circle.size() + 1) &gt;&gt; 1) - 1], res = 0; for (int i = 0; i &lt; (int)circle.size(); ++i) res += abs(circle[i] - v); for (int i = 1; i &lt;= n; ++i) res += abs(f[i]); printf("%d\n", res); &#125;&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>树形DP</category>
        <category>基环树DP</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>基环树DP</tag>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder AGC002F - Leftmost Ball]]></title>
    <url>%2F2019%2F09%2FAtCoder-AGC002F-Leftmost-Ball%2F</url>
    <content type="text"><![CDATA[似乎在以前见过一次。 首先可以发现，由于白球的干扰，纵使放置方法不同，颜色序列也是相同的，于是在 $\mbox{DP}$ 中加入一个维度来规避重复计算。 于是令 $f_{i, j}$ 表示已经放了 $i$ 个白球和 $j$ 种颜色的方案数。 考虑什么情况是合法的：对于任意一段前缀，其白球的数量都不小于颜色的数量。 于是，我们在转移白球的时候，一定放在最前面的那个位置： f_{i, j} = f_{i, j - 1}对于放置一种颜色，显然可以在剩下的空位中随意放置，于是有： f_{i, j} = f_{i, j - 1} \times \pmatrix{n \times k - (j - 1) \times (k - 1) - i - 1 \\k - 2 } \times(n - j + 1)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;typedef long long lint;#define MAXN 2005using namespace std;int n, k;lint f[MAXN][MAXN], fac[MAXN * MAXN], inf[MAXN * MAXN];const int mod = 1e9 + 7, N = 4000000;lint power(lint a, int b) &#123; lint res = 1; while (b) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;void init() &#123; inf[0] = fac[0] = 1; for (int i = 1; i &lt;= N; ++i) fac[i] = fac[i - 1] * i % mod; inf[N] = power(fac[N], mod - 2); for (int i = N - 1; i &gt;= 1; --i) inf[i] = inf[i + 1] * (i + 1) % mod;&#125;lint C(int n, int m) &#123; return fac[n] * inf[n - m] % mod * inf[m] % mod;&#125;int main() &#123; init(); scanf("%d%d", &amp;n, &amp;k); if (k == 1) &#123; puts("1"); return 0; &#125; f[0][0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt;= i; ++j) if (!j) f[i][j] = f[i - 1][j]; else f[i][j] = (f[i - 1][j] + f[i][j - 1] * C(n * k - (j - 1) * (k - 1) - i - 1, k - 2) % mod * (n - j + 1) % mod) % mod; printf("%lld\n", f[n][n]);&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>计数DP</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>solution</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder AGC003E - Sequential operations on Sequence]]></title>
    <url>%2F2019%2F09%2FAtCoder-AGC003E-Sequential-operations-on-Sequence%2F</url>
    <content type="text"><![CDATA[由于减小操作本质是不产生影响的，所以读入时维护一个单调栈使得序列长度递增。 长的序列是由短的序列重复而来的，称这个短的序列为该序列的子序列。 故可以计算一个子序列在序列中出现了多少次，这就是他的总贡献次数；接着考虑到这个子序列是由子序列的子序列组成而来的，那么可以计算子序列的子序列的总贡献次数……以此类推，直到贡献到最初始的那个序列为止。在最初始的序列中，每个数只出现一次。这个每次只回推一次，总复杂度 $O(n)$ 。 当然组成时还有结尾的一小部分是没有囊括在内的，成为尾序列。考虑到它一定和子序列有着相同的前缀，于是可以二分找到这个位置，就知道了该尾序列的子序列。若该子序列恰好构成尾序列，那么不用回溯，否则找出尾序列的尾序列，递归处理。 最近还是需要注意一下整数运算中的取整，卡了一小时。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;#define MAXN 100005typedef long long lint;using namespace std;int n, m, b;lint a[MAXN], times[MAXN], remain[MAXN], sum[MAXN];lint read() &#123; char c = getchar(); lint x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void find(lint p, lint val) &#123; while (p) &#123; if (p &lt;= a[1]) &#123; sum[p] += val; return ; &#125; int x = int(upper_bound(a + 1, a + n + 1, p) - a - 1); lint np = p % a[x]; times[x] += val * int(p / a[x]); p = np; &#125;&#125;int main() &#123; a[n = 1] = b = (int)read() ; m = (int)read(); for (int i = 1; i &lt;= m; ++i) &#123; lint x = read(); while (n &gt;= 1 &amp;&amp; a[n] &gt;= x) --n; a[++n] = x; &#125; for (int i = 2; i &lt;= n; ++i) remain[i] = a[i] - a[i - 1] * (a[i] / a[i - 1]); times[n] = 1; for (int i = n; i &gt;= 2; --i) &#123; find(remain[i], times[i]); times[i - 1] += times[i] * (a[i] / a[i - 1]); &#125; for (int i = (int)a[1] - 1; i &gt;= 1; --i) sum[i] += sum[i + 1]; for (int i = 1; i &lt;= a[1]; ++i) sum[i] += times[1]; for (int i = 1; i &lt;= b; ++i) printf("%lld\n", sum[i]);&#125;]]></content>
      <categories>
        <category>思维</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1137E - Train Car Selection]]></title>
    <url>%2F2019%2F09%2FCodeforces-1137E-Train-Car-Selection%2F</url>
    <content type="text"><![CDATA[首先应该有以下两个结论： 加进来的一组点当中只有第一个可能会对答案产生贡献； 如果从开头加入一组点，剩下的点不可能成为答案。 所以本质上是对 $m + 1$ 个点进行讨论。 所以每个数加入以后他的位置不变。 因为答案是一次函数的形式，且可以用 $\sum s_i$ 直接计算答案，考虑可以维护一个下凸壳。 至于在加入之前的 $3$ 操作，可以直接计算出贡献减去。 考虑完这些这题就十分常规了，这题最后和下凸壳相切的直线斜率是正的，故理论上只会和最右边的点相切，但是题目有要求需要编号最小，所以稍微判断一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;typedef long long lint;#define MAXN 300005using namespace std;int n, m, top;lint b, s;struct node &#123; lint x, y; node(lint x = 0, lint y = 0):x(x), y(y) &#123;&#125;&#125;sta[MAXN];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;double slope(node a, node b) &#123; return (double)(a.y - b.y) / (double)(a.x - b.x);&#125;lint calc(node a) &#123; return a.x * s + a.y + b;&#125;int main() &#123; n = read(); m = read(); sta[++top] = node(0, 0); while (m--) &#123; int opt = read(); if (opt == 1) &#123; int k = read(); b = s = 0; sta[top = 1] = node(0, 0); n += k; &#125; else if (opt == 2) &#123; int k = read(); node cur(n, -b - s * n); n += k; while (top &gt;= 2 &amp;&amp; slope(sta[top - 1], sta[top]) &gt; slope(sta[top], cur)) --top; sta[++top] = cur; &#125; else &#123; int B = read(), S = read(); b += B; s += S; &#125; while (top &gt;= 2 &amp;&amp; calc(sta[top]) &gt;= calc(sta[top - 1])) --top; printf("%lld %lld\n", sta[top].x + 1, calc(sta[top])); &#125;&#125;]]></content>
      <categories>
        <category>思维</category>
        <category>单调</category>
        <category>单调栈</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>单调栈</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 917D - Strangers Trees]]></title>
    <url>%2F2019%2F09%2FCodeforces-917D-Strangers-Trees%2F</url>
    <content type="text"><![CDATA[如果只连原图中的 $n - k$ 条边，那么只有 $k$ 个连通块，他们都是树形结构。 我们先不管会不会和原图的边重复，如果找一种方法使得这 $k$ 个连通块构成一棵树，方案数应该是： n^{k - 2} \cdot \prod \limits_{i \in S} \mbox{size}_i$S$ 是该森林的连通块集合。 首先由 $\mbox{Prufer}$ 序列可以知道 $n$ 个点无标号完全图的生成树方案数为：$n^{n - 2}$ ，但是此处只有 $k$ 个连通块，每个连通块中的节点应该视作一个同时而不视作一个。显然连通块与另一个连通块之间只会连一条边，那么 $\mbox{Prufer}$ 的长度应该只有 $k - 2$ 。但是连通块里的点都是互不相同的，连接两个连通块应该可以视作连接这两个连通块中的任意节点，所以每一个节点都可以填入。 由于 $\mbox{Prufer}$ 序列加入的是删除点的父亲节点，所以我们不知道删除点是哪一个点。由于每一个点只有一个父亲，所以一个连通块所看作的点只会被删去一次，这个连通块中的任意一个点都可以被删去，所以贡献 $\mbox{size}_i$ 。 前面很好处理，所以需要 $\mbox{DP}$ 出 $\prod \limits_{i \in S} \mbox{size}_i$ 。 设 $f_{i, j, k}$ 表示第 $i$ 个点，点 $i$ 所在的连通块的大小 $j$ ，已经连了 $k$ 条边，此时 $i$ 所在连通块大小尚未乘进去。 然后树形背包解决一下，虽然看着有 $O(n^5)$ ，但是树形背包精细实现是 $O(nk)$ 的。证明树形背包是 $O(nk)$ ： 每一次合并 $(i, j)$，$i$ 是 $j$ 的父亲，那么树形背包的实质可以看作子树 $i$ （不包括 $j$ ）的所有节点与子树 $j$ 的所有节点分别互相对应一次。显然只有 $O(n^2)$ 次对应，因为对应完了就合并在了一起。 所以应该是 $O(n^4)$ 的，但是大概率跑不到，一般是 $O(n^3)$ 的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;#define MAXN 105typedef long long lint;using namespace std;const int mod = 1e9 + 7;int n;lint g[MAXN], f[MAXN][MAXN][MAXN], fac[MAXN], temp[MAXN][MAXN];int size[MAXN];int head[MAXN], cnt;struct data &#123; int next, to; data(int next = 0, int to = 0):next(next), to(to) &#123;&#125;&#125;edge[MAXN &lt;&lt; 1];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void connect(int u, int v) &#123; edge[++cnt] = data(head[u], v); head[u] = cnt;&#125;lint power(lint a, int b) &#123; b = (b + mod - 1) % (mod - 1); lint res = 1; while (b) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;void DFS(int u, int pre) &#123; size[u] = f[u][1][0] = 1; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to; if (v == pre) continue; DFS(v, u); memset(temp, 0, sizeof(temp)); for (int j = 1; j &lt;= size[u]; ++j) for (int k = 1; k &lt;= size[v]; ++k) for (int p = 0; p &lt;= size[u]; ++p) for (int q = 0; q &lt;= size[v]; ++q) &#123; temp[j + k][p + q] = (temp[j + k][p + q] + f[u][j][p] * f[v][k][q] % mod) % mod; temp[j][p + q + 1] = (temp[j][p + q + 1] + f[u][j][p] * f[v][k][q] % mod * k % mod) % mod; &#125; memcpy(f[u], temp, sizeof(temp)); size[u] += size[v]; &#125;&#125;void init() &#123; fac[0] = 1; for (int i = 1; i &lt;= n; ++i) fac[i] = fac[i - 1] * i % mod;&#125;lint C(int n, int m) &#123; return fac[n] * power(fac[m], mod - 2) % mod * power(fac[n - m], mod - 2) % mod;&#125;int main() &#123; n = read(); for (int i = 1; i &lt; n; ++i) &#123; int u = read(), v = read(); connect(u, v); connect(v, u); &#125; DFS(1, 0); init(); for (int i = 0; i &lt; n; ++i) &#123; lint base = power(n, n - i - 2); for (int j = 1; j &lt;= n; ++j) g[i] = (g[i] + base * f[1][j][n - i - 1] % mod * j % mod) % mod; &#125; for (int i = n - 1; i &gt;= 0; --i) for (int j = i + 1; j &lt; n; ++j) g[i] = (g[i] - g[j] * C(j, i) % mod) % mod; for (int i = 0; i &lt; n; ++i) printf("%lld ", (g[i] + mod) % mod);&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>树形DP</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>计数</tag>
        <tag>树形DP</tag>
        <tag>Prufer序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1082F - Speed Dial]]></title>
    <url>%2F2019%2F09%2FCodeforces-1082F-Speed-Dial%2F</url>
    <content type="text"><![CDATA[将 $\mbox{Trie}$ 树建出来后，可以将题意转化为：树上有一些目标节点，要求确定一些点使得目标节点到这些节点的距离乘上权值之和最小。姑且把这些点称之为统治点。 考虑到一个节点有且仅有一个统治点，且他的子节点的统治点有可能和他的相同，设 $f_{i, j, k}$ 为节点 $i$ ，统治点为 $j$ ，子树中有 $k$ 个统治点，因此枚举子节点的统治点后即可利用树形背包转移。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;#define MAXN 505#define MAXM 15#define INF 0x3f3f3f3fusing namespace std;int n, m, len[MAXN], times[MAXN];int ch[MAXN][10], fa[MAXN], dep[MAXN], amount[MAXN], total = 1, root = 1;bool isleaf[MAXN];int f[MAXN][MAXN][MAXM];char s[MAXN][MAXN];void append(char* s, int n, int m) &#123; int u = root; for (int i = 1; i &lt;= n; ++i) &#123; int c = s[i] - '0'; if (!ch[u][c]) &#123; fa[ch[u][c] = ++total] = u; dep[ch[u][c]] = dep[u] + 1; &#125; u = ch[u][c]; &#125; amount[u] += m;&#125;int DFS(int u, int p, int q) &#123; if (~f[u][p][q]) return f[u][p][q]; int h[MAXM], g[MAXM]; memset(h, 0x3f, sizeof(h)); if (u != p) h[0] = (dep[u] - dep[p]) * amount[u]; else h[1] = 0; for (int i = 0; i &lt;= 9; ++i) &#123; if (!ch[u][i]) continue; int v = ch[u][i]; memset(g, 0x3f, sizeof(g)); for (int j = 0; j &lt;= q; ++j) for (int k = 0; j + k &lt;= q; ++k) g[j + k] = min(g[j + k], h[j] + min(DFS(v, p, k), k ? DFS(v, v, k) : INF)); for (int j = 0; j &lt;= q; ++j) h[j] = g[j]; &#125; for (int i = 0; i &lt;= q; ++i) f[u][p][i] = h[i]; return f[u][p][q];&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); if (m &gt;= n) &#123; puts("0"); return 0; &#125; for (int i = 1; i &lt;= n; ++i) &#123; scanf("%s%d", s[i] + 1, &amp;times[i]); append(s[i], (int)strlen(s[i] + 1), times[i]); &#125; memset(f, -1, sizeof(f)); int ans = INF; for (int i = 0; i &lt;= m + 1; ++i) ans = min(ans, DFS(root, root, i)); printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>树形DP</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>树形DP</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1146D - Frog Jumping]]></title>
    <url>%2F2019%2F09%2FCodeforces-1146D-Frog-Jumping%2F</url>
    <content type="text"><![CDATA[对于数据范围较小的部分，可以直接搜索解决：每个点至多被访问一次，故时间复杂度是线性的。 考虑裴蜀定理： ax + by = (a, b)同时我们知道，对于一个不定方程： ax + by = c其有解当且仅当： (a, b) | c所以 $(a, b)$ 显然是最小步长，所以有以下递推式： f(x + a) = f(x) + \frac{a}{(a, b)}成立的一个充分条件是： x \geq a + b因为考虑每次往前走都可以往后走抵消，最坏的情况就是由 $b - 1$ 往后走 $a$ 步到达 $a + b - 1$ 。 故上面那个限定为充分条件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;typedef long long lint;#define MAXN 1000005using namespace std;lint n, a, b, x, y;lint c;lint f[MAXN];bool visit[MAXN];lint gcd(lint a, lint b) &#123; return !b ? a : gcd(b, a % b);&#125;void DFS(int i, int id) &#123; ++f[id]; visit[i] = true; if (i + a &lt;= id &amp;&amp; !visit[i + a]) DFS(i + (int)a, id); if (i - b &gt;= 0 &amp;&amp; !visit[i - b]) DFS(i - (int)b, id);&#125;lint bruteforce(lint n) &#123; f[0] = 1; visit[0] = 1; lint ans = 1; for (int i = 1; i &lt;= n; ++i) &#123; f[i] = f[i - 1]; if (i - a &gt;= 0 &amp;&amp; visit[i - a]) DFS(i, i); ans += f[i]; &#125; return ans;&#125;int main() &#123; scanf("%I64d%I64d%I64d", &amp;n, &amp;a, &amp;b); if (n &lt;= a + b + a) &#123; printf("%I64d\n", bruteforce(n)); return 0; &#125; lint ans = bruteforce(a + b + a), step = a / gcd(a, b); for (lint i = a + b + 1; i &lt;= a + b + a; ++i) &#123; lint times = (n - i) / a + 1; ans += (f[i] + f[i] + (times - 1) * step) * times / 2 - f[i]; &#125; printf("%I64d\n", ans);&#125;]]></content>
      <categories>
        <category>思维</category>
        <category>构造</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>搜索</tag>
        <tag>裴蜀定理</tag>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1146G - Zoning Restrictions]]></title>
    <url>%2F2019%2F08%2FCodeforces-1146G-Zoning-Restrictions%2F</url>
    <content type="text"><![CDATA[考虑一个区间是否要收取罚款只与最大的那个有关，所以有状态：$f_{i, j, k}$ 表示区间 $[i,j]$ ，最大的数为 $k$ 的最大利润。 如果对于一个限制，已经有一个位置放置了严格高于的房子，那么显然其他区域也可以放置且不消耗代价。那么我们只需要在一个区间找一个位置确定房子高度，然后枚举左右两边的房子高度即可。 当然，只有在某个限制是当前区间的子区间才罚款计入答案，不然会重复统计。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define MAXN 55using namespace std;int n, h, m;int l[MAXN], r[MAXN], x[MAXN], c[MAXN];int f[MAXN][MAXN][MAXN];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;int calc(int L, int R, int M, int X) &#123; int res = X * X; for (int i = 1; i &lt;= m; ++i) if (L &lt;= l[i] &amp;&amp; l[i] &lt;= M &amp;&amp; M &lt;= r[i] &amp;&amp; r[i] &lt;= R &amp;&amp; X &gt; x[i]) res -= c[i]; return res;&#125;int main() &#123; n = read(); h = read(); m = read(); for (int i = 1; i &lt;= m; ++i) &#123; l[i] = read(); r[i] = read(); x[i] = read(); c[i] = read(); &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; i + j - 1 &lt;= n; ++j) for (int x = 1; x &lt;= h; ++x) &#123; int l = j, r = i + j - 1; f[l][r][x] = f[l][r][x - 1]; for (int k = l; k &lt;= r; ++k) f[l][r][x] = max(f[l][r][x], f[l][k - 1][x] + f[k + 1][r][x] + calc(l, r, k, x)); &#125; printf("%d\n", f[1][n][h]);&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>普通</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>DP</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1146H - Satanic Panic]]></title>
    <url>%2F2019%2F08%2FCodeforces-1146H-Satanic-Panic%2F</url>
    <content type="text"><![CDATA[原先那个 $O(n^3 \log n)$ 的算法被证伪了……好伤心…… 计数问题不是直接算，就是 $\mbox{DP}$ 一下再算。 五角星显然是要求有五个点的凸包的方案数，一个凸包可以等价转换为五条极角序上升的线段。 那么设 $f_{i, j, k}$ 为初始为点 $i$ ，当前为点 $j$ ，是第 $k$ 条边的方案数，随便转移一下就行。 注意转移的时候用到了一个技巧：将边按照极角序加入，这样可以保证接入的边满足极角序递增/递减一类的要求。如果直接做的话，会写到 $O(n^4)$ 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;#define MAXN 305typedef long long lint;using namespace std;int n, m;lint f[MAXN][MAXN][5];struct point &#123; int x, y; point(int x = 0, int y = 0):x(x), y(y) &#123;&#125;&#125;a[MAXN];struct edge &#123; int u, v; double w; edge(int u = 0, int v = 0, double w = 0):u(u), v(v), w(w) &#123;&#125; bool operator &lt; (const edge b) const &#123; return w &lt; b.w; &#125;&#125;s[MAXN * MAXN];int read() &#123; char c = getchar(); int x = 0, s = 1; while (!isdigit(c)) &#123; if (c == '-') s = -1; c = getchar(); &#125; while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x * s;&#125;int main() &#123; n = read(); for (int i = 1; i &lt;= n; ++i) &#123; a[i].x = read(); a[i].y = read(); &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) if (i != j) s[++m] = edge(i, j, atan2(a[i].y - a[j].y, a[i].x - a[j].x)); sort(s + 1, s + m + 1); for (int i = 1; i &lt;= m; ++i) &#123; int u = s[i].u, v = s[i].v; f[u][v][0] = 1; for (int k = 1; k &lt;= 4; ++k) for (int j = 1; j &lt;= n; ++j) f[j][v][k] += f[j][u][k - 1]; &#125; lint ans = 0; for (int i = 1; i &lt;= n; ++i) ans += f[i][i][4]; printf("%lld\n", ans);&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>计数DP</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>solution</tag>
        <tag>凸包</tag>
        <tag>极角序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1148F - Foo Fighters]]></title>
    <url>%2F2019%2F08%2FCodeforces-1148F-Foo-Fighters%2F</url>
    <content type="text"><![CDATA[构造题果然都好难……不得不说真的很靠思维，但好像总是有一种套路，即确定一种取法，但是取法怎么取以及怎么保证正确性，当然这就靠思维了。 首先反转符号可以转化为将正号转化成负号。 首先基于无后效性的考虑，可以从高到低枚举每一位，统计所有的以当前位 $k$ 为最低位的 $mask_i$ ，若他们的和大于 $0$ ，则当前位可以保证贡献，答案该位置 $1$ ，将该位有 $1$ 的数反转。 倘若前面都是取最优解的话，那么当前位 $k$ 如此取也是最优解。但是，是否以后存在一种取法，使得 $k$ 位不取更优？ 显然不存在这种情况。因为每一步操作都保证了以当前位为最低位的那些数，负数之和一定比正数之和大，若每一位都保证，那么最后转化完的总和一定是负数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;#define MAXN 300005#define MAXB 75typedef long long lint;using namespace std;const int B = 61;int n;lint mask[MAXN], val[MAXN], cur;lint read() &#123; char c = getchar(); lint x = 0, s = 1; while (!isdigit(c)) &#123; if (c == '-') s = -1; c = getchar(); &#125; while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x * s;&#125;int main() &#123; n = (int)read(); for (int i = 1; i &lt;= n; ++i) &#123; val[i] = read(); mask[i] = read(); cur += val[i]; &#125; if (cur &lt; 0) for (int i = 1; i &lt;= n; ++i) val[i] = -val[i]; lint ans = 0; for (int i = B; i &gt;= 0; --i) &#123; lint sum = 0; for (int j = 1; j &lt;= n; ++j) if (mask[j] == (1ll &lt;&lt; i)) sum += val[j]; if (sum &gt; 0) &#123; ans |= (1ll &lt;&lt; i); for (int j = 1; j &lt;= n; ++j) if (mask[j] &gt;&gt; i &amp; 1) val[j] = -val[j]; &#125; for (int j = 1; j &lt;= n; ++j) if (mask[j] &gt;&gt; i &amp; 1) mask[j] ^= (1ll &lt;&lt; i); &#125; printf("%I64d\n", ans);&#125;]]></content>
      <categories>
        <category>思维</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>贪心</tag>
        <tag>bitmask</tag>
        <tag>constructive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1147D - Palindrome XOR]]></title>
    <url>%2F2019%2F08%2FCodeforces-1147D-Palindrome-XOR%2F</url>
    <content type="text"><![CDATA[这题算是想出来了，但是思路非常含糊，而且方法不够优秀，所以还是记录一下。 首先对于原先的 $a, b$ ，应该有：$|a| = n, |b| &lt; |a|$ 。 首先如果没有“ $?$ ”，对于 $b$ 的每一种长度，最多只有一种合法序列，证明分 $|b|$ 大于一半和小于一半。 对于大于一半的情况，显然是有一段小于一半的区间被确定，然后通过 $a$ 映射回另一边，再通过 $b$ 映射回另一边，以此循环即可证明。 对于小于一半的，已经有一段大于一半的区间被确定，一定最多只有一种。 对于这种确定关系，我们可以用一条边 $0/1$ 来表示，$0$ 表示两端相同， $1$ 表示两端不同。同时设立一个 $0$ 点，表示颜色为恒为 $0$ ，那么有： $a_i$ 和 $a_{n - i + 1}$ 连 $0$ 边； $b$ 同理； 对于 $b$ 的前导零我们不要忽视他，和 $0$ 点连 $0$ 边； 若异或为 $1$ ，则 $a_i$ 与 $b_i$ 连异或值的边，当然如果是’ $?$ ‘ 就不用连。 跑染色，从 $0$ 点开始跑，跑有多少个不同的连通块，设其个数为 $s$ ，则答案有：$2^{s - 1}$ ，不合法直接返回 $0$ 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;#define MAXN 1005#define MAXM 1000005typedef long long lint;using namespace std;const int mod = 998244353;int n;int a[MAXN];char s[MAXN];int head[MAXN &lt;&lt; 1], cnt;int color[MAXN &lt;&lt; 1], visit[MAXN &lt;&lt; 1];struct data &#123; int next, to, type; data(int next = 0, int to = 0, int type = 0):next(next), to(to), type(type) &#123;&#125;&#125;edge[MAXM];void connect(int u, int v, int t) &#123; edge[++cnt] = data(head[u], v, t); head[u] = cnt;&#125;bool DFS(int u) &#123; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to, t = edge[i].type; if (visit[v]) &#123; if (color[v] != (color[u] ^ t)) return false; continue; &#125; visit[v] = true; color[v] = color[u] ^ t; if (!DFS(v)) return false; &#125; return true;&#125;lint solve(int m) &#123; memset(head, 0, sizeof(head)); memset(visit, 0, sizeof(visit)); memset(color, 0, sizeof(color)); cnt = 0; for (int i = 1; i &lt;= n; ++i) connect(i, n - i + 1, 0); for (int i = 1; i &lt;= m; ++i) connect(i + n, m - i + 1 + n, 0); for (int i = 1; i &lt;= n; ++i) &#123; if (a[i] == 2) continue; connect(i, i + n, a[i]); connect(i + n, i, a[i]); &#125; for (int i = m + 1; i &lt;= n; ++i) connect((n &lt;&lt; 1) + 1, i + n, 0); connect((n &lt;&lt; 1) + 1, m + n, 1); connect(m + n, (n &lt;&lt; 1) + 1, 1); connect((n &lt;&lt; 1) + 1, n, 1); connect(n, (n &lt;&lt; 1) + 1, 1); bool flag = false; lint res = 1; for (int i = (n &lt;&lt; 1) + 1; i &gt;= 1; --i) if (!visit[i]) &#123; visit[i] = true; if (!DFS(i)) return 0; if (flag) res = res * 2 % mod; flag = true; &#125; return res;&#125;int main() &#123; scanf("%s", s + 1); n = (int)strlen(s + 1); for (int i = 1; i &lt;= n; ++i) a[n - i + 1] = s[i] == '?' ? 2 : s[i] - '0'; lint ans = 0; for (int i = 1; i &lt;= n; ++i) ans = (ans + solve(i)) % mod; printf("%lld\n", ans);&#125;]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1179D - Fedor Runs for President]]></title>
    <url>%2F2019%2F08%2FCodeforces-1179D-Fedor-Runs-for-President%2F</url>
    <content type="text"><![CDATA[hmm…… $\mbox{tutorial}$ 给的是 $O(n \log n)$ 做法的，真心不懂？明明是道 $O(n)$ 的水 $\mbox{DP}$ 。 显然最后是一棵基环树，要设基环树环上每个点子树大小为 $s_i$ ，那么答案为： \frac{\sum \limits_{i}s_i(s_i - 1) + 2s_i(n - s_i)}{2}然后要最大化这个答案，显然每一个点都可以作为基环树环上最上面那个点统计答案。 由于你可以把一棵基环树剖开来，分开计算后再合起来。每个点只需要他自己这棵子树基环树形态最好的上传即可，大概有这几种状态：环底、环中、环顶，转移很简单稍微想想就会。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;#define MAXN 500005typedef long long lint;using namespace std;int n;int head[MAXN], cnt;int size[MAXN];lint f[MAXN], ans;struct data &#123; int next, to; data(int next = 0, int to = 0):next(next), to(to) &#123;&#125;&#125;edge[MAXN &lt;&lt; 1];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void connect(int u, int v) &#123; edge[++cnt] = data(head[u], v); head[u] = cnt;&#125;void DFS(int u, int pre) &#123; size[u] = 1; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to; if (v == pre) continue; DFS(v, u); size[u] += size[v]; &#125; f[u] = 1ll * size[u] * (size[u] - 1) + 2ll * size[u] * (n - size[u]); int maxi = 0; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to; if (v == pre) continue; int r = size[u] - size[v], R = n - size[v]; ans = max(ans, f[v] + 1ll * R * (R - 1) + 2ll * R * (n - R)); R -= size[maxi]; ans = max(ans, f[maxi] + f[v] + 1ll * R * (R - 1) + 2ll * R * (n - R)); if (f[v] &gt; f[maxi]) maxi = v; f[u] = max(f[u], f[v] + 1ll * r * (r - 1) + 2ll * r * (n - r)); &#125;&#125;int main() &#123; n = read(); for (int i = 1; i &lt; n; ++i) &#123; int u = read(), v = read(); connect(u, v); connect(v, u); &#125; DFS(1, 0); printf("%I64d\n", ans / 2);&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>树形DP</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1188D - Make Equal]]></title>
    <url>%2F2019%2F08%2FCodeforces-1188D-Make-Equal%2F</url>
    <content type="text"><![CDATA[首先设目标数为 $x$ ，切序列有序，显然有：$x &gt; a_n$ 。 一个很直观的想法：枚举 $x$ 的每一个二进制位，发现有进位，不会写了…… 通过 $\mbox{tutorial}$ 发现了一个神奇的性质：若对于第 $k$ 位按照 $\mbox{mod }2^k$ 后的结果进行排序，那么发现进位的一定是一段后缀——很显然。 现在有动规方程：$f_{i, j}$ 表示第 $i$ 位，后 $j$ 位进位的最小值。 同时，直接枚举 $x$ 的二进制位是错的，错在最终态不可表，这样的状态定义是无法确定最终态的，答案会出现偏差。 所以考虑一个事实：进位的部分一定是末尾连续的一段。 于是我们可以将 $j$ 设计成一个状态，类似于状态压缩 $\mbox{DP}$ 以进行转移。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;#define MAXB 64#define MAXN 100005#define INF 0x3f3f3f3ftypedef long long lint;using namespace std;int n, K;const int B = 60;lint a[MAXN], maxi;int f[MAXB][MAXN], sum1[MAXN], sum0[MAXN];lint read() &#123; char c = getchar(); lint x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;bool comp(lint a, lint b) &#123; return a % (1ll &lt;&lt; K) &lt; b % (1ll &lt;&lt; K);&#125;void csort(int k) &#123; K = k + 1; sort(a + 1, a + n + 1, comp);&#125;void init(int k) &#123; for (int i = 1; i &lt;= n; ++i) &#123; sum0[i] = sum0[i - 1] + !(a[i] &gt;&gt; k &amp; 1); sum1[i] = sum1[i - 1] + (a[i] &gt;&gt; k &amp; 1); &#125;&#125;int main() &#123; n = (int)read(); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = read(); maxi = max(maxi, a[i]); &#125; for (int i = 1; i &lt;= n; ++i) a[i] = maxi - a[i]; memset(f, 0x3f, sizeof(f)); f[0][0] = 0; for (int i = 0; i &lt; B; ++i) &#123; if (i != 0) csort(i - 1); init(i); for (int j = 0; j &lt;= n; ++j) &#123; int l = sum1[n] - sum1[n - j], v = sum1[n - j] + sum0[n] - sum0[n - j]; f[i + 1][l] = min(f[i + 1][l], f[i][j] + v); l = n - sum0[n - j]; v = sum0[n - j] + sum1[n] - sum1[n - j]; f[i + 1][l] = min(f[i + 1][l], f[i][j] + v); &#125; &#125; printf("%d\n", f[B][0]);&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>状压DP</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>状压DP</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1198F - GCD Groups 2]]></title>
    <url>%2F2019%2F08%2FCodeforces-1198F-GCD-Groups-2%2F</url>
    <content type="text"><![CDATA[丢人了，随机跑的和状压一样快。这说明我随机写的很好？ 乍一看没有思路，看了下 $\mbox{tutorial}$ 发现最多能够被分解成 $9$ 个质数，那么现在就有一个随机算法了： 随机选两个数分属两个集合，分别分解他们的质因数，现在需要消去这些质因数：将剩下的数随机加，使得达到删除某些质因数的效果，最后检查是否为 $1$ ，即删掉所有的质因数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt; #define MAXN 100005 using namespace std; int n;pair&lt;int, int&gt; s[MAXN];int belong[MAXN];clock_t base = clock(); struct division &#123; int p[MAXN], v[MAXN], total, temp; division() &#123; memset(p, 0, sizeof(p)); memset(v, 0, sizeof(v)); total = temp = 0; &#125; void init() &#123; for (int i = 1; i &lt;= total; ++i) v[i] = p[i] = 0; temp = total = 0; &#125; void decompose(int x) &#123; init(); int limit = sqrt(x); for (int i = 2; i &lt;= limit; ++i) if (x % i == 0) &#123; p[++total] = i; while (x % i == 0) x /= i; &#125; if (x != 1) p[++total] = x; &#125;&#125;A, B; int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125; int crand(int mod) &#123; return 1ll * rand() * rand() % mod + 1;&#125; bool kill(division&amp; t, int x) &#123; bool islegal = false; for (int i = 1; i &lt;= t.total; ++i) if (!t.v[i] &amp;&amp; x % t.p[i] != 0) &#123; t.v[i] = true; islegal = true; ++t.temp; &#125; return islegal;&#125; int main() &#123; srand((int)time(0)); n = read(); for (int i = 1; i &lt;= n; ++i) &#123; s[i].first = read(); s[i].second = i; &#125; while ((clock() - base) * 2.520 &lt;= CLOCKS_PER_SEC) &#123; random_shuffle(s + 1, s + n + 1); int a = crand(n), b = crand(n); A.decompose(s[a].first); B.decompose(s[b].first); belong[s[a].second] = 1; belong[s[b].second] = 2; if (a == b) continue; for (int i = 1; i &lt;= n; ++i) &#123; if (i == a || i == b) continue; if (kill(A, s[i].first)) belong[s[i].second] = 1; else &#123; kill(B, s[i].first); belong[s[i].second] = 2; &#125; &#125; if (A.temp == A.total &amp;&amp; B.temp == B.total) &#123; puts("YES"); for (int i = 1; i &lt;= n; ++i) printf("%d ", belong[i]); return 0; &#125; &#125; puts("NO");&#125; 状压就是先选出两个数使得他们分属两个集合，分解质因数，可以计算出一个数加到某一个集合后会使哪些质因数消失，状压表示集合， $\mbox{DP}$ 求可行解 ，这样是 $O(n2^{2k})$ 的。 对于一个质因数，我们只需要任选 $2k$ 个没有这个质因数的其他数字，这样保证一定有情况能使该质因数被消去，关于任选的正确性：因为选了 $2k$ 个，合法情况下一定有至少一个会剩下，所以该质因数一定可以被消掉。 我讨厌这个算法，又难写空间开销还大还一样快！！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;bits/stdc++.h&gt; #define MAXN 100005#define MAXB 18 using namespace std; int n, m;int s[MAXN], t[MAXN];int belong[MAXN], used[MAXN];clock_t base = clock();int pa[MAXN], pb[MAXN], A, B;bool ischosen[MAXN];int f[2][1 &lt;&lt; MAXB], from[1 &lt;&lt; MAXB], decision[1 &lt;&lt; MAXB], part[1 &lt;&lt; MAXB], amount[3]; int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125; int crand(int mod) &#123; return 1ll * rand() * rand() % mod + 1;&#125; void divide(int* p, int&amp; total, int x) &#123; int limit = sqrt(x); total = 0; for (int i = 2; i &lt;= limit; ++i) if (x % i == 0) &#123; p[++total] = i; while (x % i == 0) x /= i; &#125; if (x != 1) p[++total] = x;&#125; void enlist(int* p, int total) &#123; for (int i = 1; i &lt;= total; ++i) for (int j = 1, k = 0; j &lt;= n &amp;&amp; k &lt;= A + B; ++j) if (s[j] % p[i]) &#123; ischosen[j] = true; ++k; &#125;&#125; int keep(int* p, int total, int x) &#123; int s = 0; for (int i = 1; i &lt;= total; ++i) if (x % p[i]) s |= 1 &lt;&lt; (i - 1); return s;&#125; int main() &#123; srand((int)time(0)); n = read(); for (int i = 1; i &lt;= n; ++i) s[i] = read(); while ((clock() - base) * 2.520 &lt;= CLOCKS_PER_SEC) &#123; memset(ischosen, 0, sizeof(ischosen)); memset(f, 0, sizeof(f)); memset(amount, 0, sizeof(amount)); int a = crand(n), b = crand(n); if (a == b) continue; divide(pa, A, s[a]); divide(pb, B, s[b]); belong[a] = 1; belong[b] = 2; enlist(pa, A); enlist(pb, B); m = 0; for (int i = 1; i &lt;= n; ++i) if (ischosen[i]) &#123; t[++m] = s[i]; used[m] = i; &#125; int limit = (1 &lt;&lt; (A + B)) - 1; f[0][0] = 1; for (int i = 1; i &lt;= m; ++i) &#123; int cur = i &amp; 1; memcpy(f[cur], f[cur ^ 1], sizeof(f[cur])); if (used[i] == a || used[i] == b) continue; int s1 = keep(pa, A, t[i]), s2 = keep(pb, B, t[i]) &lt;&lt; A; for (int s = limit - 1; s &gt;= 0; --s) &#123; if (f[cur ^ 1][s]) &#123; if ((s &amp; s1) != s1 &amp;&amp; !f[cur][s | s1]) &#123; f[cur][s | s1] = 1; decision[s | s1] = used[i]; from[s | s1] = s; part[s | s1] = 1; &#125; if ((s &amp; s2) != s2 &amp;&amp; !f[cur][s | s2]) &#123; f[cur][s | s2] = 1; decision[s | s2] = used[i]; from[s | s2] = s; part[s | s2] = 2; &#125; &#125; &#125; &#125; if (f[m &amp; 1][limit]) &#123; int s = limit; while (s) &#123; belong[decision[s]] = part[s]; ++amount[part[s]]; s = from[s]; &#125; puts("YES"); for (int i = 1; i &lt;= n; ++i) printf("%d ", belong[i] ? belong[i] : 1); return 0; &#125; &#125; puts("NO");&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>状压DP</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>状压DP</tag>
        <tag>随机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 3266 - [JLOI2015]骗我呢]]></title>
    <url>%2F2019%2F08%2FLuogu-3266-JLOI2015-%E9%AA%97%E6%88%91%E5%91%A2%2F</url>
    <content type="text"><![CDATA[显然每一行最多有一个地方“下降”，并且“下降”对于下一行的影响也是可知的，故直接枚举。 设 $f_{i, j}$ 为第 $i$ 行，第 $j$ 个地方下降，有： f_{i, j} = \sum \limits_{k = 0}^{j + 1} f_{i - 1, k}也就是： f_{i, j} = f_{i - 1, j + 1} + f_{i, j - 1}用矩阵表示： e \ \ e \ \ e \ \ e \\ e \ \ e \ \ e \ \ e \\ e \ \ e \ \ e \ \ e \\为了更好的表达转移： e \ \ e \ \ e \ \ e \\ \ \ \ \ \ \ \ \ e \ \ e \ \ e \ \ e \\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ e \ \ e \ \ e \ \ e \\相当于在这样一个平行四边形中只能向下走或者向右走，要求最后一行的和。 由于需要求最后一行的和，可以通过增加行数来达到目的，顺带稍稍翻转一下： \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ e \ \ e \ \ e \ \ e \\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ e \ \ e \ \ e \ \ e \\ \ \ \ \ \ \ \ \ e \ \ e \ \ e \ \ e \\ e \ \ e \ \ e \ \ e \\设左下角为 $(0, 0)$ ，则右上角为 $(n, n + m + 1)$ ，则为了满足转移规则不能经过 $y_1 = x + 1$ 和 $y_2 = x - m - 2$ 这两条直线。 $(0, 0)$ 到 $(x, y)$ 的方案数显然是：$\pmatrix{x + y \\ x}$ ，记经过直线 $y_1$ 为 $1$ ，$y_2$ 同理，则必然有：$111112221112222\dots$ ，防止算重把相同的合并，为 $1212\dots$ 。 非法表示要么 $1$ 开头要么 $2$ 开头，将终点沿 $y_1$ 对称，得到的就是以 $1$ 或 $12$ 结尾的方案数；再沿 $2$ 对称，得到的是以 $21$ 或 $212$ 结尾的方案数。 故我们减去以 $1$ 或 $12$ 结尾的方案数，加上 $21$ 或 $212$ 结尾的方案数，减去…… 当 $x &lt; 0$ 或 $y &lt; 0$ ，即已经没有意义，停止即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;#define MAXN 4000006typedef long long lint;using namespace std;const int mod = 1e9 + 7;int n, m;const int N = 4000000;lint fac[MAXN], inf[MAXN];lint power(lint a, int b) &#123; lint res = 1; while (b) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;void init() &#123; inf[0] = fac[0] = 1; for (int i = 1; i &lt;= N; ++i) fac[i] = fac[i - 1] * i % mod; inf[N] = power(fac[N], mod - 2); for (int i = N - 1; i &gt;= 1; --i) inf[i] = inf[i + 1] * (i + 1) % mod;&#125;lint C(int n, int m) &#123; if (n &lt; 0 || m &lt; 0 || m &gt; n) return 0; return fac[n] * inf[n - m] % mod * inf[m] % mod;&#125;void flip1(int&amp; x, int&amp; y) &#123; swap(x, y); --x; ++y;&#125;void flip2(int&amp; x, int&amp; y) &#123; swap(x, y); x += m + 2; y -= m + 2;&#125;void solve() &#123; int x = n + m + 1, y = n; lint ans = C(x + y, x); while (x &gt;= 0 &amp;&amp; y &gt;= 0) &#123; flip1(x, y); ans = (ans - C(x + y, x)) % mod; flip2(x, y); ans = (ans + C(x + y, x)) % mod; &#125; x = n + m + 1; y = n; while (x &gt;= 0 &amp;&amp; y &gt;= 0) &#123; flip2(x, y); ans = (ans - C(x + y, x)) % mod; flip1(x, y); ans = (ans + C(x + y, x)) % mod; &#125; printf("%lld\n", (ans + mod) % mod);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); init(); solve();&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>计数DP</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>DP</tag>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 5023 - 填数游戏]]></title>
    <url>%2F2019%2F08%2FLuogu-5023-%E5%A1%AB%E6%95%B0%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[这种找规律的题最不擅长了…… 首先需要证明两个结论： 对角线单调不增 这个结论应该是显然的，不妨假设对于两条路径，他们有着一段公共前缀，思考一下在分岔点需要注意什么就可以证明了，换而言之 $1$ 的存在必然是从左下开始的连续一段。 若 $(x - 1, y)$ 和 $(x, y - 1)$ 所填的数字相同，那么对于矩形 $(x, y)\rightarrow (n, m)$ ，有对于任意一条左上 $\rightarrow $ 到右下的对角线所填的数相等 这个比较不好想，主要是情况略微复杂。考虑一个四方格（是一个矩阵的一个子矩阵）： x \ \ 1 \\ 1 \ \ x \\$x$ 表示随便填了，当然这两个 $1$ 可以一起换成 $0$ ，假设有两条路径，在到达这个子矩阵左上角的点时才进行分叉，分别是往右和往下，最后在这个子矩阵的右下角的点 $(x, y)$ 在此交汇。 我们设路径 $1$ 先下降，即：$\mbox{DR}$，路径 $2$ 则是：$\mbox{RD}$ 。路径 $2$ 的字典序更大，故 $s_2 &lt;= s_1$ 。易知倘若矩阵 $(x, y) \rightarrow (n, m)$ 存在任意一条对角线不是相同的，那么一定可以使 $s_2 &gt; s_1$ 。 这两个结论证明完就可以进行 $\mbox{DP}$ 了，设 $f_{i, j, s}$ 表示从右下往左上数的第 $i$ 条对角线，有 $j$ 个 $1$ ，$s$ 是满足该点到 $(n, m)$ 的矩阵满足其任意对角线都相同的标号，标号按顺序标。 对于转移，枚举下一条对角线 $1$ 的个数，有且仅有一种合法的集合，计算出并进行转移。 打表可知，对于 $m &gt; n + 1$ 时，有 $f_{n, m} = 3 \times f_{n, m - 1}$ ，直接进行转移。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;#define MAXN 9typedef long long lint;using namespace std;const int mod = 1e9 + 7;int n, m, M;int f[2][MAXN][1 &lt;&lt; MAXN];int len[MAXN &lt;&lt; 1];int right(int i, int x) &#123; return i &lt;= m ? x : x + 1;&#125;int down(int i, int x) &#123; return i &lt;= m ? x - 1 : x;&#125;lint power(lint a, int b) &#123; lint res = 1; while (b) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); if (n == 1) &#123; printf("%lld\n", power(2, m)); return 0; &#125; if (m &gt; n + 1) &#123; M = m; m = n + 1; &#125; if (n &gt; m) swap(n, m); int limit = n + m - 1; for (int i = 1; i &lt;= n; ++i) len[i] = i; for (int i = n + 1; i &lt;= m; ++i) len[i] = n; for (int i = m + 1; i &lt;= limit; ++i) len[i] = limit - i + 1; f[1][0][1] = f[1][1][1] = 1; for (int i = 2; i &lt;= limit; ++i) &#123; int c = i &amp; 1; memset(f[c], 0, sizeof(f[c])); for (int j = 0; j &lt;= len[i - 1]; ++j) &#123; for (int s = 0; s &lt; (1 &lt;&lt; len[i - 1]); ++s) &#123; if (!f[c ^ 1][j][s]) continue; for (int k = 0; k &lt;= len[i]; ++k) &#123; bool islegal = true; for (int l = 1; l &lt; len[i]; ++l) if (l != k &amp;&amp; !(s &gt;&gt; (right(i, l) - 1) &amp; 1)) &#123; islegal = false; break; &#125; if (!islegal) continue; int t = 0; for (int l = 1; l &lt;= len[i]; ++l) &#123; int d = down(i, l), r = right(i, l); if (!d) t |= 1 &lt;&lt; (l - 1); else if (r &gt; len[i - 1]) t |= 1 &lt;&lt; (l - 1); else if (d != j &amp;&amp; (s &gt;&gt; (r - 1) &amp; 1) &amp;&amp; (s &gt;&gt; (d - 1) &amp; 1)) t |= 1 &lt;&lt; (l - 1); &#125; f[c][k][t] = (f[c][k][t] + f[c ^ 1][j][s]) % mod; &#125; &#125; &#125; &#125; int c = limit &amp; 1; lint ans = (f[c][1][0] + f[c][1][1] + f[c][0][0] + f[c][0][1]) % mod; if (M) ans = ans * power(3, M - m) % mod; printf("%lld\n", ans);&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>状压DP</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>状压DP</tag>
        <tag>数学规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 4769 - [NOI2018]冒泡排序]]></title>
    <url>%2F2019%2F08%2FLuogu-4769-NOI2018-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[神仙题%%% 首先需要将题目要求转化，其实提示很明显，即必须保证交换次数为：$\frac{1}{2} \sum \limits_{i = 1}^n |i - p_i|$ ，考虑一个数在其原位置右边，即 $p_i &gt; i$ ，那么必须进行且只进行 $p_i - i$ 次操作使其归位，那么必须保证比他大的数恰有 $p_i - i$ 个在他左边；若要最小化移动步数，需要右边没有比他小的数，若有之，则必然会向右交换一次，浪费次数。 结论由最小化移动步数的思想推之：不存在长度为 $3$ 的下降子序列。 随便口胡一下证明，其实很显然。考虑在满足最小化的前提下，是否恰有 $p_i - i$ 个数在其左边，现在数列有两个性质：一是经过一些次合法的交换一定有序，二是右边没有比他小的数。由于右边没有比他小的数，不可能向左交换，又因性质一，将会回到原位，故在满足右边没有比他小的数必然可以满足左边恰有 $p_i - i$ 个数比他小。 现在先不考虑字典序的限制，由于不存在长度为 $3$ 的下降子序列的限制，发现对于一个 $1 \sim i - 1$ 已经固定的序列，$i$ 放置的数，要么是剩下数的最小值，要么是剩下数比已有数列最大值更大的值；反之，一定会存在非法下降子序列，于是通过枚举该位放的是剩下第几大的数或是最小值，$f_{i, j}$ 表示剩下 $i$ 位，有 $j$ 个数比前面序列的最大值大，有方程： f_{i, j} = \sum \limits_{k = 0}^j f_{i - 1, k}即： f_{i, j} = f_{i - 1, j} + f_{i, j - 1}对于这个式子，发现其是有组合意义的：从 $(0, 0)$ 到 $(i, j)$ 且不经过直线 $y = x$ 的方案数，于是有： f_{i, j} = \pmatrix{i + j \\ j} - \pmatrix{i + j \\ j - 1}现在 $f_{i, j}$ 已经可以 $O(1)$ 求出了，考虑如何求出字典序： 可以用类似数位 $\mbox{DP}$ 的思想去考虑，对于一个已经确定前面 $i - 1$ 位的数列 $q$ ，第 $i$ 位的限制为 $a_i$ ，则必须保证 $q_i &gt; m$ ，其中 $m$ 为 $\max \limits_{j = 1}^{i}(q_j)$。设 $c$ 为 $q_{i + 1 \dots n}$ 中比 $m$ 大的数，那么答案为： \begin{align*} & \sum \limits_{j = 0}^{c - 1} f_{n - i, j} \\ = &f_{n - i + 1, c - 1} \end{align*}首先声明以下的 $m’ = \max \limits_{j = 1}^{i}(q_j)$，证明一下： $a_i &gt; m’$ 那么可选值域为：$[a_i + 1, n]$ ，枚举一下当前放的值就是上面的求和式； 此时 $m = a_i$ 。 $a_i &lt; m’$ 那么可选值域仍为：$[a_i + 1, n]$ ，但是对于 $[a_i + 1, m’ - 1]$ 的数，由于 $a_i$ 还未放置，一定构成下降子序列，非法，故仍是上面求和式；此时 $m = m’$ 。 所以枚举一下求和即可，注意序列不合法直接退出。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;#define MAXN 1200005#define lowbit(x) x &amp; -x#define INF 0x3f3f3f3ftypedef long long lint;using namespace std;const int mod = 998244353;int T, n, a[MAXN];lint ans = 0;lint fac[MAXN], inf[MAXN];int t[MAXN];void add(int x, int v) &#123; while (x &lt;= n) &#123; t[x] += v; x += lowbit(x); &#125;&#125;int query(int x) &#123; int res = 0; while (x) &#123; res = res + t[x]; x -= lowbit(x); &#125; return res;&#125;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;lint power(lint a, int b) &#123; lint res = 1; while (b) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;void init() &#123; memset(t, 0, sizeof(t)); inf[0] = fac[0] = 1; for (int i = 1; i &lt;= (n &lt;&lt; 1); ++i) fac[i] = fac[i - 1] * i % mod; inf[n &lt;&lt; 1] = power(fac[n &lt;&lt; 1], mod - 2); for (int i = (n &lt;&lt; 1) - 1; i &gt;= 1; --i) inf[i] = inf[i + 1] * (i + 1) % mod;&#125;lint C(int n, int m) &#123; return fac[n] * inf[m] % mod * inf[n - m] % mod;&#125;lint f(int i, int j) &#123; return C(i + j, j) - C(i + j, j - 1);&#125;int main() &#123; T = read(); while (T--) &#123; n = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); init(); for (int i = 1; i &lt;= n; ++i) add(i, 1); int maxi = 0; ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; add(a[i], -1); maxi = max(maxi, a[i]); ans = (ans + f(n - i + 1, n - i - query(maxi) - 1)) % mod; if (a[i] &lt; maxi &amp;&amp; query(a[i])) break; &#125; printf("%lld\n", (ans + mod) % mod); &#125;&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>计数DP</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>solution</tag>
        <tag>计数</tag>
        <tag>组合数学</tag>
        <tag>卡特兰数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 4562 - [JXOI2018]游戏]]></title>
    <url>%2F2019%2F08%2FLuogu-4562-JXOI2018-%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[显然有几个房间是必选的，设他们有 $s$ 个，把他们找出来。我写个埃氏筛以为会挂，结果飞快地过了。 结束时间就是走过所有必选房间的结束时间，然后直接枚举把某些不必选的房间参杂在必选的房间中，统计一下方案： \sum \limits_{i = 0}^{n - s}(s + i) \times \pmatrix{n - s \\ i} \times (s + i - 1)^{\underline{i}} \times s! \times (n - s - i)!1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;#define MAXN 10000007typedef long long lint;using namespace std;int l, r, n, sum, visit[MAXN];const int mod = 1e9 + 7;lint fac[MAXN], inf[MAXN];lint power(lint a, int b) &#123; lint res = 1; while (b) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;void init() &#123; inf[0] = fac[0] = 1; for (int i = 1; i &lt;= n; ++i) fac[i] = fac[i - 1] * i % mod; inf[n] = power(fac[n], mod - 2); for (int i = n - 1; i &gt;= 1; --i) inf[i] = inf[i + 1] * (i + 1) % mod; &#125;lint C(int n, int m) &#123; return fac[n] * inf[n - m] % mod * inf[m] % mod;&#125;int main() &#123; scanf("%d%d", &amp;l, &amp;r); n = r - l + 1; init(); for (int i = l; i &lt;= r; ++i) if (!visit[i]) &#123; ++sum; visit[i] = true; for (int j = i; j &lt;= r; j += i) visit[j] = true; &#125; lint ans = 0; for (int i = 0; i &lt;= n - sum; ++i) ans = (ans + 1ll * (sum + i) * C(n - sum, i) % mod * fac[sum + i - 1] % mod * inf[sum - 1] % mod * fac[sum] % mod * fac[n - sum - i] % mod) % mod; printf("%lld\n", ans);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 4492 - [HAOI2018]苹果树]]></title>
    <url>%2F2019%2F08%2FLuogu-4492-HAOI2018-%E8%8B%B9%E6%9E%9C%E6%A0%91%2F</url>
    <content type="text"><![CDATA[$\mbox{DP}$首先需要指出一个疏忽：一棵 $n$ 个结点的树的方案数显然是 $n!$ ，并不需要额外 $\mbox{DP}$ ，添加第一个点的时候只有一个分支，添加第二个点的时候就有两个分支了……以此类推即可。 那么考虑如何快速计算点对距离之和：比较理想的方法是求出深度之和，在予以合并。 那么可以将分别枚举两棵子树的大小进行合并， $\mbox{DP}$ 方程有： \begin{align*} g_i &= \sum \limits_{j = 0}^{i - 1} \pmatrix{i - 1 \\ j}(k! \times (g_j + j! \times j) + j! \times (g_k + k!\times k) + j! \times k!) \\ f_i &= \sum \limits_{j = 0}^{i - 1} \pmatrix{i - 1 \\ j}(k! \times (f_j + g_j \times (k + 1)) + j! \times (f_k + g_k \times (j + 1))) \\ \end{align*}以上： k = i - j - 1其中，$g_i$ 为根深度为 $1$ 的所有大小为 $i$ 的树的深度之和；$f_i$ 为所有大小为 $i$ 的树的每两点距离之和。 随便 $\mbox{DP}$ 即可。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#define MAXN 2005typedef long long lint;using namespace std;int n, mod;lint f[MAXN], g[MAXN], h[MAXN], C[MAXN][MAXN];void init() &#123; C[0][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; C[i][i] = C[i][0] = 1; for (int j = 1; j &lt; i; ++j) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;mod); init(); h[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; int k = i - j - 1; h[i] = (h[i] + C[i - 1][j] * h[j] % mod * h[k] % mod) % mod; g[i] = (g[i] + C[i - 1][j] * (h[k] * (g[j] + h[j] * j % mod) % mod + h[j] * (g[k] + h[k] * k % mod) % mod + h[j] * h[k] % mod) % mod) % mod; f[i] = (f[i] + C[i - 1][j] * (h[k] * (f[j] + g[j] * (k + 1) % mod) % mod + h[j] * (f[k] + g[k] * (j + 1) % mod) % mod)) % mod; &#125; &#125; printf("%lld\n", f[n]);&#125; 纯数学解法上面的方程是基于点集枚举而统计答案的，这里介绍一种通过枚举边的方法来计算答案。 首先，先确立一条边唯一对应一个点，即深度较深的那个点，设为 $u$ 。 现在，枚举到了一条边，其点为 $u$ ，再枚举 $u$ 的子树大小 $s$ ，方案数为：$2s(n - s)$ ，子树的形态数有：$s!$ 。 对于编号小于等于 $u$ 的点，显然是不在 $u$ 的子树里的，有形态数：$u!$ 。 对于不在 $u$ 的子树里的，且编号大于 $u$ 的点，放置方案数为：$u \times (u + 1) \times \cdots \times (n - s - 1)$ ，即：$(n - s - 1)^{\underline{n - s - u}}$ 。 那么答案为： \sum \limits_{i = 1}^n i! \times 2\sum \limits_{j = 1}^{n - i}j \times (n - j) \times \pmatrix{n - i \\ j}\times j! \times (n - j - 1)^{\underline{n - j - i}}]]></content>
      <categories>
        <category>DP</category>
        <category>计数DP</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>DP</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扩展卢卡斯定理]]></title>
    <url>%2F2019%2F08%2F%E6%89%A9%E5%B1%95%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[这是一个比较冷门的算法，但曾今在省选中出现过，还是记录一下，以便以后复习。 首先我们已经知道卢卡斯定理可以求： \pmatrix{n \\ m} \mod{p}其中 $p$ 是质数，我们有： \pmatrix{n \\ m} \mod p =]]></content>
      <categories>
        <category>数学</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>扩展欧几里得算法</tag>
        <tag>中国剩余定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 4204 - [NOI2006]神奇口袋]]></title>
    <url>%2F2019%2F08%2FLuogu-4204-NOI2006-%E7%A5%9E%E5%A5%87%E5%8F%A3%E8%A2%8B%2F</url>
    <content type="text"><![CDATA[之前一度强求期望求错了，算是题意的一种理解错误吧。 之前是希望求出每一步每一种球的数量的期望：这样是不对的。这种求法的本质是走到每一步的平均概率之积，但是这个根本没有意义。 题目要求的应该是算出所有符合题意要求的概率之和。 考虑一个事实：对于一个球 $i$ ，数量为 $a_i$ ，球的总数为 $\mbox{sum}$ ，计算下下次抽到 $i$ 球的概率： \begin{align*} & \frac{a_i}{\mbox{sum}} \times \frac{a_i + d}{\mbox{sum} + d} + \frac{\mbox{sum} - a_i}{\mbox{sum}} \times \frac{a_i}{\mbox{sum} + d} \\ = & \frac{a_i}{sum} \end{align*}发现抽到之概率不变，考虑一个递推的过程，$\mbox{sum}$ 是实际改变了，$a_i$ 在某些情况下也会实际改变，但是概率不变，换一种角度看本质上是没有加球的。我们用概率来推，发现指定抽到 $i$ 球有： \frac{a_i + d}{\mbox{sum} + d}显然后面也是一样的，制定第二次抽到 $i$ 球有： \frac{a_i' + d}{\mbox{sum}' + d}自然有第二次指定抽到 $i$ 球前抽到之的概率为： \frac{a_i'}{\mbox{sum}'} = \frac{a_i + d}{\mbox{sum} + d}$a_i$ 和 $\mbox{sum}$ 如此转移即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;#define MAXV 300005using namespace std;int v[MAXV], prime[MAXV], total;int t, n, d, a[MAXV], sum;const int V = 300000;struct number &#123; int a[MAXV &lt;&lt; 1], n; number(int n = 0):n(n) &#123; memset(a, 0, sizeof(a)); &#125; number operator * (const int b) const &#123; number c(n); for (int i = 1; i &lt;= n; ++i) &#123; c.a[i] += a[i] * b; if (c.a[i] &gt; 9) &#123; c.a[i + 1] += c.a[i] / 10; c.a[i] %= 10; &#125; &#125; while (c.a[c.n + 1]) &#123; ++c.n; if (c.a[c.n] &lt;= 9) break; c.a[c.n + 1] += c.a[c.n] / 10; c.a[c.n] %= 10; &#125; return c; &#125;&#125;up, down;struct division &#123; int c[MAXV]; void process(int x, int v) &#123; for (int i = 1; i &lt;= total &amp;&amp; x &gt;= 1; ++i) while (x % prime[i] == 0) &#123; c[i] += v; x /= prime[i]; &#125; &#125; void add(int x) &#123; process(x, 1); &#125; void sub(int x) &#123; process(x, -1); &#125;&#125;ans;void sieve() &#123; for (int i = 2; i &lt;= V; ++i) &#123; if (!v[i]) prime[++total] = i; for (int j = 1; j &lt;= total &amp;&amp; i * prime[j] &lt;= V; ++j) &#123; v[i * prime[j]] = 1; if (i % prime[j] == 0) break; &#125; &#125;&#125;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void deal(division res) &#123; up = down = number(1); up.a[1] = down.a[1] = 1; for (int i = 1; i &lt;= total; ++i) &#123; for (int j = 1; j &lt;= res.c[i]; ++j) up = up * prime[i]; for (int j = 1; j &lt;= -res.c[i]; ++j) down = down * prime[i]; &#125; for (int i = up.n; i &gt;= 1; --i) printf("%d", up.a[i]); printf("/"); for (int i = down.n; i &gt;= 1; --i) printf("%d", down.a[i]); puts("");&#125;int main() &#123; sieve(); t = read(); n = read(); d = read(); for (int i = 1; i &lt;= t; ++i) &#123; a[i] = read(); sum = sum + a[i]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; read(); int y = read(); ans.add(a[y]); ans.sub(sum); a[y] += d; sum += d; &#125; deal(ans);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>概率</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>概率</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 3193 - [HNOI2008]GT考试]]></title>
    <url>%2F2019%2F07%2FLuogu-3193-HNOI2008-GT%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[别吧，我的 $\mbox{KMP}$ 基础是真的差好吧。作为一个基础的字符串算法我是真的陌生到了一种极致。 $\mbox{KMP}$ 有一个 $\mbox{fail}$ 数组用来记录对于每一个前缀的最长公共前后缀，十分类似于 $\mbox{AC}$ 自动机，换而言之，失配的时候应该跳到 $\mbox{fail}$ 所指向的结点——因为他们前后缀相同，此时后缀此时有一段仍旧是匹配的。 对于这题，很容易写出一个 $\mbox{DP}$ 方程： f_{i, j} = \sum \limits_{j = 0}^{m - 1}f_{i - 1, k} \times g_{k, j}其中，$g_{k, j}$ 表示的是 $k$ 位再添加一位失配了然后仍有 $j$ 位匹配的方案数，加一下矩阵优化就行了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define MAXM 24using namespace std;int n, m, mod, a[MAXM], fail[MAXM], val[MAXM];struct matrix &#123; int a[MAXM][MAXM], n; matrix(int n = 0):n(n) &#123; memset(a, 0, sizeof(a)); &#125; matrix operator * (const matrix b) const &#123; matrix c(n); for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) for (int k = 0; k &lt; n; ++k) c.a[i][j] = (c.a[i][j] + a[i][k] * b.a[k][j] % mod) % mod; return c; &#125; void init() &#123; for (int i = 0; i &lt; n; ++i) a[i][i] = 1; &#125;&#125;base, trans;matrix power(matrix a, int b) &#123; matrix res(a.n); res.init(); while (b) &#123; if (b &amp; 1) res = res * a; a = a * a; b &gt;&gt;= 1; &#125; return res;&#125;void init() &#123; base = trans = matrix(m); base.a[0][0] = 1; for (int i = 2, j = 0; i &lt;= m; ++i) &#123; while (j &amp;&amp; a[i] != a[j + 1]) j = fail[j]; if (a[i] == a[j + 1]) ++j; fail[i] = j; &#125; for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt;= 9; ++j) &#123; int p = i; while (p &amp;&amp; j != a[p + 1]) p = fail[p]; if (j == a[p + 1]) ++p; ++trans.a[i][p]; &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;mod); for (int i = 1; i &lt;= m; ++i) scanf("%1d", &amp;a[i]); init(); base = base * power(trans, n); int ans = 0; for (int i = 0; i &lt; m; ++i) ans = (ans + base.a[0][i]) % mod; printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>KMP</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>矩阵快速幂</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu T90568 - music]]></title>
    <url>%2F2019%2F07%2FLuogu-T90568-music%2F</url>
    <content type="text"><![CDATA[区间大小是恒定的，所以一首歌的贡献区间是可知的，也就可以知道一个点可以听到哪些歌。 现在问题转化成了给定一个区间，求哪一个点评分小于 $x_i$ 的歌曲最少，且最少为多少。 倘若以区间序号作为下标，显然是无法维护的，这相当于在好几棵主席树上进行区间查询。 考虑转化成以 $x_i$ 为下标的主席树，每次分别对歌的贡献范围作区间加法，最后在某一个版本的主席树上作区间查询，避免了对多棵主席树同时查询的问题。 这里的主席树更应该叫做可持久化线段树。这里比较特殊的是主席树的区间加操作。众所周知主席树的结点是不同历史版本间共用的，所以需要借用标记永久化的思想，即可解决问题了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;iostream&gt;#define MAXN 200005#define INF 0x3f3f3f3fusing namespace std;int n, m, q, N, total;int a[MAXN], root[MAXN];pair&lt;int, int&gt; b[MAXN];map&lt;int, int&gt; times;struct segment &#123; int l, r, v, t; segment(int l = 0, int r = 0, int v = 0, int t = 0):l(l), r(r), v(v), t(t) &#123;&#125;&#125;t[MAXN &lt;&lt; 6];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void pushup(int x) &#123; t[x].v = min(t[t[x].l].v, t[t[x].r].v) + t[x].t;&#125;void modify(int l, int r, int p, int q, int v, int&amp; u) &#123; t[u = ++total] = t[v]; if (l &lt;= p &amp;&amp; q &lt;= r) &#123; ++t[u].t; ++t[u].v; return ; &#125; int mid = (p + q) &gt;&gt; 1; if (l &lt;= mid) modify(l, r, p, mid, t[v].l, t[u].l); if (r &gt; mid) modify(l, r, mid + 1, q, t[v].r, t[u].r); pushup(u);&#125;int query(int l, int r, int p, int q, int x) &#123; if (l &lt;= p &amp;&amp; q &lt;= r) return t[x].v; int mid = (p + q) &gt;&gt; 1, res = INF; if (l &lt;= mid) res = min(res, query(l, r, p, mid, t[x].l) + t[x].t); if (r &gt; mid) res = min(res, query(l, r, mid + 1, q, t[x].r) + t[x].t); return res;&#125;int main() &#123; n = read(); m = read(); for (int i = 1; i &lt;= n; ++i) &#123; b[i].first = a[i] = read(); b[i].second = i; &#125; sort(b + 1, b + n + 1); for (int i = 1; i &lt;= n; ++i) modify(max(1, b[i].second - m + 1), b[i].second, 1, n, root[i - 1], root[i]); q = read(); int ans = 0; while (q--) &#123; int l = read(), r = read(), x = read() ^ ans, p = lower_bound(b + 1, b + n + 1, make_pair(x, 0)) - b; while (b[p].first &gt;= x &amp;&amp; p) --p; if (p &gt; n) --p; printf("%d\n", ans = query(l, r, 1, n, root[p])); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>基础</category>
        <category>主席树</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>主席树</tag>
        <tag>标记永久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 1587 - [NOI2016]循环之美]]></title>
    <url>%2F2019%2F07%2FLuogu-1587-NOI2016-%E5%BE%AA%E7%8E%AF%E4%B9%8B%E7%BE%8E%2F</url>
    <content type="text"><![CDATA[当 $(k, y) = 1$ 时，满足题目要求，这时候就需要打表找规律了。 那么题目变成求： \sum \limits_{i = 1}^n \sum \limits_{j = 1}^m[(i, j)= 1][(j, k) = 1]反演一下： \begin{align*} &\sum \limits_{i = 1}^n \sum \limits_{j = 1}^m[(i, j)= 1][(j, k) = 1] \\ =&\sum \limits_{i = 1}^n \sum \limits_{j = 1}^m[(i, j)= 1]\sum \limits_{d |(j, k)}\mu(d) \\ =& \sum \limits_{d | k} \sum \limits_{i = 1}^n \sum \limits_{j = 1}^{\frac{m}{d}}[(i, jd) = 1] \\ =& \sum \limits_{d | k} \sum \limits_{i = 1}^n \sum \limits_{j = 1}^{\frac{m}{d}}[(i, j) = 1][(i, d) = 1] \end{align*}如果设： f(i, j, k) = \sum \limits_{i = 1}^n \sum \limits_{j = 1}^m[(i, j)= 1][(j, k) = 1]那么对于结尾的那个式子有： \sum \limits_{d | k}f(\frac{m}{d}, n, d)递归处理，当 $k = 1$ 时变成一个十分基础的莫比乌斯反演题，求和一下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;map&gt;typedef long long lint;#define MAXN 10000005using namespace std;struct node &#123; int n, m, k; node(int n = 0, int m = 0, int k = 0):n(n), m(m), k(k) &#123;&#125; bool operator &lt; (const node b) const &#123; return n &lt; b.n || (n == b.n &amp;&amp; m &lt; b.m) || (n == b.n &amp;&amp; m == b.m &amp;&amp; k &lt; b.k); &#125;&#125;;const int N = 10000000;int n, m, k;int prime[MAXN], v[MAXN], mu[MAXN], smu[MAXN], total;map&lt;node, lint&gt; record;map&lt;int, int&gt; M;void init() &#123; mu[1] = 1; for (int i = 2; i &lt;= N; ++i) &#123; if (!v[i]) &#123; prime[++total] = i; mu[i] = -1; &#125; for (int j = 1; j &lt;= total &amp;&amp; i * prime[j] &lt;= N; ++j) &#123; v[i * prime[j]] = true; if (i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; &#125; for (int i = 1; i &lt;= N; ++i) smu[i] = smu[i - 1] + mu[i];&#125;int Mu(int n) &#123; if (n &lt;= N) return smu[n]; if (M[n]) return M[n]; int res = 1; for (int i = 2, j; i &lt;= n; i = j + 1) &#123; j = n / (n / i); res = res - Mu(n / i) * (j - i + 1); &#125; return M[n] = res;&#125;lint solve(int n, int m, int k) &#123; if (!n) return 0; if (record[node(n, m, k)]) return record[node(n, m, k)]; lint res = 0; if (k == 1) &#123; int limit = min(n, m); for (int i = 1, j; i &lt;= limit; i = j + 1) &#123; j = min(n / (n / i), m / (m / i)); res = res + 1ll * (n / i) * (m / i) * (Mu(j) - Mu(i - 1)); &#125; &#125; else for (int i = 1; i * i &lt;= k; ++i) if (k % i == 0) &#123; res = res + mu[i] * solve(m / i, n, i); if (i * i != k) res = res + mu[k / i] * solve(m / (k / i), n, k / i); &#125; return record[node(n, m, k)] = res;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); init(); printf("%lld\n", solve(n, m, k));&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>反演</category>
        <category>莫比乌斯反演</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>莫比乌斯反演</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 533A - Berland Miners]]></title>
    <url>%2F2019%2F07%2FCodeforces-533A-Berland-Miners%2F</url>
    <content type="text"><![CDATA[其实就是一道细节题，由于只能更改一个山洞，考虑一个山洞更改会对所有他的子树中以他为最小值的山洞进行更改，变成他们的次低值，只要维护这些更改并查询是否满足题意即可。 题目要求： \forall i, h_i \geq s_i其中，$h_i, s_i$ 都是有序的。 转换一下思路，先把其离散化，在每一个 $s_i$ 的位置插入 $i - n - 1$ ，表明应有 $n - i + 1$ 个数较之大或相等。这样对于 $h_i$ 做一个区间加法，最后查询区间是否有小于 $0$。 对于更改有一个策略：将次低值从大到小排序，找到最高位的 $1$ ，判断此次更改是否能消去最高位的 $1$ ，若不能，则更改该点无解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 500005#define INF 0x3f3f3f3f#define ls x &lt;&lt; 1#define rs x &lt;&lt; 1 | 1using namespace std;int n, m, M;int l[MAXN], h[MAXN], fa[MAXN], mini[MAXN], semini[MAXN], b[MAXN], origin[MAXN], temp[MAXN];int head[MAXN], cnt;vector&lt;int&gt; g[MAXN];struct segment &#123; int l, r, v, t;&#125;t[MAXN &lt;&lt; 2];struct data &#123; int next, to; data(int next = 0, int to = 0):next(next), to(to) &#123;&#125;&#125;edge[MAXN &lt;&lt; 1];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;bool comp(int u, int v) &#123; return l[semini[u]] &gt; l[semini[v]];&#125;void pushup(int x) &#123; t[x].v = min(t[ls].v, t[rs].v);&#125;void build(int l = 1, int r = m, int x = 1) &#123; t[x].l = l; t[x].r = r; t[x].v = t[x].t = 0; if (l == r) return ; int mid = (l + r) &gt;&gt; 1; build(l, mid, ls); build(mid + 1, r, rs); pushup(x);&#125;void pushdown(int x) &#123; if (!t[x].t) return ; t[ls].v += t[x].t; t[rs].v += t[x].t; t[ls].t += t[x].t; t[rs].t += t[x].t; t[x].t = 0;&#125;void modify(int l, int r, int v, int x = 1) &#123; if (l &gt; r) return ; if (l &lt;= t[x].l &amp;&amp; t[x].r &lt;= r) &#123; t[x].t += v; t[x].v += v; return ; &#125; pushdown(x); int mid = (t[x].l + t[x].r) &gt;&gt; 1; if (l &lt;= mid) modify(l, r, v, ls); if (r &gt; mid) modify(l, r, v, rs); pushup(x);&#125;void connect(int u, int v) &#123; edge[++cnt] = data(head[u], v); head[u] = cnt;&#125;void DFS(int u, int pre, int s, int t) &#123; fa[u] = pre; if (l[s] &gt; l[u]) &#123; t = s; s = u; &#125; else if (l[t] &gt; l[u]) t = u; g[s].push_back(u); mini[u] = s; semini[u] = t; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to; if (v == pre) continue; DFS(v, u, s, t); &#125;&#125;int query(int x = 1) &#123; if (t[x].l == t[x].r) return t[x].l; pushdown(x); int res = 0; if (t[rs].v &lt; 0) res = query(rs); else res = query(ls); pushup(x); return res;&#125;int solve() &#123; if (t[1].v &gt;= 0) return 0; int ans = INF; for (int u = 1; u &lt;= n; ++u) &#123; sort(g[u].begin(), g[u].end(), comp); int i, maxi = 0; for (i = 0; i &lt; (int)g[u].size(); ++i) &#123; int c = query(); modify(1, l[u], -1); temp[i] = c; modify(1, c, 1); if (l[semini[g[u][i]]] &lt; c) break; maxi = max(maxi, b[c]); if (t[1].v &gt;= 0) &#123; ans = min(ans, maxi - origin[u]); break; &#125; &#125; i -= (i == (int)g[u].size()); for (; i &gt;= 0; --i) &#123; modify(1, l[u], 1); modify(1, temp[i], -1); &#125; &#125; return ans == INF ? -1 : ans;&#125;int main() &#123; n = read(); for (int i = 1; i &lt;= n; ++i) origin[i] = l[i] = read(); l[0] = INF; for (int i = 1; i &lt; n; ++i) &#123; int u = read(), v = read(); connect(u, v); connect(v, u); &#125; DFS(1, 0, 0, 0); m = read(); for (int i = 1; i &lt;= m; ++i) b[i] = h[i] = read(); sort(b + 1, b + m + 1); for (int i = 1; i &lt;= m; ++i) h[i] = i; build(); for (int i = 1; i &lt;= m; ++i) modify(h[i], h[i], -m + h[i] - 1); for (int i = 1; i &lt;= n; ++i) l[i] = upper_bound(b + 1, b + m + 1, l[i]) - b - 1; for (int i = 1; i &lt;= n; ++i) modify(1, l[mini[i]], 1); printf("%d\n", solve());&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>基础</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 5296 - [北京省选集训2019]生成树计数]]></title>
    <url>%2F2019%2F07%2FLuogu-5296-%E5%8C%97%E4%BA%AC%E7%9C%81%E9%80%89%E9%9B%86%E8%AE%AD2019-%E7%94%9F%E6%88%90%E6%A0%91%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[根据广义二项式定理，我们可以将 $(\sum \limits_{i \in E}v_i)^k$ 化成若干项，且每一项是 $v_i$ 的乘积，他们的系数之和等于 $k$ ，大概是这样的： \sum \limits_{E} \prod \limits_{i \in E}v_i^{a_i}[\sum \limits_{i \in E} a_i = 1]根据变元矩阵树定理可以知道，我们每次求的值等价于： \sum \limits_{E} \prod \limits_{i \in E} v_i所以矩阵树定理求出来的那个多项式，我们只要 $x^k$ 的那一项。 于是把每一条边权赋为： \sum \limits_{i = 0}^k \frac{1}{i!}v^kx^k注意是指数型生成函数，估一下多项式的次数应该是 $n \times k$ 的，所以拉格朗日插值搞出系数即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 1005#define MAXS 35typedef long long lint;using namespace std;int n, m, k;int a[MAXS][MAXS];lint f[MAXN], fac[MAXN], inf[MAXN], coe[MAXN], ans;const int mod = 998244353;struct matrix &#123; lint a[MAXS][MAXS]; int n; matrix(int n = 0):n(n) &#123; memset(a, 0, sizeof(a)); &#125;&#125;base;lint decrease(matrix&amp; m) &#123; lint ans = 1; for (int i = 1; i &lt; m.n; ++i) &#123; for (int j = i + 1; j &lt; m.n; ++j) &#123; while (m.a[j][i]) &#123; lint r = m.a[i][i] / m.a[j][i]; for (int k = i; k &lt; m.n; ++k) &#123; m.a[i][k] = (m.a[i][k] - m.a[j][k] * r % mod + mod) % mod; swap(m.a[i][k], m.a[j][k]); &#125; ans = mod - ans; &#125; &#125; ans = ans * m.a[i][i] % mod; &#125; return (ans + mod) % mod;&#125;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;lint power(lint a, int b) &#123; lint res = 1; while (b) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;void init() &#123; fac[0] = 1; for (int i = 1; i &lt;= m; ++i) fac[i] = fac[i - 1] * i % mod; for (int i = 0; i &lt;= m; ++i) inf[i] = power(fac[i], mod - 2);&#125;void insert(int x) &#123; for (int i = m; i &gt;= 0; --i) &#123; coe[i] = coe[i] * (mod - x) % mod; if (i) coe[i] = (coe[i] + coe[i - 1]) % mod; &#125;&#125;void remove(int x) &#123; for (int i = 0; i &lt;= m; ++i) &#123; if (i) coe[i] = (coe[i] - coe[i - 1] + mod) % mod; coe[i] = coe[i] * power(mod - x, mod - 2) % mod; &#125;&#125;int main() &#123; n = read(); k = read(); m = n * k + 1; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) a[i][j] = read(); init(); for (int p = 1; p &lt;= m; ++p) &#123; base = matrix(n); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt; i; ++j) &#123; lint v = 0, c = 1; for (int l = 0; l &lt;= k; ++l) &#123; v = (v + c * inf[l] % mod) % mod; c = 1ll * c * p % mod * a[i][j] % mod; &#125; base.a[i][i] = (base.a[i][i] + v) % mod; base.a[j][j] = (base.a[j][j] + v) % mod; base.a[i][j] = base.a[j][i] = (mod - v) % mod; &#125; f[p] = decrease(base); &#125; coe[0] = 1; for (int i = 1; i &lt;= m; ++i) insert(i); for (int i = 1; i &lt;= m; ++i) &#123; remove(i); lint cur = 1; for (int j = 1; j &lt;= m; ++j) if (i != j) cur = cur * (i - j) % mod; cur = (power(cur, mod - 2) + mod) % mod; ans = (ans + coe[k] * cur % mod * f[i] % mod) % mod; insert(i); &#125; printf("%lld\n", (ans * fac[k] % mod + mod) % mod);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>组合数学</category>
        <category>矩阵树定理</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>拉格朗日插值</tag>
        <tag>矩阵树定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder AGC012E - Camel and Oases]]></title>
    <url>%2F2019%2F07%2FAtCoder%20AGC012E%20-%20Camel%20and%20Oases%2F</url>
    <content type="text"><![CDATA[根据题意不难发现 $v$ 的不同取值仅有 $\log v$ 种，对于不同的 $v$ ，显然可以将区间划分为几个能够互相自达的部分。 那么转换一下题意，似乎就是一个区间覆盖的模型：从 $\log v$ 种区间中选取一些区间使得覆盖全部点，并且对于第一层区间有必选的要求。 对于除了第一层以外的区间就可以使用状压 $\mbox{DP}$ 解决问题，记两个值：$l_s, r_s$ ，分别表示从左能够覆盖区间的最长长度和从右覆盖区间的最长长度，对于第一层区间显然可以从这两个值进行判断；同时这也是用一维表示区间覆盖的唯一方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAXN 200005#define MAXB 21using namespace std;const int INF = 1e9 + 2e6;int v[MAXN], n, m;int d[MAXN], up[MAXN][MAXB], down[MAXN][MAXB], pre[1 &lt;&lt; MAXB], suf[1 &lt;&lt; MAXB];int visit[MAXN];int read() &#123; char c = getchar(); int x = 0, s = 1; while (!isdigit(c)) &#123; if (c == '-') s = -1; c = getchar(); &#125; while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x * s;&#125;void init() &#123; while (v[++m] &gt;= 1) v[m + 1] = v[m] &gt;&gt; 1; d[0] = -INF; d[n + 1] = INF; for (int j = 1; j &lt;= m; ++j) &#123; for (int i = 1; i &lt;= n; ++i) if (d[i] - d[i - 1] &lt;= v[j]) up[i][j] = up[i - 1][j]; else up[i][j] = i; for (int i = n; i &gt;= 1; --i) if (d[i + 1] - d[i] &lt;= v[j]) down[i][j] = down[i + 1][j]; else down[i][j] = i; &#125;&#125;void solve() &#123; memset(suf, 0x3f, sizeof(suf)); memset(pre, -0x3f, sizeof(pre)); suf[0] = n + 1; pre[0] = 0; int limit = (1 &lt;&lt; m) - 1; for (int s = 0; s &lt;= limit; ++s) &#123; for (int i = 1; i &lt;= m; ++i) &#123; if (s &gt;&gt; (i - 1) &amp; 1) continue; int t = s | (1 &lt;&lt; (i - 1)); if (pre[s] &gt;= 0) pre[t] = max(pre[t], down[pre[s] + 1][i]); if (suf[s] &lt;= n + 1) suf[t] = min(suf[t], up[suf[s] - 1][i]); &#125; &#125; for (int s = 0; s &lt;= limit; ++s) &#123; if (s &amp; 1) continue; int t = limit ^ s ^ 1; int a = up[suf[t] - 1][1], b = down[pre[s] + 1][1]; if (a &lt;= b) &#123; ++visit[a]; --visit[b + 1]; &#125; &#125; for (int i = 1; i &lt;= n; ++i) visit[i] = visit[i - 1] + visit[i]; for (int i = 1; i &lt;= n; ++i) if (visit[i]) puts("Possible"); else puts("Impossible");&#125;int main() &#123; n = read(); v[1] = read(); for (int i = 1; i &lt;= n; ++i) d[i] = read(); init(); solve();&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>状压DP</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 3295 - [SCOI2016]萌萌哒]]></title>
    <url>%2F2019%2F07%2FLuogu-3295-SCOI2016-%E8%90%8C%E8%90%8C%E5%93%92%2F</url>
    <content type="text"><![CDATA[考虑一开始每个数自成一个集合，每次给定两个区间实质是让两个区间位序相同的数归属同一集合。 同一集合中包含的不同位置的数字相同，那么答案为：$9 \times 10^{m - 1}$，其中 $m$ 为剩下的集合个数。 直接并查集时 $O(n^2)$ 的，考虑寻找一种算法使复杂度降低。 使用倍增，每次赋值打一个标记 $f_{x, l}$ 表示：从第 $x$ 位开始往后 $l$ 位，每一次并查集合并意味着第 $x$ 位往后 $l$ 位分别和父亲结点往 $l$ 位分别做一次并查集，这样询问时直接合并，最后下传一下合并标记，最后直接输出即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAXN 1000005#define MAXB 19typedef long long lint;using namespace std;const int mod = 1e9 + 7;const int B = 18;int n, m;int fa[MAXN][MAXB], sum;lint power(lint a, int b) &#123; lint res = 1; while (b) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;int find(int x, int b) &#123; return fa[x][b] != x ? fa[x][b] = find(fa[x][b], b) : x;&#125;void merge(int x, int y, int b) &#123; if (find(x, b) != find(y, b)) fa[find(x, b)][b] = find(y, b);&#125;void pushdown() &#123; for (int j = B; j &gt;= 1; --j) &#123; for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) &#123; merge(i, find(i, j), j - 1); merge(i + (1 &lt;&lt; (j - 1)), find(i, j) + (1 &lt;&lt; (j - 1)), j - 1); &#125; &#125;&#125;int main() &#123; n = read(); m = read(); for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt;= B; ++j) fa[i][j] = i; for (int i = 1; i &lt;= m; ++i) &#123; int l1 = read(), r1 = read(), l2 = read(), r2 = read(); for (int j = B; j &gt;= 0; --j) if (l1 + (1 &lt;&lt; j) - 1 &lt;= r1) &#123; merge(l1, l2, j); l1 = l1 + (1 &lt;&lt; j); l2 = l2 + (1 &lt;&lt; j); &#125; &#125; pushdown(); for (int i = 1; i &lt;= n; ++i) if (find(i, 0) != i) ++sum; printf("%lld\n", 9ll * power(10, n - sum - 1) % mod);&#125;]]></content>
      <categories>
        <category>思维</category>
        <category>倍增</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 5416 - [CTSC2016]时空旅行]]></title>
    <url>%2F2019%2F07%2FLuogu-5416-CTSC2016-%E6%97%B6%E7%A9%BA%E6%97%85%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[一道挺神的题目，首先对于题目要求的 $(x - x_i)^2 + c_i$，挺显然的应该用凸包维护，此处维护一个下凸包。 然后考虑直接遍历整棵树，发现由于凸包的维护是增量法实现的，所以无法实现删点操作，只能考虑线段树分治了。 套上线段树分治，直接在线段树的每一个结点维护凸包，从上往下遍历时求取最大值即可。 注意一些细节：凸包加点时以 $x$ 从小到大加入；每个星球的可行区间会有多个；$x$ 可能重复；卡空间。 实在毒瘤。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define MAXN 500005#define ls x &lt;&lt; 1#define rs x &lt;&lt; 1 | 1#define INF 0x3f3f3f3f3f3f3f3fusing namespace std;typedef long long lint;typedef pair&lt;int, int&gt; pa;int n, m, N, c, total, amount;int dfn[MAXN], size[MAXN], style[MAXN], number[MAXN];lint ans[MAXN];vector&lt;int&gt; g[MAXN], append[MAXN], destroy[MAXN];struct option &#123; int id, ori; lint x; bool operator &lt; (const option b) const &#123; return x &lt; b.x; &#125;&#125;b[MAXN];struct planet &#123; lint x, y; planet(lint x = 0, lint y = 0):x(x), y(y) &#123;&#125;&#125;a[MAXN];struct node &#123; int l, r, id; node(int l = 0, int r = 0, int id = 0):l(l), r(r), id(id) &#123;&#125; bool operator &lt; (const node b) const &#123; return a[id].x &lt; a[b.id].x; &#125;&#125;seg[MAXN];struct segment &#123; int last; vector&lt;int&gt; p; segment() &#123; last = 0; p.clear(); &#125;&#125;t[MAXN &lt;&lt; 2];lint read() &#123; char c = getchar(); lint x = 0, s = 1; while (!isdigit(c)) &#123; if (c == '-') s = -1; c = getchar(); &#125; while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x * s;&#125;double slope(int u, int v) &#123; if (a[u].x == a[v].x) return a[u].y &gt; a[v].y ? -INF : INF; return double(a[u].y - a[v].y) / double(a[u].x - a[v].x);&#125;void insert(int l, int r, int id, int x = 1, int p = 1, int q = n) &#123; if (l &lt;= p &amp;&amp; q &lt;= r) &#123; vector&lt;int&gt;&amp; cur = t[x].p; while (cur.size() &gt;= 2 &amp;&amp; slope(cur[cur.size() - 1], id) &lt; slope(cur[cur.size() - 2], cur[cur.size() - 1])) cur.pop_back(); cur.push_back(id); return ; &#125; int mid = (p + q) &gt;&gt; 1; if (l &lt;= mid) insert(l, r, id, ls, p, mid); if (r &gt; mid) insert(l, r, id, rs, mid + 1, q);&#125;void DFS(int u) &#123; dfn[u] = ++total; size[u] = 1; if (style[u]) destroy[number[u]].push_back(dfn[u] - 1); else append[number[u]].push_back(dfn[u]); for (int i = 0; i &lt; (int)g[u].size(); ++i) &#123; int v = g[u][i]; DFS(v); size[u] += size[v]; &#125; if (style[u]) append[number[u]].push_back(dfn[u] + size[u]); else destroy[number[u]].push_back(dfn[u] + size[u] - 1);&#125;lint query(int go, lint d, int x = 1, int p = 1, int q = n) &#123; int &amp;l = t[x].last, r = (int)t[x].p.size() - 1, mid = (p + q) &gt;&gt; 1; lint res = INF; vector&lt;int&gt;&amp; cur = t[x].p; while (l &lt; r &amp;&amp; slope(cur[l], cur[l + 1]) &lt; (double)d) ++l; if (l &lt;= r) res = a[cur[l]].y + d * d - a[cur[l]].x * d; if (p == q) return res; if (go &lt;= mid) res = min(res, query(go, d, ls, p, mid)); else res = min(res, query(go, d, rs, mid + 1, q)); return res;&#125;int main() &#123; n = (int)read(); m = (int)read(); a[1].y = read(); append[1].push_back(1); destroy[1].push_back(n); for (int i = 2; i &lt;= n; ++i) &#123; int type = (int)read(), fa = (int)read() + 1, id = (int)read() + 1; style[i] = type; number[i] = id; if (!type) &#123; lint x = read(), y; read(); read(); y = read(); a[id] = planet(x &lt;&lt; 1, x * x + y); &#125; g[fa].push_back(i); &#125; DFS(1); for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt; (int)append[i].size(); ++j) seg[++N] = node(append[i][j], destroy[i][j], i); sort(seg + 1, seg + N + 1); for (int i = 1; i &lt;= N; ++i) insert(seg[i].l, seg[i].r, seg[i].id); for (int i = 1; i &lt;= m; ++i) &#123; b[i].id = (int)read() + 1; b[i].x = read(); b[i].ori = i; &#125; sort(b + 1, b + m + 1); for (int i = 1; i &lt;= m; ++i) ans[b[i].ori] = query(dfn[b[i].id], b[i].x); for (int i = 1; i &lt;= m; ++i) printf("%lld\n", ans[i]);&#125;]]></content>
      <categories>
        <category>思维</category>
        <category>分治</category>
        <category>线段树分治</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>线段树分治</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 4041 - [AHOI2014/JSOI2014]奇怪的计算器]]></title>
    <url>%2F2019%2F07%2FLuogu-4041-AHOI2014-JSOI2014-%E5%A5%87%E6%80%AA%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[有一个很重要的性质必须要发现：不管如何操作其大小相对性是不变的。至于怎么发现呢，手模几遍就出来了，性质题出了多模拟几遍似乎没有什么太好的方法。 那么在排序以后，每次修改的区间一定是某一段首区间和某一段尾区间，在线段树上二分找到指定区间区间覆盖即可。 同时，有一个巧妙的函数可以处理标记的互相影响：$v_i = a \times v_i + b \times a_i + c$ ，自行领会一下，标记修改时注意下如何影响。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 100005#define ls x &lt;&lt; 1#define rs x &lt;&lt; 1 | 1 typedef long long lint;using namespace std;int q, n, l, r;int a[MAXN], ans[MAXN], temp[MAXN];char s[5];pair&lt;int, int&gt; b[MAXN];struct tag &#123; lint a, b, c; tag(lint a = 1, lint b = 0, lint c = 0):a(a), b(b), c(c) &#123;&#125; tag operator + (const tag t) const &#123; return tag(a * t.a, b * t.a + t.b, c * t.a + t.c); &#125;&#125;;struct segment &#123; int l, r; lint mini, maxi; tag t;&#125;t[MAXN &lt;&lt; 2];struct option &#123; char type; int val; option(char type = 0, int val = 0):type(type), val(val) &#123;&#125;&#125;o[MAXN];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void change(int x, tag v) &#123; t[x].t = t[x].t + v; t[x].mini = t[x].mini * v.a + a[t[x].l] * v.b + v.c; t[x].maxi = t[x].maxi * v.a + a[t[x].r] * v.b + v.c;&#125;void pushdown(int x) &#123; change(ls, t[x].t); change(rs, t[x].t); t[x].t = tag();&#125;void pushup(int x) &#123; t[x].mini = min(t[ls].mini, t[rs].mini); t[x].maxi = max(t[ls].maxi, t[rs].maxi);&#125;void build(int l = 1, int r = n, int x = 1) &#123; t[x].l = l; t[x].r = r; if (l == r) &#123; t[x].mini = t[x].maxi = a[l]; return ; &#125; int mid = (l + r) &gt;&gt; 1; build(l, mid, ls); build(mid + 1, r, rs); pushup(x);&#125;void modify(int l, int r, tag v, int x = 1) &#123; if (l &lt;= t[x].l &amp;&amp; t[x].r &lt;= r) &#123; change(x, v); return ; &#125; pushdown(x); int mid = (t[x].l + t[x].r) &gt;&gt; 1; if (l &lt;= mid) modify(l, r, v, ls); if (r &gt; mid) modify(l, r, v, rs); pushup(x);&#125;int queryL(int x = 1) &#123; if (t[x].l == t[x].r) return t[x].l; pushdown(x); if (t[rs].mini &lt; l) return queryL(rs); return queryL(ls);&#125;int queryR(int x = 1) &#123; if (t[x].l == t[x].r) return t[x].l; pushdown(x); if (t[ls].maxi &gt; r) return queryR(ls); return queryR(rs);&#125;void output(int x = 1) &#123; if (t[x].l == t[x].r) &#123; temp[t[x].l] = t[x].mini; return ; &#125; pushdown(x); output(ls); output(rs);&#125;int main() &#123; q = read(); l = read(); r = read(); for (int i = 1; i &lt;= q; ++i) &#123; scanf("%s", s + 1); int x = read(); o[i] = option(s[1], x); &#125; n = read(); for (int i = 1; i &lt;= n; ++i) &#123; b[i].first = a[i] = read(); b[i].second = i; &#125; sort(a + 1, a + n + 1); sort(b + 1, b + n + 1); build(); for (int i = 1; i &lt;= q; ++i) &#123; if (o[i].type == '+') change(1, tag(1, 0, o[i].val)); if (o[i].type == '-') change(1, tag(1, 0, -o[i].val)); if (o[i].type == '*') change(1, tag(o[i].val, 0, 0)); if (o[i].type == '@') change(1, tag(1, o[i].val, 0)); if (t[1].mini &lt; l) modify(1, queryL(), tag(0, 0, l)); if (t[1].maxi &gt; r) modify(queryR(), n, tag(0, 0, r)); &#125; output(); for (int i = 1; i &lt;= n; ++i) ans[b[i].second] = temp[i]; for (int i = 1; i &lt;= n; ++i) printf("%d\n", ans[i]);&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>基础</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 727F - Polycarp's problems]]></title>
    <url>%2F2019%2F07%2FCodeforces-727F-Polycarp-s-problems%2F</url>
    <content type="text"><![CDATA[一道很不错的逆向思维题。 其实我还有个线段树解法，即按题意暴力模拟，复杂度 $O(mn)$ 。 这类逆推还是比较巧妙的。首先是将题目所限制的心情作为 $\mbox{DP}$ 的对象，得到满足答案条件时，心情值至少为多少，最后利用二分回答答案。即转题目所求为限制，转限制为所求，规避了心情值会很大的情况。 其次，利用逆推，保证了 $\mbox{DP}$ 的无后效性，感觉一类代价限制性题目都需要用到逆推，这样才能保证当前代价，符合以后限制。 复杂度是 $O(n^2 + m\log n)$ 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAXN 1005typedef long long lint;using namespace std;lint f[MAXN][MAXN];int a[MAXN], n, m;lint read() &#123; char c = getchar(); lint x = 0, s = 1; while (!isdigit(c)) &#123; if (c == '-') s = -1; c = getchar(); &#125; while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x * s;&#125;void init() &#123; memset(f, 0x3f, sizeof(f)); f[n + 1][0] = 0; for (int i = n; i &gt;= 1; --i) f[i][0] = max(f[i + 1][0] - a[i], 0ll); for (int i = n; i &gt;= 1; --i) for (int j = 1; j &lt;= n - i + 1; ++j) f[i][j] = max(min(f[i + 1][j - 1], max(f[i + 1][j] - a[i], 0ll)), 0ll);&#125;int search(lint v) &#123; int l = 0, r = n, res = n; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (f[1][mid] &lt;= v) &#123; res = mid; r = mid - 1; else l = mid + 1; &#125; return res;&#125;int main() &#123; n = (int)read(); m = (int)read(); for (int i = 1; i &lt;= n; ++i) a[i] = (int)read(); init(); for (int i = 1; i &lt;= m; ++i) &#123; int p = search(read()); printf("%d\n", p); &#125;&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>普通</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>DP</tag>
        <tag>逆推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5195 - DZY Loves Topological Sorting]]></title>
    <url>%2F2019%2F07%2FHDU-5195-DZY-Loves-Topological-Sorting%2F</url>
    <content type="text"><![CDATA[没有 $k$ 条边的限制还是非常显然的。 对于这 $k$ 条边，要么先找出来，要么在后续操作中顺势而为。 先找出来只能是把字典序最大的，入边全部置空，剩下的无法操作。 在操作中，考虑现在可以删除 $k$ 条边，即进行拓扑的点的度数可以为 $0 \sim k$ ，为了字典序最大，需要在满足这些度数的点中找出一个字典序最大的。利用线段树可以找到。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define MAXN 100005#define INF 0x3f3f3f3f#define ls x &lt;&lt; 1#define rs x &lt;&lt; 1 | 1using namespace std;int n, m, k;int ind[MAXN];int head[MAXN], cnt;struct data &#123; int next, to; data(int next = 0, int to = 0):next(next), to(to) &#123;&#125;&#125;edge[MAXN &lt;&lt; 1];struct segment &#123; int l, r, v; segment(int l = 0, int r = 0, int v = 0):l(l), r(r), v(v) &#123;&#125;&#125;t[MAXN &lt;&lt; 2];void connect(int u, int v) &#123; edge[++cnt] = data(head[u], v); head[u] = cnt;&#125;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void pushup(int x) &#123; t[x].v = min(t[ls].v, t[rs].v);&#125;void build(int l = 1, int r = n, int x = 1) &#123; t[x].l = l; t[x].r = r; if (l == r) &#123; t[x].v = ind[l]; return ; &#125; int mid = (l + r) &gt;&gt; 1; build(l, mid, ls); build(mid + 1, r, rs); pushup(x);&#125;int query(int k, int x = 1) &#123; if (t[x].l == t[x].r) return t[x].l; if (t[rs].v &lt;= k) return query(k, rs); return query(k, ls);&#125;void modify(int p, int x = 1) &#123; if (t[x].l == t[x].r) &#123; --t[x].v; return ; &#125; int mid = (t[x].l + t[x].r) &gt;&gt; 1; if (p &lt;= mid) modify(p, ls); else modify(p, rs); pushup(x);&#125;void change(int p, int x = 1) &#123; if (t[x].l == t[x].r) &#123; t[x].v = INF; return ; &#125; int mid = (t[x].l + t[x].r) &gt;&gt; 1; if (p &lt;= mid) change(p, ls); else change(p, rs); pushup(x);&#125;void solve() &#123; for (int i = 1; i &lt;= n; ++i) &#123; int u = query(k); k -= ind[u]; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to; --ind[v]; modify(v); &#125; printf("%d", u); printf(i == n ? "\n" : " "); change(u); &#125;&#125;int main() &#123; while (~scanf("%d%d%d", &amp;n, &amp;m, &amp;k)) &#123; memset(head, 0, sizeof(head)); memset(ind, 0, sizeof(ind)); cnt = 0; for (int i = 1; i &lt;= m; ++i) &#123; int u = read(), v = read(); connect(u, v); ++ind[v]; &#125; build(); solve(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>基础</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>线段树</tag>
        <tag>拓扑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 2839 - [国家集训队]middle]]></title>
    <url>%2F2019%2F07%2FLuogu-2839-%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-middle%2F</url>
    <content type="text"><![CDATA[根据中位数的固定套路，应该二分答案，比他大的置 $1$，比他小的置 $-1$ 。如此对于一段区间，若和为正数，则答案还可以更大些；反之需更小。 对于题目要求，发现 $[b + 1, c - 1]$ 是必须取的，然后再取 $[a, b]$ 的最大后缀和和 $[c, d]$ 的最大前缀和，若和大于 $0$，则答案更大往上二分。 正确性？和大于 $0$ 保证必然存在一段序列使得中位数较现在所二分的答案大。同时，最后得到的结果必然是和等于 $0$ 的。大于 $0$ 则有更大解，小于 $0$ 则不是中位数，也保证了结果的合法性。 如此复杂度是 $O(nq\log n)$ 的，主要复杂度出在 $1, -1$ 序列上。 发现对于两个排名相邻的数，其序列大致相同。于是乎，可以用主席树维护可持久化数组来进行优化，省去每次建立序列的复杂度，降到 $O(q \log n)$ 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define MAXN 100010#define INF 0x3f3f3f3fusing namespace std;int n, q, total;int A[MAXN];int root[MAXN];int s[MAXN];struct node &#123; int v, p; node (int v = 0, int p = 0):v(v), p(p) &#123;&#125; bool operator &lt; (const node a) const &#123; return v &lt; a.v; &#125;&#125;B[MAXN];struct data &#123; int sum, maxl, maxr, maxi; data(int sum = 0, int maxl = -INF, int maxr = -INF, int maxi = 0):sum(sum), maxl(maxl), maxr(maxr), maxi(maxi) &#123;&#125; data operator + (const data b) const &#123; data c; c.sum = sum + b.sum; c.maxi = max(maxi, max(b.maxi, maxr + b.maxl)); c.maxl = max(maxl, sum + b.maxl); c.maxr = max(b.maxr, b.sum + maxr); return c; &#125;&#125;;struct segment &#123; int l, r; data a;&#125;t[MAXN &lt;&lt; 5];int build(int l, int r) &#123; int x = ++total; if (l == r) &#123; t[x].a.sum = t[x].a.maxl = t[x].a.maxr = t[x].a.maxi = 1; return x; &#125; int mid = (l + r) &gt;&gt; 1; t[x].l = build(l, mid); t[x].r = build(mid + 1, r); t[x].a = t[t[x].l].a + t[t[x].r].a; return x;&#125;int append(int last, int l, int r, int p, int v) &#123; int x = ++total; t[x] = t[last]; if (l == r) &#123; t[x].a.sum += v; t[x].a.maxi += v; t[x].a.maxl += v; t[x].a.maxr += v; return x; &#125; int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) t[x].l = append(t[last].l, l, mid, p, v); else t[x].r = append(t[last].r, mid + 1, r, p, v); t[x].a = t[t[x].l].a + t[t[x].r].a; return x;&#125;int read() &#123; char c = getchar(); int x = 0; while (c &lt; '0' || c &gt; '9') c = getchar(); while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;data query(int ql, int qr, int l, int r, int x) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return t[x].a; int mid = (l + r) &gt;&gt; 1; data res; if (ql &lt;= mid) res = res + query(ql, qr, l, mid, t[x].l); if (qr &gt; mid) res = res + query(ql, qr, mid + 1, r, t[x].r); return res;&#125;bool check(int k, int a, int b, int c, int d) &#123; int val = 0; data res; res = query(a, b, 1, n, root[k]); val = val + res.maxr; res = query(c, d, 1, n, root[k]); val = val + res.maxl; if (b &lt;= c - 2) &#123; res = query(b + 1, c - 1, 1, n, root[k]); val = val + res.sum; &#125; return val &gt;= 0;&#125;int solve(int a, int b, int c, int d) &#123; int l = 1, r = n, ans = -1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid, a, b, c, d)) l = mid + 1, ans = mid; else r = mid - 1; &#125; return ans;&#125;int main() &#123; n = read(); for (int i = 1; i &lt;= n; ++i) &#123; B[i].v = A[i] = read(); B[i].p = i; &#125; sort(B + 1, B + n + 1); build(1, n); root[0] = 1; root[1] = root[0]; for (int i = 2; i &lt;= n; ++i) root[i] = append(root[i - 1], 1, n, B[i - 1].p, -2); q = read(); int last = 0; for (int i = 1; i &lt;= q; ++i) &#123; int a = read(), b = read(), c = read(), d = read(); s[1] = (a + last) % n + 1; s[2] = (b + last) % n + 1; s[3] = (c + last) % n + 1; s[4] = (d + last) % n + 1; sort(s + 1, s + 5); last = B[solve(s[1], s[2], s[3], s[4])].v; printf("%d\n", last); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>基础</category>
        <category>主席树</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>二分</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 3285 - [SCOI2014]方伯伯的OJ]]></title>
    <url>%2F2019%2F07%2FLuogu-3285-SCOI2014-%E6%96%B9%E4%BC%AF%E4%BC%AF%E7%9A%84OJ%2F</url>
    <content type="text"><![CDATA[编号和排名似乎是不能同时维护的，于是分开维护。先用一棵平衡树直接维护排名，再用一棵平衡树来维护对于某一个编号对应排名平衡树的结点。 这样就结束了，可是操作里需要维护父亲结点，写 $\mbox{treap}$ 那必然是不想维护（事实上也就多一句话）。然后删掉写了发线段树，细节颇多： 现在只剩下一棵平衡树了，维护该编号的一个相对位置，即提前操作给他一个相对最小的权值，置后操作给他一个相对最大的权值，利用动态开点线段树就能实现插入了。 由于 $n$ 的数量级过大，那么如何统计排名呢？已知最小值 $l$ 和最大值 $r$ ，已知当前相对位置 $k$ ，排名为 $k - l + 1$ 。同时会有前面的数被提前或置后，即那个位置的数被删除了，线段树维护一下前面一段被删去的个数 $s$ ，真实排名为 $k - l + 1 - s$ 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;map&gt;#define MAXN 100005#define MINI -100100005#define MAXI 100100005using namespace std;struct segment &#123; int l, r, s; segment(int l = 0, int r = 0, int s = 0):l(l), r(r), s(s) &#123;&#125;&#125;t[MAXN &lt;&lt; 6];int n, m, total = 1, root = 1, L, R;map&lt;int, int&gt; id, number;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void modify(int l, int r, int n, int&amp; x) &#123; if (!x) x = ++total; ++t[x].s; if (l == r) return ; int mid = (l + r) &gt;&gt; 1; if (n &lt;= mid) modify(l, mid, n, t[x].l); else modify(mid + 1, r, n, t[x].r);&#125;int query(int l, int r, int k, int x) &#123; if (l == r) return l; int mid = (l + r) &gt;&gt; 1, s = max(0, min(R, mid) - max(l, L) + 1 - t[t[x].l].s); if (s &gt;= k) return query(l, mid, k, t[x].l); else return query(mid + 1, r, k - s, t[x].r);&#125;int ranking(int l, int r, int n, int x) &#123; if (!t[x].s) return 0; if (l == r) return 1; int mid = (l + r) &gt;&gt; 1; if (n &lt;= mid) return ranking(l, mid, n, t[x].l); else return ranking(mid + 1, r, n, t[x].r) + t[t[x].l].s;&#125;int ranking(int x) &#123; int cur = id.count(x) ? id[x] : x; return cur - L - ranking(MINI, MAXI, cur, root) + 1;&#125;int change(int x, int y) &#123; int cur = id.count(x) ? id[x] : x, res = ranking(x); id[y] = cur; number[cur] = y; id.erase(x); return res;&#125;int top(int x) &#123; int cur = id.count(x) ? id[x] : x, res = ranking(x); modify(MINI, MAXI, cur, root); id[x] = --L; number[L] = x; return res;&#125;int back(int x) &#123; int cur = id.count(x) ? id[x] : x, res = ranking(x); modify(MINI, MAXI, cur, root); id[x] = ++R; number[R] = x; return res;&#125;int query(int k) &#123; int t = query(MINI, MAXI, k, root); return number.count(t) ? number[t] : t;&#125;int main() &#123; n = read(); m = read(); L = 1; R = n; int ans = 0; while (m--) &#123; int opt = read(); if (opt == 1) &#123; int x = read() - ans, y = read() - ans; printf("%d\n", ans = change(x, y)); &#125; else if (opt == 2) &#123; int x = read() - ans; printf("%d\n", ans = top(x)); &#125; else if (opt == 3) &#123; int x = read() - ans; printf("%d\n", ans = back(x)); &#125; else &#123; int k = read() - ans; printf("%d\n", ans = query(k)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>基础</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 817F - MEX Queries]]></title>
    <url>%2F2019%2F07%2FCodeforces-817F-MEX-Queries%2F</url>
    <content type="text"><![CDATA[线段树题居然调了一早上。 题目要求的是各种常规操作，有个区间覆盖标记和区间取反标记，注意这里区间覆盖标记可以覆盖掉区间取反标记，区间取反标记取反区间覆盖标记，就是标记的互相影响需要注意。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt; #define MAXN 600005#define ls x &lt;&lt; 1#define rs x &lt;&lt; 1 | 1 typedef long long lint; using namespace std; int n, N;lint b[MAXN];int INF; struct option &#123; int type; lint l, r;&#125;a[MAXN]; struct segment &#123; int l, r, sum, tag, rev;&#125;t[MAXN &lt;&lt; 2]; lint read() &#123; char c = getchar(); lint x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125; void build(int l = 1, int r = N, int x = 1) &#123; t[x].l = l; t[x].r = r; t[x].sum = r - l + 1; t[x].tag = t[x].rev = 0; if (l == r) return ; int mid = (l + r) &gt;&gt; 1; build(l, mid, ls); build(mid + 1, r, rs);&#125; void pushup(int x) &#123; t[x].sum = t[ls].sum + t[rs].sum;&#125; void pushdown(int x) &#123; if (t[x].tag) &#123; t[ls].tag = t[rs].tag = t[x].tag; t[ls].sum = (2 - t[x].tag) * (t[ls].r - t[ls].l + 1); t[rs].sum = (2 - t[x].tag) * (t[rs].r - t[rs].l + 1); t[x].rev = t[x].tag = 0; &#125; if (t[x].rev) &#123; if (t[ls].tag &amp;&amp; t[rs].tag != 3) t[ls].tag = (3 - t[ls].tag); else t[ls].rev ^= 1; if (t[rs].tag &amp;&amp; t[rs].tag != 3) t[rs].tag = (3 - t[rs].tag); else t[rs].rev ^= 1; t[ls].sum = (t[ls].r - t[ls].l + 1) - t[ls].sum; t[rs].sum = (t[rs].r - t[rs].l + 1) - t[rs].sum; t[x].rev = 0; &#125;&#125; void modify(int l, int r, int v, int x = 1) &#123; if (l &lt;= t[x].l &amp;&amp; t[x].r &lt;= r) &#123; t[x].sum = (2 - v) * (t[x].r - t[x].l + 1); t[x].tag = v; return ; &#125; pushdown(x); int mid = (t[x].l + t[x].r) &gt;&gt; 1; if (l &lt;= mid) modify(l, r, v, ls); if (r &gt; mid) modify(l, r, v, rs); pushup(x);&#125; void change(int l, int r, int x = 1) &#123; if (l &lt;= t[x].l &amp;&amp; t[x].r &lt;= r) &#123; if (t[x].tag &amp;&amp; t[x].tag &lt;= 2) t[x].tag = 3 - t[x].tag; else t[x].rev ^= 1; t[x].sum = (t[x].r - t[x].l + 1) - t[x].sum; return ; &#125; pushdown(x); int mid = (t[x].l + t[x].r) &gt;&gt; 1; if (l &lt;= mid) change(l, r, ls); if (r &gt; mid) change(l, r, rs); pushup(x);&#125; int query(int x = 1) &#123; if (t[x].l == t[x].r) return t[x].l; pushdown(x); int res; if (t[ls].sum) res = query(ls); else res = query(rs); pushup(x); return res;&#125; int main() &#123; n = read(); for (int i = 1; i &lt;= n; ++i) &#123; a[i].type = read(); b[i * 3 - 2] = a[i].l = read(); b[i * 3 - 1] = a[i].r = read(); b[i * 3] = a[i].r + 1; &#125; b[n * 3 + 1] = 1; sort(b + 1, b + (n * 3) + 2); N = unique(b + 1, b + (n * 3) + 2) - b - 1; INF = N; for (int i = 1; i &lt;= n; ++i) &#123; a[i].l = lower_bound(b + 1, b + N + 1, a[i].l) - b; a[i].r = lower_bound(b + 1, b + N + 1, a[i].r) - b; &#125; build(); for (int i = 1; i &lt;= n; ++i) &#123; int opt = a[i].type; if (opt == 1) &#123; modify(a[i].l, a[i].r, 2); printf("%I64d\n", b[query()]); &#125; else if (opt == 2) &#123; modify(a[i].l, a[i].r, 1); printf("%I64d\n", b[query()]); &#125; else &#123; change(a[i].l, a[i].r); printf("%I64d\n", b[query()]); &#125; &#125; &#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>基础</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 3823 - [NOI2017]蚯蚓排队]]></title>
    <url>%2F2019%2F07%2FLuogu-3823-NOI2017-%E8%9A%AF%E8%9A%93%E6%8E%92%E9%98%9F%2F</url>
    <content type="text"><![CDATA[蚯蚓的操作应当用链表解决，对于题目要查询的那个乘积，直接开个哈希表进去查就行了。 合并、分割时链表往前往后分别计算一下哈希值即可。 复杂度似乎是可以过的，有点玄学。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAXN 200005#define MAXK 55typedef unsigned long long ulint;typedef long long lint;using namespace std;const int M = 998244353;const int mod = (1 &lt;&lt; 23) - 1;const int H = 131;int n, m;ulint bin[MAXK];char s[MAXN];int head[mod + 5], cnt;struct data &#123; int next, amount; ulint value; data(int next = 0, int amount = 0, ulint value = 0):next(next), amount(amount), value(value) &#123;&#125;&#125;edge[MAXN &lt;&lt; 5];struct node &#123; int l, r, v; node(int l = 0, int r = 0, int v = 0):l(l), r(r), v(v) &#123;&#125;&#125;a[MAXN];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void add(ulint w, int d) &#123; int u = w % mod; for (int i = head[u]; i; i = edge[i].next) if (edge[i].value == w) &#123; edge[i].amount += d; return ; &#125; edge[++cnt] = data(head[u], d, w); head[u] = cnt;&#125;void init() &#123; bin[0] = 1; for (int i = 1; i &lt;= 50; ++i) bin[i] = bin[i - 1] * H; for (int i = 1; i &lt;= n; ++i) add(a[i].v, 1);&#125;void merge(int u, int v, int d) &#123; vector&lt;int&gt; f, g; for (int i = 1; i &lt;= 49 &amp;&amp; u; ++i) &#123; f.push_back(u); u = a[u].l; &#125; for (int i = 1; i &lt;= 49 &amp;&amp; v; ++i) &#123; g.push_back(v); v = a[v].r; &#125; ulint value = 0; for (int i = 0; i &lt; f.size(); ++i) &#123; value = value + a[f[i]].v * bin[i]; ulint temp = value; for (int j = 0; j &lt; g.size() &amp;&amp; i + j + 2 &lt;= 50; ++j) &#123; temp = temp * H + a[g[j]].v; add(temp, d); &#125; &#125;&#125;void link(int u, int v) &#123; a[v].l = u; a[u].r = v; merge(u, v, 1);&#125;void cut(int u) &#123; int v = a[u].r; a[u].r = a[v].l = 0; merge(u, v, -1);&#125;lint mul(ulint w) &#123; int u = w % mod; for (int i = head[u]; i; i = edge[i].next) if (edge[i].value == w) return edge[i].amount; return 0;&#125;int query(char* s, int n, int k) &#123; ulint v = 0; lint res = 1; for (int i = 1; i &lt;= k; ++i) v = v * H + (s[i] - '0'); res = res * mul(v) % M; for (int i = k + 1; i &lt;= n; ++i) &#123; v = (v - (s[i - k] - '0') * bin[k - 1]) * H + (s[i] - '0'); res = res * mul(v) % M; &#125; return res % M;&#125;int main() &#123; n = read(); m = read(); for (int i = 1; i &lt;= n; ++i) a[i].v = read(); init(); while (m--) &#123; int opt = read(); if (opt == 1) &#123; int u = read(), v = read(); link(u, v); &#125; else if (opt == 2) &#123; int u = read(); cut(u); &#125; else &#123; scanf("%s", s + 1); int n = (int)strlen(s + 1), k = read(); printf("%d\n", query(s, n, k)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>哈希</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>哈希</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 475D - CGCDSSQ]]></title>
    <url>%2F2019%2F07%2FCodeforces-475D-CGCDSSQ%2F</url>
    <content type="text"><![CDATA[这道题本身很简单，只是记录一下一类解法。 对于一个序列，求任意一段子序列的 $\mbox{gcd}$ 时，其不同值最多只有 $n\log n$ 个，证明如下： 对于一个确定左端点的子序列，其最大公约数不同值最多有 $\log n$ 个，共有 $n$ 个左端点，故。 可以用线段树、$\mbox{SA}$ 、$\mbox{vector}$ 等实现 ，此处用最后一个。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt; #define MAXN 300005typedef long long lint;using namespace std; struct node &#123; int g, p; node(int g = 0, int p = 0):g(g), p(p) &#123;&#125;&#125;; map&lt;int, int&gt; rec, ref;vector&lt;node&gt; h[MAXN];int n, q;lint ans[MAXN];int a[MAXN]; int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125; void init() &#123; for (int i = 1; i &lt;= n; ++i) &#123; h[i].push_back(node(a[i], i)); int current = a[i]; for (int j = 0; j &lt; h[i - 1].size(); ++j) &#123; int temp = __gcd(current, h[i - 1][j].g); if (temp != current) h[i].push_back(node(current = temp, h[i - 1][j].p)); &#125; &#125;&#125; void solve() &#123; for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt; h[i].size(); ++j) &#123; if (!rec[h[i][j].g]) continue; int r = h[i][j].p, l = j == h[i].size() - 1 ? 1 : h[i][j + 1].p + 1; ans[rec[h[i][j].g]] += r - l + 1; &#125;&#125; int main() &#123; n = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); init(); q = read(); for (int i = 1; i &lt;= q; ++i) &#123; int x = read(); if (!rec[x]) &#123; rec[x] = i; ref[i] = i; &#125; else ref[i] = rec[x]; &#125; solve(); for (int i = 1; i &lt;= q; ++i) printf("%I64d\n", ans[ref[i]]);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>质数</category>
        <category>gcd</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1163F - Indecisive Taxi Fee]]></title>
    <url>%2F2019%2F05%2FCodeforces-1163F-Indecisive-Taxi-Fee%2F</url>
    <content type="text"><![CDATA[据说是一类经典的题目：改边最短路。然而这还是我碰见的第一次……看来题量还是不够大。 首先任意找出一条最短路，接下来的一次修改操作 $(u, v)$ 分为两种情况讨论： 修改的边不在最短路上： 那么答案显然是原最短路的长度与 $\mbox{dis}_{1, u} + \mbox{dis}_{v, n} + \mbox{new}_{u, v}$ 相比的最小值。 修改的边在最短路上： 那么这就涉及到了找出一条不经过原最短路某个部分的最短路问题了。 仔细分析一下，似乎有某一些结论：$\mbox{dis}_{1, u}$ 一定经过最短路的一段前缀，同理，$\mbox{dis}_{u, n}$ 一定经过最短路的一段后缀。 对于不经过最短路上某一区间的问题，易知他们必然经过一条不在最短路上的边。 设最短路为 $e_1, e_2, \dots$ ，那么对于一个不在最短路上的边 $(u, v)$ ，记 $e$ 上与两端点分别相连的是 $p, q$ ，那么便可以更新不经过 $p, q - 1$ 这一段区间的最短路值，为：$\mbox{dis}_{1, u} + \mbox{dis}_{v, n} + \mbox{dis}_{u, v}$ 。 不难证明任意一条合法的最短路必然被不在最短路上的边更新至少一次。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#define MAXN 200005#define INF 0x3f3f3f3f3f3f3f3f#define ls x &lt;&lt; 1#define rs x &lt;&lt; 1 | 1typedef long long lint;using namespace std;int n, m, q;int head[MAXN], cnt;int from[MAXN], to[MAXN];lint pre[MAXN], suf[MAXN];int last[MAXN];bool visit[MAXN], token[MAXN];int sign[MAXN], total;struct node &#123; int u; lint d; node(int u = 0, lint d = 0):u(u), d(d) &#123;&#125; bool operator &lt; (const node b) const &#123; return d &gt; b.d; &#125;&#125;;struct data &#123; int next, to, cost, id; data(int next = 0, int to = 0, int cost = 0, int id = 0):next(next), to(to), cost(cost), id(id) &#123;&#125;&#125;edge[MAXN &lt;&lt; 1];struct segment &#123; int l, r; lint v;&#125;t[MAXN &lt;&lt; 2];struct section &#123; int u, v, w; section(int u = 0, int v = 0, int w = 0):u(u), v(v), w(w) &#123;&#125;&#125;a[MAXN];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void build(int l, int r, int x = 1) &#123; t[x].v = INF; t[x].l = l; t[x].r = r; if (l == r) return ; int mid = (l + r) &gt;&gt; 1; build(l, mid, ls); build(mid + 1, r, rs);&#125;void modify(int l, int r, lint v, int x = 1) &#123; if (l &gt; r) return ; if (l &lt;= t[x].l &amp;&amp; t[x].r &lt;= r) &#123; t[x].v = min(t[x].v, v); return ; &#125; int mid = (t[x].l + t[x].r) &gt;&gt; 1; if (l &lt;= mid) modify(l, r, v, ls); if (r &gt; mid) modify(l, r, v, rs);&#125;lint query(int p, int x = 1) &#123; if (t[x].l == t[x].r) return t[x].v; int mid = (t[x].l + t[x].r) &gt;&gt; 1; if (p &lt;= mid) return min(t[x].v, query(p, ls)); else return min(t[x].v, query(p, rs));&#125;void connect(int u, int v, int w, int id) &#123; edge[++cnt] = data(head[u], v, w, id); head[u] = cnt;&#125;void Dijkstra(int S, lint* d, int type) &#123; memset(visit, 0, sizeof(visit)); priority_queue&lt;node&gt; q; for (int i = 1; i &lt;= n; ++i) d[i] = INF; d[S] = 0; q.push(node(S, d[S])); while (!q.empty()) &#123; int u = q.top().u; q.pop(); if (visit[u]) continue; visit[u] = true; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to, w = edge[i].cost; if (d[u] + w &lt; d[v]) &#123; if (type == 1) last[v] = edge[i].id; if (type == 2 &amp;&amp; !token[v]) from[v] = from[u]; if (type == 3 &amp;&amp; !token[v]) to[v] = to[u]; d[v] = d[u] + w; q.push(node(v, d[v])); &#125; &#125; &#125;&#125;void find() &#123; int cur = 1; while (cur != n) &#123; sign[last[cur]] = ++total; token[cur] = true; from[cur] = to[cur] = total; cur = a[last[cur]].u ^ a[last[cur]].v ^ cur; &#125; token[n] = true; from[n] = to[n] = total + 1;&#125;int main() &#123; n = read(); m = read(); q = read(); for (int i = 1; i &lt;= m; ++i) &#123; int u = read(), v = read(), w = read(); connect(u, v, w, i); connect(v, u, w, i); a[i] = section(u, v, w); &#125; Dijkstra(n, suf, 1); find(); Dijkstra(1, pre, 2); Dijkstra(n, suf, 3); build(1, total); for (int i = 1; i &lt;= m; ++i) &#123; int u = a[i].u, v = a[i].v, w = a[i].w; if (sign[i]) continue; modify(from[u], to[v] - 1, pre[u] + suf[v] + w); modify(from[v], to[u] - 1, pre[v] + suf[u] + w); &#125; while (q--) &#123; int t = read(), w = read(), u = a[t].u, v = a[t].v; if (sign[t]) printf("%I64d\n", min(pre[n] + w - a[t].w, query(sign[t]))); else printf("%I64d\n", min(pre[n], min(pre[u] + suf[v] + w, pre[v] + suf[u] + w))); &#125;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1167E - Range Deleting]]></title>
    <url>%2F2019%2F05%2FCodeforces-1167E-Range-Deleting%2F</url>
    <content type="text"><![CDATA[考虑一个结论：对于一个非严格不下降序列，对于一个数 $x$ ，可以保证其与 $x - 1$ 与 $x + 1$ 所在的区间必然没有交集。 利用该结论，可以判断对于值域 $1\sim x$ 的区间是否可行，同时可以判断对于 $x \sim n$ 是否可行，如此便可以二分出一个区间 $[l, r]$ 使得 $1 \sim l$ 可行，且 $r \sim n$ 可行，且 $1 \sim l$ 与 $r \sim n$ 没有交集。那么任意以 $l$ 为左端点， 右端点取值范围在 $[l + 1, r]$ 都是可行区间。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define MAXN 1000006#define INF 0x3f3f3f3ftypedef long long lint;using namespace std;int n, m;int l[MAXN], r[MAXN];int pre[MAXN], suf[MAXN];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;bool check(int x, int v) &#123; if (suf[x + 1] == -1) return false; return suf[x + 1] &gt; v;&#125;int bound(int v, int l, int r) &#123; int res = 1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid, v)) &#123; r = mid - 1; res = mid; &#125; else l = mid + 1; &#125; return res;&#125;int main() &#123; memset(l, 0x3f, sizeof(l)); n = read(); m = read(); for (int i = 1; i &lt;= n; ++i) &#123; int x = read(); l[x] = min(l[x], i); r[x] = max(r[x], i); &#125; for (int i = 1; i &lt;= m; ++i) &#123; if (pre[i - 1] == -1) pre[i] = -1; if (l[i] != INF) &#123; if (l[i] &lt; pre[i - 1]) pre[i] = -1; else pre[i] = r[i]; &#125; else pre[i] = pre[i - 1]; &#125; suf[m + 1] = INF; for (int i = m; i &gt;= 1; --i) &#123; if (suf[i + 1] == -1) suf[i] = -1; if (r[i]) &#123; if (r[i] &gt; suf[i + 1]) suf[i] = -1; else suf[i] = l[i]; &#125; else suf[i] = suf[i + 1]; &#125; lint ans = 0; for (int i = 1; i &lt;= m; ++i) &#123; if (pre[i - 1] == -1) break; int p = bound(pre[i - 1], i, m); ans = ans + (m - p + 1); &#125; printf("%I64d\n", ans);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>组合数学</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 5217 - 航海舰队]]></title>
    <url>%2F2019%2F05%2FBZOJ-5217-%E8%88%AA%E6%B5%B7%E8%88%B0%E9%98%9F%2F</url>
    <content type="text"><![CDATA[二维转一维 $\mbox{FFT}$ 。 首先先划分出包含舰队的最小矩形。不难发现若一个舰队的位置不合法，当且仅当有某一舰船与岩石相冲突。若转化成一维问题，以舰队最左上角的格子 $a$ 作为基准，进行匹配，则是 $r_{i + p} = s_{i}$ ，那么将 $s$ 反转即是一个卷积问题。依此可以确定 $a$ 的限定位置集合，同时要 $\mbox{BFS}$ 判断这些限定位置的合法性。 再考虑哪一些格子是合法的？ 还是转化成一维来看：$i$ 位置合法且 $j$ 位置有船，那么 $i + j$ 位置必然可达。 虽然转化成了二维，但是并不会出现跨行转移一类的非法情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define MAXN 705#define INF 0x3f3f3f3fusing namespace std;int n, m, x, y, lx, ly, rx, ry;int dx[] = &#123;0, 1, 0, -1, 0&#125;, dy[] = &#123;0, 0, 1, 0, -1&#125;;bool visit[MAXN][MAXN];char s[MAXN][MAXN];int r[MAXN * MAXN * 4];int ans[MAXN * MAXN * 4];vector&lt;int&gt; legal;struct node &#123; int x, y; node(int x = 0, int y = 0):x(x), y(y) &#123;&#125;&#125;;struct complex &#123; double x, y; complex(double x = 0, double y = 0):x(x), y(y) &#123;&#125; complex operator + (const complex b) const &#123; return complex(x + b.x, y + b.y); &#125; complex operator - (const complex b) const &#123; return complex(x - b.x, y - b.y); &#125; complex operator * (const complex b) const &#123; return complex(x * b.x - y * b.y, x * b.y + y * b.x); &#125;&#125;a[MAXN * MAXN * 4], b[MAXN * MAXN * 4];;int get(int x, int y) &#123; return (x - 1) * m + y;&#125;void BFS(int x, int y) &#123; queue&lt;node&gt; q; q.push(node(x, y)); visit[x][y] = false; while (!q.empty()) &#123; int x = q.front().x, y = q.front().y; q.pop(); a[get(x, y) - 1].x = 1; for (int i = 1; i &lt;= 4; ++i) &#123; int nx = x + dx[i], ny = y + dy[i]; if (nx &lt; 1 || nx &gt; n || ny &lt; 1 || ny &gt; m || !visit[nx][ny]) continue; visit[nx][ny] = false; q.push(node(nx, ny)); &#125; &#125;&#125;void init() &#123; lx = ly = INF; rx = ry = -INF; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) if (s[i][j] == '#') a[n * m - get(i, j)].x = 1; else if (s[i][j] == 'o') &#123; lx = min(lx, i); ly = min(ly, j); rx = max(rx, i); ry = max(ry, j); &#125; for (int i = lx; i &lt;= rx; ++i) for (int j = ly; j &lt;= ry; ++j) if (s[i][j] == 'o') b[get(i - lx + 1, j - ly + 1) - 1].x = 1;&#125;int getr(int n) &#123; int size = 0, limit = 1; while (limit &lt;= n) &#123; limit &lt;&lt;= 1; ++size; &#125; for (int i = 0; i &lt; limit; ++i) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (size - 1)); return limit;&#125;void FFT(complex* a, int n, int opt) &#123; for (int i = 0; i &lt; n; ++i) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int i = 1; i &lt; n; i &lt;&lt;= 1) &#123; complex wn = complex(cos(M_PI / i), sin(M_PI / i) * opt); for (int j = 0; j &lt; n; j += (i &lt;&lt; 1)) &#123; complex w(1, 0); for (int k = 0; k &lt; i; ++k) &#123; complex x = a[j + k], y = a[j + k + i] * w; a[j + k] = x + y; a[j + k + i] = x - y; w = w * wn; &#125; &#125; &#125;&#125;void solve() &#123; int limit = getr((n * m) &lt;&lt; 1); FFT(a, limit, 1); FFT(b, limit, 1); for (int i = 0; i &lt; limit; ++i) a[i] = a[i] * b[i]; FFT(a, limit, -1); for (int i = 0; i &lt; limit; ++i) a[i].x = (int)(a[i].x / limit + 0.5); for (int i = 1; i &lt;= n - (rx - lx); ++i) for (int j = 1; j &lt;= m - (ry - ly); ++j) if (a[n * m - get(i, j)].x == 0) visit[i][j] = true; memset(a, 0, sizeof(a)); BFS(lx, ly); FFT(a, limit, 1); for (int i = 0; i &lt; limit; ++i) a[i] = a[i] * b[i]; FFT(a, limit, -1); for (int i = 0; i &lt; limit; ++i) a[i].x = (int)(a[i].x / limit + 0.5); int ans = 0; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) if (a[get(i, j) - 1].x) ++ans; printf("%d\n", ans);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf("%s", s[i] + 1); init(); solve();&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1007D - Ants]]></title>
    <url>%2F2019%2F05%2FCodeforces-1007D-Ants%2F</url>
    <content type="text"><![CDATA[稍微翻译下：用 $m$ 种路径为一棵树染色，每一种颜色都有两条备选路径，对于路径上的变，需要染成颜色 $i$ 。问是否有一种方式，使得每一种颜色都至少有一条路径满足条件。 随便考虑一条路径，是有两种可能的状态：满足条件或不满足条件。据此，理应使用 $\mbox{2-SAT}$ 解决问题。 显然需要树链剖分，那么对于一条链 $(u, v)$ ，若他已经被染成了颜色 $c$ ，那么其链上的任意一条边都应该为颜色 $c$ 。换而言之，就是线段树上的节点到根的路径上，应该只有一种颜色。 边太多了，考虑前缀优化建图。 前缀优化建图通常用来处理某个命题集合种最多有一个命题成立或不成立的情况。现在考虑最多只有一个命题成立的情况。 假设这些命题的编号为 $1 \sim x$ ，那么新建 $x$ 个节点，用这些节点来表示集合的某个前缀的所有命题是否存在成立。若前缀存在成立的，则其为真；反之为假。 定义一次建边 $u \rightarrow v$ 为建：前者真 $\rightarrow$ 后者真，后者假 $\rightarrow$ 前者假。其为两条对称边。 建三种边： $1 \sim i$ 的命题均不成立 $\rightarrow$ $1 \sim i - 1$ 的命题均不成立。 命题 $i$ 成立 $\rightarrow$ $1 \sim i$ 的命题中存在成立。 命题 $i$ 成立 $\rightarrow$ $1 \sim i - 1$ 的命题中不存在成立。 线段树的节点显然是具有前缀性，于是在父节点的基础上继续前缀建边即可。 线段树一个节点上可能会有多段路径，需要依次处理，注意处理与父节点的关系。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include &lt;cstring&gt;#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#define MAXN 100005#define MAXM 6000005#define ls x &lt;&lt; 1#define rs x &lt;&lt; 1 | 1#define fs x &gt;&gt; 1using namespace std;stack&lt;int&gt; sta;int n, m, q, amount;int dep[MAXN], size[MAXN], top[MAXN], son[MAXN], fa[MAXN], tag[MAXN], rev[MAXN], total;int scc[MAXM];bool ins[MAXM];int dfn[MAXM], low[MAXM], number, quantity;vector&lt;int&gt; g[MAXN];int head[MAXM], cnt;struct data &#123; int next, to; data(int next = 0, int to = 0):next(next), to(to) &#123;&#125;&#125;edge[MAXM];struct segment &#123; int l, r, p, q; vector&lt;int&gt; g;&#125;t[MAXN &lt;&lt; 2];int zero(int x) &#123; return x &lt;&lt; 1;&#125;int one(int x) &#123; return x &lt;&lt; 1 | 1;&#125;void connect(int u, int v) &#123; edge[++cnt] = data(head[u], v); head[u] = cnt; edge[++cnt] = data(head[v ^ 1], u ^ 1); head[v ^ 1] = cnt;&#125;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void build(int l, int r, int x = 1) &#123; t[x].l = l; t[x].r = r; if (l == r) return ; int mid = (l + r) &gt;&gt; 1; build(l, mid, ls); build(mid + 1, r, rs);&#125;void insert(int l, int r, int v, int x = 1) &#123; if (l &lt;= t[x].l &amp;&amp; t[x].r &lt;= r) &#123; t[x].g.push_back(v); return ; &#125; int mid = (t[x].l + t[x].r) &gt;&gt; 1; if (l &lt;= mid) insert(l, r, v, ls); if (r &gt; mid) insert(l, r, v, rs);&#125;void DFS1(int u, int pre) &#123; fa[u] = pre; size[u] = 1; dep[u] = dep[pre] + 1; for (int i = 0; i &lt; g[u].size(); ++i) &#123; int v = g[u][i]; if (v == pre) continue; DFS1(v, u); size[u] = size[u] + size[v]; if (size[v] &gt; size[son[u]]) son[u] = v; &#125;&#125;void DFS2(int u, int pre) &#123; top[u] = pre; tag[u] = ++total; rev[total] = u; if (!son[u]) return ; DFS2(son[u], pre); for (int i = 0; i &lt; g[u].size(); ++i) &#123; int v = g[u][i]; if (v == fa[u] || v == son[u]) continue; DFS2(v, v); &#125;&#125;void append(int u, int v, int e) &#123; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); insert(tag[top[u]], tag[u], e); u = fa[top[u]]; &#125; if (dep[u] &gt; dep[v]) swap(u, v); insert(tag[u] + 1, tag[v], e);&#125;void construct(int x = 1) &#123; t[x].p = ++amount; amount = t[x].q = t[x].p + (int)t[x].g.size() - (!t[x].g.empty()); if (x != 1) &#123; connect(zero(t[x].p), zero(t[fs].q)); if (t[x].g.size()) &#123; connect(t[x].g[0], zero(t[fs].q)); &#125; &#125; for (int i = 0; i &lt; t[x].g.size(); ++i) &#123; int p = t[x].g[i]; if (i) &#123; connect(zero(t[x].p + i), zero(t[x].p + i - 1)); connect(p, zero(t[x].p + i - 1)); &#125; connect(p, one(t[x].p + i)); &#125; if (t[x].l == t[x].r) return ; construct(ls); construct(rs);&#125;void tarjan(int u) &#123; sta.push(u); ins[u] = true; dfn[u] = low[u] = ++number; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to; if (!dfn[v]) &#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; else if (ins[v]) low[u] = min(low[u], dfn[v]); &#125; if (dfn[u] == low[u]) &#123; int k; ++quantity; do &#123; k = sta.top(); sta.pop(); ins[k] = false; scc[k] = quantity; &#125; while (u != k); &#125;&#125;int main() &#123; n = read(); for (int i = 1; i &lt; n; ++i) &#123; int u = read(), v = read(); g[u].push_back(v); g[v].push_back(u); &#125; DFS1(1, 0); DFS2(1, 1); build(1, n); m = read(); for (int i = 1; i &lt;= m; ++i) &#123; int u1 = read(), v1 = read(), u2 = read(), v2 = read(); append(u1, v1, zero(i)); append(u2, v2, one(i)); &#125; amount = m; construct(); for (int i = 1; i &lt;= (amount &lt;&lt; 1 | 1); ++i) if (!dfn[i]) tarjan(i); for (int i = 1; i &lt;= m; ++i) if (scc[one(i)] == scc[zero(i)]) &#123; puts("NO"); return 0; &#125; puts("YES"); for (int i = 1; i &lt;= m; ++i) puts(scc[i &lt;&lt; 1] &lt; scc[i &lt;&lt; 1 | 1] ? "1" : "2");&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>强连通分量</category>
        <category>2-SAT</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>2-SAT</tag>
        <tag>强连通分量</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Baby Step Giant Step]]></title>
    <url>%2F2019%2F05%2FBaby-Step-Giant-Step%2F</url>
    <content type="text"><![CDATA[$\mbox{Baby Step Giant Step}$ 是处理一类问题的利器，适用于求解：$a^x \equiv b \pmod{p}$ 这类方程。 $\mbox{Baby Step Giant Step}$该方法只能解决以下问题： \begin{align*} a^x &\equiv b \pmod{p} \\ (a, p) &= 1 \end{align*}根据费马小定理，$a^{p - 1} \equiv 1 \pmod{p}$ 且 $a_{0} \equiv 1 \pmod{p}$ 可知其循环节小于 $p$ 。 稍稍借助分块的思想，将 $a^{x}$ 转化成 $a^{t \cdot i - j}$ 。其中，$t = \sqrt{p}$ ，注意这里使用相减可以避免使用逆元。 原式转化成： a^{t \cdot i} \equiv b \cdot a^j \pmod{p}$i \in [1, t], j \in [0, t - 1]$ ，都是 $\sqrt{p}$ 级别的 ，枚举后者丢到哈希表里，枚举前者查询即可。 12345678910111213141516171819202122232425typedef long long lint;unordered_map&lt;lint, int&gt; record;lint power(lint a, lint b, lint p);int BSGS(lint a, lint b, lint p) &#123; a = a % p; b = b % p; if (a == b) return 1; int t = sqrt(p) + 1; lint v = b; for (int i = 0; i &lt; t; ++i) &#123; record[v] = i; v = v * a % p; &#125; v = a = power(a, t, p); for (int i = 1; i &lt;= t; ++i) &#123; if (record.count(v)) return t * i - record[v]; v = v * a % p; &#125; return -1;&#125; $\mbox{Ex Baby Step Giant Step}$不是我不会拼 $\mbox{expand}$ 啊，是名字真的太长了…… 针对于上述算法的局限性，提出一个更加优秀的算法，可解决 $(a, p) \neq 1$ 的情况。 首先设 $d = (a, p)$ ，有： a^{x - 1}\frac{a}{d} \equiv \frac{b}{d} \pmod{\frac{p}{d}}我就证明一下这个结论，由其推导出上面等式成立： \begin{align*} &a \equiv b \pmod{p} \\ \Rightarrow & \frac{a}{d} \equiv \frac{b}{d} \pmod{\frac{p}{d}} \end{align*}首先先把式子写作：$a = t \cdot p + b$ ，左右同除 $d$ ：$\frac{a}{d} = t \cdot \frac{p}{d} + \frac{b}{d}$ ，又因为 $b &lt; p$ ，故成立。 一直循环，$a^{x’} = a^{x - 1}, b’ = \frac{b}{d}, p’ = \frac{p}{d}$ ，直到互质为止。 设 $c = \prod \limits_{i = 1}^{k} d_i$ ，有： a^{x - k}\frac{a^k}{c} \equiv \frac{b}{c} \pmod{\frac{p}{c}}既然已然互质，那么此时做一遍 $\mbox{BSGS}$ 即可。 但此时只能求出 $x \geq k$ 的最小值，需要检查 $x &lt; k$ 是否有解成立。 123456789101112131415161718192021222324252627282930313233343536373839404142434445typedef long long lint;unordered_map&lt;lint, int&gt; record;lint power(lint a, lint b, lint p);lint gcd(lint a, lint b);int BSGS(lint a, lint b, lint c, lint p) &#123; record.clear(); a = a % p; b = b % p; if (a == b) return 1; int t = sqrt(p) + 1; lint v = b; for (int i = 0; i &lt; t; ++i) &#123; record[v] = i; v = v * a % p; &#125; a = power(a, t, p); v = a * c % p; for (int i = 1; i &lt;= t; ++i) &#123; if (record.count(v)) return t * i - record[v]; v = v * a % p; &#125; return -1;&#125;int ExBSGS(lint a, lint b, lint p) &#123; int number = 0; lint d, c = 1; while ((d = gcd(a, p)) &gt; 1) &#123; if (b % d) return -1; ++number; b = b / d; p = p / d; c = c * (a / d) % p; if (b == c) return number; &#125; int res = BSGS(a, b, c, p); return res == -1 ? res : res + number;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>数论</category>
        <category>BSGS</category>
      </categories>
      <tags>
        <tag>BSGS</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 5346 - [XR-1]柯南家族]]></title>
    <url>%2F2019%2F05%2FLuogu-5346-XR-1-%E6%9F%AF%E5%8D%97%E5%AE%B6%E6%97%8F%2F</url>
    <content type="text"><![CDATA[非常新颖的一个做法，似乎是有想到类似的版本然而没有继续想下去？ 最难的部分是求出他们的聪明程度之排名，以下对此进行讨论。 首先最基础的操作 $O(n \log^2 n)$ ，就是插入时，实时查询当前在平衡树中和他比较的节点的聪明程度。然而由于平衡树的超大常数，妥妥的过不了，只能优化插入时的查询。 思考一下，其实我们并不需要知道他们权值的具体大小，只需要知道相对的孰大孰小即可。那么尝试给每一个人赋一个 $[0, 1]$ 的权值，用来表示他们的聪明程度 $c$ 。 这是一种相对的思想，那么对于一个插入的人 $u$ ，定义其前驱为 $v$ ，后继为 $w$ ，其聪明程度就是 $\frac{c_v + c_w}{2}$ ，这样插入对平衡树里的别的节点并不会产生任何的影响。 因此，一旦他们的聪明程度确定后，就不会发生改变了，可以线性查询。 这样也有一个弊端，即会爆精度。不难发现只有在平衡树极端失衡的时候会爆精度——利用替罪羊树的思想失衡重构即可，这样保证了除以二操作一定是 $\log n$ 次的，保证了精度。 既然已经知道了排名，直接主席树回答询问即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAXN 500005#define INF 0x3f3f3f3fusing namespace std;int n, m;int head[MAXN], cnt;int smart[MAXN], ranking[MAXN], rev[MAXN];int f[MAXN], size[MAXN], dfn[MAXN], amount;int segr[MAXN], chainr[MAXN];bool visit[MAXN];struct data &#123; int next, to; data(int next = 0, int to = 0):next(next), to(to) &#123;&#125;&#125;edge[MAXN &lt;&lt; 1];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void connect(int u, int v) &#123; edge[++cnt] = data(head[u], v); head[u] = cnt;&#125;namespace seg &#123; struct segment &#123; int l, r, v; segment(int l = 0, int r = 0, int v = 0):l(l), r(r), v(v) &#123;&#125; &#125;t[MAXN &lt;&lt; 6]; int total = 0; void insert(int l, int r, int p, int v, int&amp; u) &#123; t[u = ++total] = t[v]; ++t[u].v; if (l == r) return ; int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) insert(l, mid, p, t[v].l, t[u].l); else insert(mid + 1, r, p, t[v].r, t[u].r); &#125; int query(int l, int r, int k, int u, int v) &#123; if (l == r) return l; int mid = (l + r) &gt;&gt; 1, s = t[t[v].l].v - t[t[u].l].v; if (s &gt;= k) return query(l, mid, k, t[u].l, t[v].l); else return query(mid + 1, r, k - s, t[u].r, t[v].r); &#125;&#125;;namespace scape &#123; int ch[MAXN][2], size[MAXN], fa[MAXN], a[MAXN]; double ranking[MAXN]; int total = 0, root = 0, amount = 0; const double alpha = 0.75; void init() &#123; memset(ch, 0, sizeof(ch)); &#125; bool compare(int u, int v) &#123; if (smart[u] != smart[v]) return smart[u] &gt; smart[v]; if (f[u] &amp;&amp; f[v] &amp;&amp; f[u] != f[v]) return ranking[f[u]] &lt; ranking[f[v]]; return u &gt; v; &#125; bool isbalance(int u) &#123; return (double)max(size[ch[u][0]], size[ch[u][1]]) &lt;= alpha * size[u]; &#125; void recycle(int u) &#123; if (ch[u][0]) recycle(ch[u][0]); a[++amount] = u; if (ch[u][1]) recycle(ch[u][1]); &#125; int rebuild(double p, double q, int l, int r) &#123; if (l &gt; r) return 0; int mid = (l + r) &gt;&gt; 1, x = a[mid]; ranking[x] = (p + q) / 2; ch[x][0] = rebuild(p, ranking[x], l, mid - 1); ch[x][1] = rebuild(ranking[x], q, mid + 1, r); size[x] = size[ch[x][0]] + size[ch[x][1]] + 1; return x; &#125; void build(double l, double r, int&amp; u) &#123; amount = 0; recycle(u); u = rebuild(l, r, 1, amount); &#125; void insert(double l, double r, int v, int&amp; u, bool cover) &#123; if (!u) &#123; size[u = v] = 1; ranking[u] = (l + r) / 2; return ; &#125; ++size[u]; int w = !compare(v, u); insert(w ? ranking[u] : l, w ? r : ranking[u], v, ch[u][w], cover | (alpha * size[u] &lt; (size[ch[u][w]] + 1))); if (!cover &amp;&amp; !isbalance(u)) build(l, r, u); &#125; void insert(int v) &#123; insert(0, 1, v, root, 0); &#125;&#125;;void DFS(int u) &#123; dfn[u] = ++amount; size[u] = 1; seg::insert(1, n, ranking[u], chainr[f[u]], chainr[u]); seg::insert(1, n, ranking[u], segr[amount - 1], segr[amount]); for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to; DFS(v); size[u] = size[u] + size[v]; &#125;&#125;void build() &#123; scape::amount = 0; scape::recycle(scape::root); for (int i = 1; i &lt;= n; ++i) &#123; ranking[scape::a[i]] = i; rev[i] = scape::a[i]; &#125;&#125;int main() &#123; n = read(); m = read(); for (int i = 2; i &lt;= n; ++i) &#123; f[i] = read(); connect(f[i], i); &#125; smart[0] = -INF; for (int i = 1; i &lt;= n; ++i) &#123; smart[i] = read(); scape::insert(i); &#125; build(); DFS(1); while (m--) &#123; int opt = read(), u = read(); if (opt == 1) printf("%d\n", ranking[u]); else if (opt == 2) &#123; int k = read(); printf("%d\n", rev[seg::query(1, n, k, chainr[0], chainr[u])]); &#125; else &#123; int k = read(); printf("%d\n", rev[seg::query(1, n, k, segr[dfn[u] - 1], segr[dfn[u] + size[u] - 1])]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>基础</category>
        <category>平衡树</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>主席树</tag>
        <tag>替罪羊树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 5344 - [XR-1]逛森林]]></title>
    <url>%2F2019%2F05%2FLuogu-5344-XR-1-%E9%80%9B%E6%A3%AE%E6%9E%97%2F</url>
    <content type="text"><![CDATA[做这题真是愉悦身心！！！不过也确实发现了存在的知识盲点。 首先很显然的线段树优化建图，然后发现边总数大约是：$m\log^2 n$ ，出题人毒瘤随手就卡了。 他同时也指明了一个方向——倍增建图。 首先稍微介绍一下倍增建图： 长度为 $2^{i - 1}$ 的两个子区间与长度为 $2^i$ 的区间相连； 长度为 $2^0$ 的区间与端点相连； 接下来显然是应该将几个可以表示整段区间的点与新增的某一个虚点相连，一言难尽…… 倍增实在掌握的很差，绞尽脑汁各种方式建：按二进制划分区间总边数 $2m \log n$ 的建法，甚至先于之有一个更加愚蠢的，先跳到同一高度再按二进制划分的建法，这样总共划分了 $3$ 次， $3m \log n$ 。 为什么不借鉴一下 $\mbox{RMQ}$ 的写法呢？找到离其最近的 $2^i$ ，用它在一条链中，划分出两个长度相同，分别以链首链尾作为端点，且互相重叠的区间，这样连边次数最少，只有 $4m$ 种。 代码极丑请见谅……还有边表最好不要构造函数否则 $\mbox{double time}$ 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#define MAXN 3000005#define MAXE 10000005#define MAXB 50005#define INF 0x3f3f3f3fusing namespace std;int n, m, s, total, amount;int head[MAXN], cnt, root[2];int dep[MAXB], anc[MAXB], fa[MAXB][17], top[MAXB][17], bot[MAXB][17];int dis[MAXN];bool visit[MAXN];struct node &#123; int u, d; node(int u = 0, int d = 0):u(u), d(d) &#123;&#125; bool operator &lt; (const node b) const &#123; return d &gt; b.d; &#125;&#125;;struct opt &#123; int u1, v1, u2, v2, w; opt(int u1 = 0, int v1 = 0, int u2 = 0, int v2 = 0, int w = 0):u1(u1), v1(v1), u2(u2), v2(v2), w(w) &#123;&#125;&#125;a[MAXN / 3];struct data &#123; int next, to, cost; data(int next = 0, int to = 0, int cost = 0):next(next), to(to), cost(cost) &#123;&#125;&#125;edge[MAXE];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void connect(int u, int v, int w) &#123; edge[++cnt] = data(head[u], v, w); head[u] = cnt;&#125;int get(int u) &#123; return anc[u] == u ? u : anc[u] = get(anc[u]);&#125;void DFS(int u, int pre) &#123; dep[u] = dep[pre] + 1; fa[u][0] = pre; top[u][0] = ++total; bot[u][0] = ++total; for (int i = 1; (1 &lt;&lt; i) &lt;= dep[u]; ++i) &#123; fa[u][i] = fa[fa[u][i - 1]][i - 1]; top[u][i] = ++total; bot[u][i] = ++total; connect(top[u][i - 1], top[u][i], 0); connect(top[fa[u][i - 1]][i - 1], top[u][i], 0); connect(bot[u][i], bot[u][i - 1], 0); connect(bot[u][i], bot[fa[u][i - 1]][i - 1], 0); &#125; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to; if (v == pre) continue; DFS(v, u); &#125;&#125;void dijkstra() &#123; memset(dis, 0x3f, sizeof(dis)); dis[s] = 0; priority_queue&lt;node&gt; q; q.push(s); while (!q.empty()) &#123; int u = q.top().u; q.pop(); if (visit[u]) continue; visit[u] = true; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to, w = edge[i].cost; if (!visit[v] &amp;&amp; dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; q.push(node(v, dis[v])); &#125; &#125; &#125;&#125;void construct(int u, int v, int c, int opt) &#123; if (!opt) connect(u, v, c); else connect(v, u, c);&#125;int get(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); for (int i = 16; i &gt;= 0; --i) if (dep[fa[u][i]] &gt;= dep[v]) u = fa[u][i]; if (u == v) return u; for (int i = 16; i &gt;= 0; --i) if (fa[u][i] != fa[v][i]) &#123; u = fa[u][i]; v = fa[v][i]; &#125; return fa[u][0];&#125;int jump(int u, int k) &#123; int i = 0; while (k) &#123; if (k &amp; 1) u = fa[u][i]; ++i; k &gt;&gt;= 1; &#125; return u;&#125;void add(int u, int v, int w, int c, int opt) &#123; if (u == v) &#123; construct(u, w, c, opt); return ; &#125; int s = dep[u] - dep[v]; int i; for (i = 0; (2 &lt;&lt; i) &lt;= s; ++i); construct(!opt ? top[u][i] : bot[u][i], w, c, opt); u = jump(u, s - (1 &lt;&lt; i)); construct(!opt ? top[u][i] : bot[u][i], w, c, opt); &#125;void print(int x) &#123; if (x &lt; 0) &#123; putchar('-'); print(-x); return ; &#125; if(x &gt; 9) print(x / 10); putchar(x % 10 + '0');&#125;int main() &#123; n = read(); m = read(); s = read(); for (int i = 1; i &lt;= n; ++i) anc[i] = i; for (int i = 1; i &lt;= m; ++i) &#123; int type = read(); if (type == 1) &#123; int u1 = read(), v1 = read(), u2 = read(), v2 = read(), w = read(); if (get(u1) == get(v1) &amp;&amp; get(u2) == get(v2)) a[++amount] = opt(u1, v1, u2, v2, w); &#125; else &#123; int u = read(), v = read(), w = read(); if (get(u) == get(v)) continue; anc[get(u)] = get(v); connect(u, v, w); connect(v, u, w); &#125; &#125; total = n; for (int i = 1; i &lt;= n; ++i) if (!dep[i]) DFS(i, 0); for (int u = 1; u &lt;= n; ++u) &#123; if (fa[u][0]) &#123; connect(fa[u][0], top[u][0], 0); connect(bot[u][0], fa[u][0], 0); &#125; connect(u, top[u][0], 0); connect(bot[u][0], u, 0); &#125; for (int i = 1; i &lt;= amount; ++i) &#123; int p = ++total, w1 = get(a[i].u1, a[i].v1), w2 = get(a[i].u2, a[i].v2); add(a[i].u1, w1, p, a[i].w, 0); add(a[i].v1, w1, p, a[i].w, 0); add(a[i].u2, w2, p, 0, 1); add(a[i].v2, w2, p, 0, 1); &#125; dijkstra(); for (int i = 1; i &lt;= n; ++i) &#123; print(dis[i] == INF ? -1 : dis[i]); putchar(' '); &#125;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>优化建图</category>
        <category>倍增</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>优化建图</tag>
        <tag>soluion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 3588 - [POI2015]PUS]]></title>
    <url>%2F2019%2F05%2FLuogu-3588-POI2015-PUS%2F</url>
    <content type="text"><![CDATA[对于这一类有相互限制关系的，显然需要用到差分约束。 同时，建图过程中会发现有几个点要向某几个区间相连，倘若掌握了线段树优化建图这样一种套路，就不难想出解法：建立一棵线段树，把某几个区间对应的至多 $\log n$ 个节点与那些点相连。 但是这样是 $O(\sum k_i^2\log n)$ 。倘若将区间与一个新增的虚点相连，再将点与虚点相连，可将复杂度优化到：$O(k\log n)$ 。 其他部分便是简单的 尝试用了拓扑实现差分约束。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAXN 100005#define ls x &lt;&lt; 1#define rs x &lt;&lt; 1 | 1using namespace std;;int n, s, m;int a[MAXN &lt;&lt; 3], total;int d[MAXN &lt;&lt; 3];int head[MAXN &lt;&lt; 3], cnt;int deg[MAXN &lt;&lt; 2];int pos[MAXN];struct segment &#123; int l, r, v;&#125;t[MAXN &lt;&lt; 2];struct data &#123; int next, to, cost; data(int next = 0, int to = 0, int cost = 0):next(next), to(to), cost(cost) &#123;&#125;&#125;edge[MAXN &lt;&lt; 5];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void connect(int u, int v, int w) &#123; edge[++cnt] = data(head[u], v, w); head[u] = cnt; ++deg[v];&#125;void build(int l, int r, int x = 1) &#123; total = max(total, x); t[x].l = l; t[x].r = r; if (l == r) &#123; pos[l] = x; return ; &#125; int mid = (l + r) &gt;&gt; 1; build(l, mid, ls); build(mid + 1, r, rs); connect(ls, x, 0); connect(rs, x, 0);&#125;void construct(int u, int l, int r, int x = 1) &#123; if (l &lt;= t[x].l &amp;&amp; t[x].r &lt;= r) &#123; connect(x, u, 0); return ; &#125; int mid = (t[x].l + t[x].r) &gt;&gt; 1; if (l &lt;= mid) construct(u, l, r, ls); if (r &gt; mid) construct(u, l, r, rs);&#125;void topsort() &#123; queue&lt;int&gt; q; for (int i = 1; i &lt;= total; ++i) if (!deg[i]) &#123; q.push(i); d[i] = max(d[i], 1); &#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to, w = edge[i].cost; d[v] = max(d[v], d[u] + w); if (--deg[v] == 0) q.push(v); &#125; &#125;&#125;int main() &#123; n = read(); s = read(); m = read(); build(1, n); for (int i = 1; i &lt;= s; ++i) &#123; int p = read(), v = read(); a[pos[p]] = d[pos[p]] = v; &#125; for (int i = 1; i &lt;= m; ++i) &#123; int l = read(), r = read(), k = read(), last = l; ++total; for (int j = 1; j &lt;= k; ++j) &#123; int cur = read(); if (last &lt; cur) construct(total, last, cur - 1); last = cur + 1; connect(total, pos[cur], 1); &#125; if (last &lt;= r) construct(total, last, r); &#125; topsort(); for (int i = 1; i &lt;= n; ++i) if (d[pos[i]] &gt; (int)1e9 || (a[pos[i]] &amp;&amp; a[pos[i]] != d[pos[i]])) &#123; puts("NIE"); return 0; &#125; puts("TAK"); for (int i = 1; i &lt;= n; ++i) printf("%d ", d[pos[i]]);&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>优化建图</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>线段树</tag>
        <tag>优化建图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 5284 - [十二省联考2019]字符串问题]]></title>
    <url>%2F2019%2F05%2FLuogu-5284-%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%832019-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[若 $A$ 支配 $B$ ，作 $A \rightarrow B$ ，记为类型 $1$ ；$B$ 又是 $A$ 的前缀，作 $B \rightarrow A$ ，记为类型 $2$ 。 其实至此已然有些眉目了，按照套路应该是可以建成一个 $\operatorname{DAG}$ 然后做一个 $\operatorname{DP}$ 的。 类型 $1$ 的边总数只有 $n$ 条，不需要优化，问题在于类型 $2$ 。 考虑后缀自动机，那么假设定位到 $B$ 所在后缀自动机上的位置，那么其在 $\operatorname{parent}$ 的子树必然都是 $A$ 的可行存在区间。 到这一步我就懵逼了，有一个很神奇的优化建图的方法： 将一个后缀自动机节点代表的所有 $A, B$ 列出，以 $\operatorname{len}$ 为第一关键字，种类为第二关键字，即先 $B$ 后 $A$ ，从大到小排序； 将 $B$ 类依次相连，$A$ 类与最近的 $B$ 类相连，以减少边的总数；第一个与当前后缀自动机节点相连，最后一个与 $\operatorname{parent}$ 树上的儿子代表的后缀自动机节点相连； 不难证明这样一定涵盖了所有的情况，且总规模 $O(n)$ 。 这其实是一种思想，将毫无关联的状态合并，以合适的方式遍历，减少状态总数。 换而言之，既然他们最后都要向某一个点相连，且经过他们相互没有影响，为何要如花项链而徒增复杂度？不如找到共性，以一条边代替所有边。 好像有一个通法：把那些都要连到某一个点的串起来，在末端与其相连，当然前提是不互相影响。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#define MAXN 200005typedef long long lint;using namespace std;int t, n, m, z, l;char s[MAXN];int ch[MAXN &lt;&lt; 1][27], fa[MAXN &lt;&lt; 1], len[MAXN &lt;&lt; 1], anc[MAXN &lt;&lt; 1][19], total, root, last;int used[MAXN &lt;&lt; 2];int head[MAXN &lt;&lt; 2], cnt, deg[MAXN &lt;&lt; 2];lint f[MAXN &lt;&lt; 2];int val[MAXN &lt;&lt; 2];int pos[MAXN &lt;&lt; 2];struct node &#123; int u, l, t; node(int u = 0, int l = 0, int t = 0):u(u), l(l), t(t) &#123;&#125; bool operator &lt; (const node a) const &#123; return l &gt; a.l || (l == a.l &amp;&amp; t &lt; a.t); &#125;&#125;;vector&lt;node&gt; g[MAXN &lt;&lt; 2];struct data &#123; int next, to; data(int next = 0, int to = 0):next(next), to(to) &#123;&#125;&#125;edge[MAXN &lt;&lt; 3];void connect(int u, int v) &#123; edge[++cnt] = data(head[u], v); head[u] = cnt; ++deg[v];&#125;struct sub &#123; int l, r, p, id; sub(int l = 0, int r = 0, int p = 0, int id = 0):l(l), r(r), p(p), id(id) &#123;&#125;&#125;a[MAXN], b[MAXN];void rev(char* s, int l) &#123; for (int i = 1; i &lt;= (l &gt;&gt; 1); ++i) swap(s[i], s[l - i + 1]);&#125;void append(int c) &#123; int u = ++total, v = last; len[u] = len[v] + 1; last = u; while (v &amp;&amp; !ch[v][c]) &#123; ch[v][c] = u; v = fa[v]; &#125; if (!v) &#123; fa[u] = root; return ; &#125; int a = ch[v][c], b = ++total; if (len[a] == len[v] + 1) &#123; --total; fa[u] = a; return ; &#125; memcpy(ch[b], ch[a], sizeof(ch[a])); fa[b] = fa[a]; fa[a] = fa[u] = b; len[b] = len[v] + 1; while (v &amp;&amp; ch[v][c] == a) &#123; ch[v][c] = b; v = fa[v]; &#125; return ;&#125;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void init() &#123; memset(ch, 0, sizeof(ch)); memset(fa, 0, sizeof(fa)); memset(len, 0, sizeof(len)); memset(head, 0, sizeof(head)); memset(val, 0, sizeof(val)); memset(f, 0, sizeof(f)); memset(deg, 0, sizeof(deg)); for (int i = 0; i &lt;= total; ++i) g[i].clear(); total = root = last = 1; cnt = 0;&#125;void build() &#123; for (int i = 1; i &lt;= total; ++i) anc[i][0] = fa[i]; for (int j = 1; j &lt;= 18; ++j) for (int i = 1; i &lt;= total; ++i) anc[i][j] = anc[anc[i][j - 1]][j - 1];&#125;int get(int l, int r) &#123; int u = pos[r]; for (int i = 18; i &gt;= 0; --i) if (len[anc[u][i]] &gt;= r - l + 1) u = anc[u][i]; return u;&#125;lint topsort() &#123; lint ans = 0; queue&lt;int&gt; q; for (int i = 1; i &lt;= total; ++i) if (!deg[i]) q.push(i); while (!q.empty()) &#123; int u = q.front(); q.pop(); ans = max(ans, f[u] + val[u]); for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to; if (--deg[v] == 0) q.push(v); f[v] = max(f[v], f[u] + val[u]); &#125; &#125; for (int i = 1; i &lt;= total; ++i) if (deg[i]) return -1; return ans;&#125;int main() &#123; t = read(); while (t--) &#123; init(); scanf("%s", s + 1); l = (int)strlen(s + 1); rev(s, l); for (int i = 1; i &lt;= l; ++i) &#123; append(s[i] - 'a' + 1); pos[i] = last; &#125; build(); n = read(); int origin = total; for (int i = 1; i &lt;= n; ++i) &#123; a[i].r = l - read() + 1; a[i].l = l - read() + 1; val[a[i].id = ++total] = a[i].r - a[i].l + 1; g[get(a[i].l, a[i].r)].push_back(node(a[i].id, a[i].r - a[i].l + 1, 0)); &#125; m = read(); for (int i = 1; i &lt;= m; ++i) &#123; b[i].r = l - read() + 1; b[i].l = l - read() + 1; b[i].id = ++total; g[get(b[i].l, b[i].r)].push_back(node(b[i].id, b[i].r - b[i].l + 1, 1)); &#125; for (int i = 1; i &lt;= origin; ++i) &#123; int last = i; sort(g[i].begin(), g[i].end()); for (int j = (int)g[i].size() - 1; j &gt;= 0; --j) &#123; node v = g[i][j]; connect(last, v.u); if (v.t) last = v.u; &#125; used[i] = last; &#125; for (int i = 2; i &lt;= origin; ++i) connect(used[fa[i]], i); z = read(); for (int i = 1; i &lt;= z; ++i) &#123; int u = read(), v = read(); connect(a[u].id, b[v].id); &#125; lint ans = topsort(); printf("%lld\n", ans); &#125;&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>后缀自动机</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>倍增</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 5283 - [十二省联考2019]异或粽子]]></title>
    <url>%2F2019%2F05%2FLuogu-5283-%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%832019-%E5%BC%82%E6%88%96%E7%B2%BD%E5%AD%90%2F</url>
    <content type="text"><![CDATA[几乎就跟 BZOJ3689 - 异或之 一模一样，仅仅只是多了一个前缀异或和，也极好想，所谓原题？ 首先将 $a_i \oplus a_{i + 1} \oplus \cdots \oplus a_j$ 转化成：$b_j \oplus b_{i - 1}$ ，即作异或前缀和，这样就可以在一段区间中查询一个与 $b_{i - 1}$ 异或的最大值，计其位置为 $k$ 。 对于一段区间 $[i, j]$ ，在确定左端点的情况下，显然可以在 $[i, n]$ 这一段区间中找到最大值的位置，若其产生贡献，就分为两个区间继续查询：$[i, p - 1]$ 和 $[p + 1, j]$ ，不难证明一共只会产生 $n + k$ 个区间进入计算，复杂度 $O(k\log (n + k))$ 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 1000005#define MAXD 33typedef long long lint;using namespace std;const int D = 32;int n, k;lint a[MAXN];int root[MAXN], ch[MAXN * MAXD][2], pos[MAXN * MAXD], size[MAXN * MAXD], total;struct node &#123; int i, l, r, p; lint v; node(int i = 0, int l = 0, int r = 0, int p = 0, lint v = 0):i(i), l(l), r(r), p(p), v(v) &#123;&#125; bool operator &lt; (const node b) const &#123; return v &lt; b.v; &#125;&#125;;priority_queue&lt;node&gt; q;lint read() &#123; char c = getchar(); lint x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;int append(lint x, int v, int id) &#123; int u = ++total, r = u; for (int i = D; i &gt;= 0; --i) &#123; int c = x &gt;&gt; i &amp; 1; ch[u][c] = ++total; ch[u][c ^ 1] = ch[v][c ^ 1]; u = ch[u][c]; v = ch[v][c]; size[u] = size[v] + 1; &#125; pos[u] = id; return r;&#125;int query(int u, int v, lint w) &#123; for (int i = D; i &gt;= 0; --i) &#123; int c = w &gt;&gt; i &amp; 1; if (size[ch[v][c ^ 1]] - size[ch[u][c ^ 1]]) &#123; u = ch[u][c ^ 1]; v = ch[v][c ^ 1]; &#125; else &#123; u = ch[u][c]; v = ch[v][c]; &#125; &#125; return pos[v];&#125;int main() &#123; n = read(); k = read(); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = read(); a[i] = a[i] ^ a[i - 1]; root[i] = append(a[i], root[i - 1], i); &#125; for (int i = 1; i &lt;= n; ++i) &#123; int p = query(root[i - 1], root[n], a[i - 1]); q.push(node(i, i, n, p, a[i - 1] ^ a[p])); &#125; lint res = 0; while (k--) &#123; node u = q.top(); q.pop(); res = res + u.v; if (u.p != u.l) &#123; int p = query(root[u.l - 1], root[u.p - 1], a[u.i - 1]); q.push(node(u.i, u.l, u.p - 1, p, a[u.i - 1] ^ a[p])); &#125; if (u.p != u.r) &#123; int p = query(root[u.p], root[u.r], a[u.i - 1]); q.push(node(u.i, u.p + 1, u.r, p, a[u.i - 1] ^ a[p])); &#125; &#125; printf("%lld\n", res);&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>可持久化</category>
        <category>01Trie</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>可持久化</tag>
        <tag>01Trie</tag>
        <tag>异或</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1139C - Edgy Trees]]></title>
    <url>%2F2019%2F05%2FCodeforces-1139C-Edgy-Trees%2F</url>
    <content type="text"><![CDATA[依旧很难思考出计数题，但是这次稍微有一些眉目？做一些记录试图激发出对于这一类题共性的思考。 首先对于这一类题一般都有一个限制，对于这一题来说就是必须经过黑色边了。 接着根据这个限制继续思考，将限制作为研究对象，以它为核心思考问题，该题便可以根据黑边，将树划分成两个部分，分别在两个区域中共选 $k$ 个点，要求每一个区域至少选一个点。 同时一般还会牵涉到一些容斥：像每一个区域至少选一个点，就可以从所有中选出 $k$ 个点，减去只在左半部分就选完 $k$ 个点的情况数以及只在右半部分就选完 $k$ 个点的情况数。 也会有相互牵涉到的情况：有时候是容斥，有时候是改变计算顺序，这里是后者。 考虑用并查集合并，一定不会重复。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 100005typedef long long lint;const int mod = 1e9 + 7;int n, k, m;int fa[MAXN], size[MAXN];struct data &#123; int u, v; data(int u = 0, int v = 0):u(u), v(v) &#123;&#125;&#125;edge[MAXN];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;int get(int u) &#123; return u == fa[u] ? u : fa[u] = get(fa[u]);&#125;lint power(lint a, int b) &#123; lint res = 1; while (b) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;int main() &#123; n = read(); k = read(); for (int i = 1; i &lt;= n; ++i) &#123; fa[i] = i; size[i] = 1; &#125; for (int i = 1; i &lt; n; ++i) &#123; int u = read(), v = read(), t = read(); if (!t) &#123; size[get(v)] += size[get(u)]; fa[get(u)] = get(v); &#125; else edge[++m] = data(u, v); &#125; lint ans = 0; for (int i = 1; i &lt;= m; ++i) &#123; int u = edge[i].u, v = edge[i].v; ans = ((ans - power(size[get(u)], k) - power(size[get(v)], k)) % mod + mod) % mod; size[get(v)] += size[get(u)]; fa[get(u)] = get(v); ans = (ans + power(size[get(v)], k)) % mod; &#125; printf("%lld\n", ans);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>组合数学</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 3296 - [SDOI2013]刺客信条]]></title>
    <url>%2F2019%2F05%2FLuogu-3296-SDOI2013-%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[显然需要运用到树同构的知识判断树的同构，同时两棵不同的子树也会产生树同构的情况，这也就是说，这牵涉到一个最小权匹配的问题 ： 不难想出 $\operatorname{DP}$ 方程：$f_{u, v}$ 表示 $u$ 子树和 $v$ 子树所匹配的最小值，当然前提是他们同构。 那么对于 $f_{u, v}$ ，便可以从他们的子树相互两两匹配的最小权值转移而来。 一个坑点：树同构是需要用重心进行计算的：若重心只有一个，则保证同构；但对于重心存在两个的情况，不难证明两个中心一定相连，需要建立一个虚点与两个重心相连，作为该树新的重心。 絮叨这么多，其实就是关于树的重心的一个重要性质： 如果有两棵树，强制以重心为根，那么这两棵树同构当且仅当形成的两棵有根树同构。 值得一提的是：这题虽然看上去很好写，实际上确实很好写，只是码量大罢了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;typedef long long lint;#define MAXN 1010#define MAXM 100005#define INF 0x3f3f3f3fusing namespace std;int n, m;int color1[MAXN], color2[MAXN];int head[MAXN &lt;&lt; 1], cnt = 1;int size[MAXN], root, root2, maxi[MAXN], fa[MAXN];int dis[MAXN &lt;&lt; 1], pre[MAXN &lt;&lt; 1], inf[MAXN &lt;&lt; 1], S, T;vector&lt;int&gt; g[MAXN], origin[MAXN];bool inq[MAXN &lt;&lt; 1];int f[MAXN][MAXN];struct data &#123; int next, to, flow, cost; data(int next = 0, int to = 0, int flow = 0, int cost = 0):next(next), to(to), flow(flow), cost(cost) &#123;&#125;&#125;edge[MAXM &lt;&lt; 1];void connect(int u, int v, int f, int c) &#123; edge[++cnt] = data(head[u], v, f, c); head[u] = cnt; edge[++cnt] = data(head[v], u, 0, -c); head[v] = cnt;&#125;void init() &#123; memset(head, 0, sizeof(head)); cnt = 1;&#125;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void getroot(int u, int pre) &#123; size[u] = 1; for (int i = 0; i &lt; (int)g[u].size(); ++i) &#123; int v = g[u][i]; if (v == pre) continue; getroot(v, u); size[u] = size[u] + size[v]; maxi[u] = max(maxi[u], size[v]); &#125; maxi[u] = max(maxi[u], n - size[u]); if (maxi[u] &lt; maxi[root]) &#123; root = u; root2 = 0; &#125; else if (maxi[u] == maxi[root]) root2 = u;&#125;void DFS(int u, int pre) &#123; size[u] = 1; fa[u] = pre; for (int i = 0; i &lt; (int)g[u].size(); ++i) &#123; int v = g[u][i]; if (v == pre) continue; DFS(v, u); size[u] = size[u] + size[v]; &#125;&#125;lint calc(int u, int pre) &#123; vector&lt;lint&gt; p; for (int i = 0; i &lt; (int)g[u].size(); ++i) &#123; int v = g[u][i]; if (v == pre) continue; p.push_back(calc(v, u)); &#125; sort(p.begin(), p.end()); lint val = 0; for (int i = 0; i &lt; (int)p.size(); ++i) val = val * 13331 + p[i]; return val * 13331 + 1;&#125;bool SPFA() &#123; queue&lt;int&gt; q; q.push(S); memset(dis, 0x3f, sizeof(dis)); dis[S] = 0; inf[S] = INF; while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = false; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to, w = edge[i].cost, f = edge[i].flow; if (dis[v] &gt; dis[u] + w &amp;&amp; f) &#123; dis[v] = dis[u] + w; pre[v] = i; inf[v] = min(inf[u], f); if (!inq[v]) &#123; q.push(v); inq[v] = true; &#125; &#125; &#125; &#125; return dis[T] != INF;&#125;int build(int p, int q) &#123; init(); int sum = 0; for (int i = 0; i &lt; (int)g[p].size(); ++i) &#123; int u = g[p][i]; if (u == fa[p]) continue; ++sum; for (int j = 0; j &lt; (int)g[q].size(); ++j) &#123; int v = g[q][j]; if (v == fa[q]) continue; connect(u, v + n, 1, f[u][v]); &#125; &#125; S = (n &lt;&lt; 1) + 1; T = (n &lt;&lt; 1) + 2; for (int i = 0; i &lt; (int)g[p].size(); ++i) &#123; int v = g[p][i]; if (v == fa[p]) continue; connect(S, v, 1, 0); &#125; for (int i = 0; i &lt; (int)g[q].size(); ++i) &#123; int v = g[q][i]; if (v == fa[q]) continue; connect(v + n, T, 1, 0); &#125; return sum;&#125;int match(int u, int v) &#123; int sum = build(u, v); int flow = 0, cost = 0; while (SPFA()) &#123; int f = inf[T], u = T; flow = flow + f; cost = cost + f * dis[T]; while (u != S) &#123; int i = pre[u]; edge[i ^ 1].flow += f; edge[i].flow -= f; u = edge[i ^ 1].to; &#125; &#125; return flow == sum ? cost : INF;&#125;int DP(int p, int q) &#123; if (size[p] == 1) return f[p][q] = color1[p] != color2[q]; for (int i = 0; i &lt; (int)g[p].size(); ++i) &#123; int u = g[p][i]; if (u == fa[p]) continue; lint signu = calc(u, fa[u]); for (int j = 0; j &lt; (int)g[q].size(); ++j) &#123; int v = g[q][j]; if (v == fa[q]) continue; if (f[u][v] != -1) continue; lint signv = calc(v, fa[v]); if (signu == signv) DP(u, v); else f[u][v] = INF; &#125; &#125; f[p][q] = match(p, q) + (color1[p] != color2[q]); return f[p][q];&#125;int main() &#123; n = read(); for (int i = 1; i &lt; n; ++i) &#123; int u = read(), v = read(); g[u].push_back(v); g[v].push_back(u); &#125; for (int i = 1; i &lt;= n; ++i) color1[i] = read(); for (int i = 1; i &lt;= n; ++i) color2[i] = read(); maxi[root] = INF; getroot(1, 0); if (root &amp;&amp; root2) &#123; for (int i = 1; i &lt;= n; ++i) &#123; origin[i] = g[i]; g[i].clear(); &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt; (int)origin[i].size(); ++j) &#123; if ((i == root &amp;&amp; origin[i][j] == root2) || (i == root2 &amp;&amp; origin[i][j] == root)) continue; g[i].push_back(origin[i][j]); &#125; ++n; g[root].push_back(n); g[root2].push_back(n); g[n].push_back(root); g[n].push_back(root2); root = n; &#125; DFS(root, 0); memset(f, -1, sizeof(f)); DP(root, root); printf("%d\n", f[root][root]);&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>树形DP</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>树形DP</tag>
        <tag>哈希</tag>
        <tag>最小费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LOJ 2340 -「WC2018」州区划分]]></title>
    <url>%2F2019%2F04%2FLOJ-2340-%E3%80%8CWC2018%E3%80%8D%E5%B7%9E%E5%8C%BA%E5%88%92%E5%88%86%2F</url>
    <content type="text"><![CDATA[说来惭愧，最近几道 $\operatorname{FWT}$ 题都是卡常没卡过，迫于无奈换 $\operatorname{OJ}$ 交才通过的。 这题几乎接近于模版题了：将一个集合划分成若干个集合，给定一个价值的计算方式，求所有可能方式的价值和。 那么很显然对于当前一个全集 $S$ ， $a$ 是其子集，$b$ 是其补集，答案就是所有可能情况的和。 换而言之： f_i = \frac{1}{g_i}\sum \limits_{j \subsetneq i} f_jg_{i \oplus j}$g_i$ 表示集合 $i$ 的价值和，如果非法为 $0$ 。需要注意的是，前面的 $g_i$ 并不受非法条件限制，直接设为为其价值和即可。 然后 $\operatorname{FMT}$ 优化子集 $\operatorname{DP}$ 即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#define MAXN 22#define MAXM 255using namespace std;const int mod = 998244353;int n, m, p;int w[MAXN], sum[1 &lt;&lt; MAXN], inv[1 &lt;&lt; MAXN];int deg[MAXN], fa[MAXN];int f[MAXN][1 &lt;&lt; MAXN], g[MAXN][1 &lt;&lt; MAXN];int size[1 &lt;&lt; MAXN];bool isedge[MAXN][MAXN];bool islegal[1 &lt;&lt; MAXN];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;int get(int u) &#123; return u == fa[u] ? u : fa[u] = get(fa[u]);&#125;int power(int a, int b) &#123; int res = 1; while (b) &#123; if (b &amp; 1) res = 1ll * res * a % mod; a = 1ll * a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;void init() &#123; int limit = (1 &lt;&lt; n) - 1; for (int i = 1; i &lt;= limit; ++i) &#123; bool enable = false; for (int j = 1; j &lt;= n; ++j) &#123; deg[j] = 0; fa[j] = j; &#125; for (int u = 1; u &lt;= n; ++u) if (i &gt;&gt; (u - 1) &amp; 1) for (int v = u + 1; v &lt;= n; ++v) if ((i &gt;&gt; (v - 1) &amp; 1) &amp;&amp; isedge[u][v]) &#123; ++deg[v]; ++deg[u]; fa[get(v)] = get(u); &#125; int root = 0, amount = 0; for (int j = 1; j &lt;= n; ++j) if (i &gt;&gt; (j - 1) &amp; 1) &#123; amount += w[j]; if (!root) root = get(j); if ((deg[j] &amp; 1) || root != get(j)) enable = true; &#125; sum[i] = enable * power(amount, p); inv[i] = power(power(amount, p), mod - 2); &#125;&#125;void FMT(int* a, int l, int opt) &#123; for (int i = 1; i &lt;= l; i &lt;&lt;= 1) for (int j = 0; j &lt;= l; ++j) if (j &amp; i) &#123; if (opt == 1) a[j] = (a[j] + a[j ^ i]) % mod; else a[j] = (a[j] - a[j ^ i] + mod) % mod; &#125;&#125;int main() &#123; n = read(); m = read(); p = read(); for (int i = 1; i &lt;= m; ++i) &#123; int u = read(), v = read(); isedge[u][v] = isedge[v][u] = true; &#125; for (int i = 1; i &lt;= n; ++i) w[i] = read(); init(); int limit = (1 &lt;&lt; n) - 1; for (int i = 1; i &lt;= limit; ++i) size[i] = size[i &gt;&gt; 1] + (i &amp; 1); for (int i = 1; i &lt;= limit; ++i) g[size[i]][i] = sum[i]; for (int i = 0; i &lt;= n; ++i) FMT(g[i], limit, 1); f[0][0] = 1; FMT(f[0], limit, 1); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt; i; ++j) for (int s = 0; s &lt;= limit; ++s) f[i][s] = (1ll * g[i - j][s] * f[j][s] % mod + f[i][s]) % mod; FMT(f[i], limit, -1); for (int j = 1; j &lt;= limit; ++j) if (size[j] == i) f[i][j] = 1ll * f[i][j] * inv[j] % mod; else f[i][j] = 0; FMT(f[i], limit, 1); &#125; FMT(f[n], limit, -1); printf("%d\n", f[n][limit]);&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>子集DP</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>子集DP</tag>
        <tag>FMT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 5019 - [SNOI2017]遗失的答案]]></title>
    <url>%2F2019%2F04%2FBZOJ-5019-SNOI2017-%E9%81%97%E5%A4%B1%E7%9A%84%E7%AD%94%E6%A1%88%2F</url>
    <content type="text"><![CDATA[首先无解情况是非常好判掉的，接着就可以将所有数除以 $g$ ，毕竟其他数都没有意义。 不难发现最多只会由 $8$ 个质数组成，并且符合条件的数构成的合法集合大小并不大，考虑对他们进行 $\operatorname{DP}$ 。 可以开一个 $16$ 的状态，分别表示某一个质数的次幂是否达到最大值/最小值，普通状压 $\operatorname{DP}$ 转移即可，此处我们将状态看成集合，为满足到达最大值/最小值的位置的集合。 考虑到题目有要求必须选某数，当然他必须在合法集合中， $\operatorname{DP}$ 时从左到右一遍，再从右往左一遍，然后在必选位置合并。 此处合并大有讲究： 需要找到一个集合 $p$ ，使得并上必选数的集合 $q$ 为全集 $s$ 。不难发现必然为 $s \oplus q$ 的超集此处可以用 $\operatorname{FWT}$ 求超集和。 合并的时候是集合并卷积，利用 $\operatorname{FWT}$ 优化使复杂度正确。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;map&gt;#define MAXP 100005#define MAXN 1000005#define MAXS 600typedef long long lint;using namespace std;const int mod = 1e9 + 7;int n, g, l, q;int v[MAXP], prime[MAXP], total;int p[MAXN], c[MAXN], amount;int appear[MAXN], state[MAXN], quanity;int times[MAXN], pre[MAXS][1 &lt;&lt; 16], suf[MAXS][1 &lt;&lt; 16], f[MAXS][1 &lt;&lt; 16];bool enable = true;map&lt;int, int&gt; record;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;lint power(lint a, int b) &#123; lint res = 1; while (b) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;void shieve(int n) &#123; for (int i = 2; i &lt;= n; ++i) &#123; if (!v[i]) prime[++total] = i; for (int j = 1; j &lt;= total &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; v[i * prime[j]] = true; if (i % prime[j] == 0) break; &#125; &#125;&#125;void init(int n) &#123; for (int i = 1; i &lt;= total; ++i) if (n % prime[i] == 0) &#123; p[++amount] = prime[i]; while (n % prime[i] == 0) &#123; n /= prime[i]; ++c[amount]; &#125; &#125;&#125;void DFS(int d, int v, int s, int t) &#123; if (d &gt; amount) &#123; ++appear[s &lt;&lt; amount | t]; return ; &#125; DFS(d + 1, v, s | (1 &lt;&lt; (d - 1)), t); for (int i = 1; i &lt;= c[d]; ++i) &#123; v = v * p[d]; if (v &gt; n) return ; if (i == c[d]) DFS(d + 1, v, s, t | (1 &lt;&lt; (d - 1))); else DFS(d + 1, v, s, t); &#125;&#125;void FWTOR(int* a, int n, int opt) &#123; for (int i = 1; i &lt; n; i &lt;&lt;= 1) for (int j = 0; j &lt; n; j += (i &lt;&lt; 1)) for (int k = 0; k &lt; i; ++k) &#123; ;int x = a[j + k], y = a[j + k + i]; if (opt == 1) a[j + k + i] = (x + y) % mod; else a[j + k + i] = (y - x + mod) % mod; &#125;&#125;void FWTAND(int* a, int n, int opt) &#123; for (int i = 1; i &lt; n; i &lt;&lt;= 1) for (int j = 0; j &lt; n; j += (i &lt;&lt; 1)) for (int k = 0; k &lt; i; ++k) &#123; int x = a[j + k], y = a[j + k + i]; if (opt == 1) a[j + k] = (x + y) % mod; else a[j + k] = (x - y + mod) % mod; &#125;&#125;int get(int n) &#123; int x = 1; while (x &lt;= n) x &lt;&lt;= 1; return x;&#125;int divide(int n) &#123; int s = 0; for (int i = 1; i &lt;= amount; ++i) &#123; int sum = 0; while (n % p[i] == 0) &#123; ++sum; n /= p[i]; &#125; if (!sum) s = s | (1 &lt;&lt; (i - 1 + amount)); else if (sum == c[i]) s = s | (1 &lt;&lt; (i - 1)); &#125; return s;&#125;void solve() &#123; int limit = (1 &lt;&lt; (amount &lt;&lt; 1)) - 1; pre[0][0] = 1; for (int i = 1; i &lt;= quanity; ++i) &#123; for (int j = 0; j &lt;= limit; ++j) &#123; pre[i][j] = (pre[i][j] + pre[i - 1][j]) % mod; pre[i][j | state[i]] = (1ll * pre[i - 1][j] * times[i] % mod + pre[i][j | state[i]]) % mod; &#125; &#125; suf[quanity + 1][0] = 1; for (int i = quanity; i &gt;= 1; --i) &#123; for (int j = 0; j &lt;= limit; ++j) &#123; suf[i][j] = (suf[i][j] + suf[i + 1][j]) % mod; suf[i][j | state[i]] = (1ll * suf[i + 1][j] * times[i] % mod + suf[i][j | state[i]]) % mod; &#125; &#125; int m = get(limit); for (int i = 0; i &lt;= quanity + 1; ++i) &#123; FWTOR(pre[i], m, 1); FWTOR(suf[i], m, 1); &#125; for (int i = 1; i &lt;= quanity; ++i) &#123; for (int j = 0; j &lt; m; ++j) f[i][j] = 1ll * pre[i - 1][j] * suf[i + 1][j] % mod; FWTOR(f[i], m, -1); FWTAND(f[i], m, 1); &#125;&#125;int main() &#123; n = read(); g = read(); l = read(); if (l % g) enable = false; l /= g; n /= g; shieve(10000); init(l); DFS(1, 1, 0, 0); int limit = (1 &lt;&lt; (amount &lt;&lt; 1)) - 1; for (int i = 0; i &lt;= limit; ++i) if (appear[i]) &#123; state[++quanity] = i; record[i] = quanity; times[quanity] = int(power(2, appear[i]) - 1); &#125; solve(); q = read(); lint inv2 = power(2, mod - 2); while (q--) &#123; int x = read(); if (x % g) &#123; puts("0"); continue; &#125; x /= g; if (l % x || x &gt; n || !enable) &#123; puts("0"); continue; &#125; int s = divide(x), p = record[s]; printf("%lld\n", 1ll * f[p][limit ^ s] * (times[p] + 1) % mod * inv2 % mod); &#125;&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>子集DP</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>子集DP</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器配置]]></title>
    <url>%2F2019%2F04%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[对于一个小白，服务器着实是不是非常好配置，在网上找到了一些博客进行了学习，稍作总结以备不时之需。 准备需要一台云服务器。 我使用的是CentOS 7.6 64位 ，本文介绍如何以该系统进行配置。 搭建git 仓库与发布在 github 上相似，是需要一个仓库可供我们 deploy 的，这样在写完文章后就可以直接 pull 上去。 首先先创建一个新用户： 12adduser gitpasswd git //输入密码 然后需要赋予 git sudo 权限： 12chmod 740 /etc/sudoersvim /etc/sudoers 找到： 1root ALL=(ALL) ALL 在下面加上： 1git ALL=(ALL) ALL 修改回原来的权限： 1chmod 440 /etc/sudoers 接着用 git 建立 git 仓库： 12345su gitcd /home/gitmkdir blog.gitcd blog.gitgit init --bare 同时也要创建网站的根目录： 1234cd /var/sudo mkdir wwwcd /var/www/sudo mkdir blog ssh为了每次 deploy 不需要输入密码，设置免密登陆： 1234cd /home/gitmkdir .sscd .sshsudo vim authorized_keys 将本地公钥复制进入即可，应于：~/.ssh/id_rsa.pub。 然后修改权限： 123456sudo chown git:git -R /var/www/blogsudo chown git:git -R /home/git/blog.gitsudo chown git:git -R ~/.sshsudo chown git:git -R ~/.ssh/authorized_keyschmod 700 ~/.sshchmod 600 ~/.ssh/authorized_keys nginx12345sudo yum install -y nginxsudo systemctl start nginx.servicesudo systemctl enable nginx.service //开机启动cd /etc/nginxsudo vim nginx.conf 然后找到 root ，改成 var/www/blog 。 git hooks12cd /home/git/blog.git/hooksvim posr-receive 复制以下内容： 12345678#!/bin/bashGIT_REPO=/home/git/blog.gitTMP_GIT_CLONE=/tmp/blogPUBLIC_WWW=/var/www/blogrm -rf $&#123;TMP_GIT_CLONE&#125;git clone $GIT_REPO $TMP_GIT_CLONErm -rf $&#123;PUBLIC_WWW&#125;/*cp -rf $&#123;TMP_GIT_CLONE&#125;/* $&#123;PUBLIC_WWW&#125; 接下来： 1chmod +x post-receive 参考一]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三角函数]]></title>
    <url>%2F2019%2F04%2F%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[既然每次考前都要复习，不如记录在这里好了。 诱导公式一 \begin{align*} \sin(-\alpha) &= -\sin(\alpha) \\ \cos(-\alpha) &= -\cos(\alpha) \\ \tan(-\alpha) &= \tan(\alpha) \\ \end{align*}二 \begin{align*} \sin(\pi + \alpha) &= -\sin(\alpha) \\ \cos(\pi + \alpha) &= \cos(\alpha) \\ \tan(\pi + \alpha) &= \tan(\alpha) \\ \end{align*}三 \begin{align*} \sin(\pi - \alpha) &= \sin(\alpha) \\ \cos(\pi - \alpha) &= -\cos(\alpha) \\ \tan(\pi - \alpha) &= -tan(\alpha) \\ \end{align*}四 \begin{align*} \sin(\frac{\pi}{2} + \alpha) &= \cos(\alpha) \\ \cos(\frac{\pi}{2} + \alpha) &= -\sin(\alpha) \end{align*}五 \begin{align*} \sin(\frac{\pi}{2} - \alpha) &= \cos(\alpha)\\ \cos(\frac{\pi}{2} - \alpha) &= \sin(\alpha)\\ \end{align*}三角恒等式两角和差 \begin{align*} \sin(\alpha + \beta) &= \sin(\alpha)\cos(\beta) + \cos(\alpha)\sin(\beta)\\ \sin(\alpha - \beta) &= \sin(\alpha)\cos(\beta) - \cos(\alpha)\sin(\beta) \\ \cos(\alpha + \beta) &= \sin(\alpha)\sin(\beta) - \cos(\alpha)\cos(\beta) \\ \cos(\alpha - \beta) &= \sin(\alpha)\sin(\beta) + \cos(\alpha)\cos(\beta) \\ \tan(\alpha + \beta) &= \frac{\tan(a) + \tan(\beta)}{1 - \tan{\alpha}\tan{\beta}} \\ \tan(\alpha - \beta) &= \frac{\tan(a) - \tan(\beta)}{1 + \tan{\alpha}\tan{\beta}} \end{align*}二倍角 \begin{align*} \sin(2\alpha) &= 2\sin(\alpha)\cos(\alpha) \\ \cos(2\alpha) &= \cos^2(\alpha) - \sin^2(\alpha)= 1 - 2\sin^2(\alpha) = 2\cos(\alpha)^2 - 1 \\ \tan(2\alpha) &= \frac{2\tan(\alpha)}{1 - \tan^2{\alpha}} \end{align*}半角 \begin{align*} \sin(\frac{\alpha}{2}) &= \pm \sqrt{\frac{1 - \cos(\alpha)}{2}} \\ \cos(\frac{\alpha}{2}) &= \pm \sqrt{\frac{1 + \cos(\alpha)}{2}} \\ \tan(\frac{\alpha}{2}) &= \pm \sqrt{\frac{1 - \cos(\alpha)}{1 + \cos(\alpha)}} = \frac{\sin(\alpha)}{1 + \cos(\alpha)} = \frac{1 - \cos(\alpha)}{\sin(\alpha)} \end{align*}]]></content>
      <categories>
        <category>数学</category>
        <category>高等</category>
        <category>三角函数</category>
      </categories>
      <tags>
        <tag>三角函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态DP]]></title>
    <url>%2F2019%2F04%2F%E5%8A%A8%E6%80%81DP%2F</url>
    <content type="text"><![CDATA[动态 $\operatorname{DP}$ ，顾名思义，用于解决动态修改的一类 $\operatorname{DP}$ 问题。同时，由于其需要转化成矩阵形式，其运用范围并不非常广泛。 适用范围前言已然提及，对于这一类问题，需要满足其 $\operatorname{DP}$ 方程必须可改写成矩阵形式，目的是利用矩阵的可合并性，在链上进行快速转移，并可以快速提取一段的权值。 计算方式至于如何快速计算答案，采取的是与 $\operatorname{dsu \ on \ tree}$ 一样的思路，轻重链剖分，分别统计答案。 对于轻链，我们直接将其的答案计入他的父亲节点； 对于重链，我们不做任何操作。 定义 $bot_u$ 为 $u$ 所属重链的底端节点，那么现在查询以 $u$ 为根的子树的 $\operatorname{DP}$ 值，则是将 $u \rightarrow bot_u$ 链上的矩阵暴力相乘即可。 原理至于其原理，其实已然解释过了：他存储的是他的轻儿子的 $\operatorname{DP}​$ 值，重儿子的 $\operatorname{DP}​$ 值则需要转移，此处的转移就是矩阵相乘。 修改方式对于一个点 $u​$ ，计算其到其重链顶端 $top_u​$ 的 $\operatorname{DP}​$ 值，然后更改 $u​$ 点的 $\operatorname{DP}​$ 值，再次计算 $top_u​$ 的 $\operatorname{DP}​$ 值，对于 $fa_{top_u}​$ 的 $\operatorname{DP}​$ 值，增量之，然后让 $u = fa_{top_u}​$ ，继续执行操作。 原理$top_u$ 显然是 $fa_{top_u}$ 的轻儿子，其 $\operatorname{DP}$ 值应当存入 $fa_{top_u}$ 的矩阵以进行转移。 顺便接上节的计算原理。 $top_u$ 的 $\operatorname{DP}$ 的值需要算 $u \rightarrow top_u$ 的矩阵相乘的值。]]></content>
      <categories>
        <category>DP</category>
        <category>动态DP</category>
      </categories>
      <tags>
        <tag>动态DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu T55282 - Snow的追寻]]></title>
    <url>%2F2019%2F04%2FLuogu-T55282-Snow%E7%9A%84%E8%BF%BD%E5%AF%BB%2F</url>
    <content type="text"><![CDATA[运用到了树的直径的可合并性，换言之，是树的直径的动态增量求法。 对于两棵子树，其树的直径端点分别为：$u_1, v_1, u_2, v_2$，那么子树合并后的直径的端点为必然为四个中的某两个。 考虑一条边 $a$ 连通左右连通块： 若直径不经过 $a$ ，则直径为两连通块直径较长的一条。 反之，则要考虑左右连通块的最长链，可知最远的一定是树的直径的端点之一。 利用 $\operatorname{DFS}$ 序将其转为线段问题，其查询必然是一段合法区间不用担心合并时候的问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define MAXN 100010using namespace std;int n, q;int head[MAXN], cnt;int front[MAXN], back[MAXN], size[MAXN], dep[MAXN], pos[MAXN], appear[MAXN &lt;&lt; 1][19], total;int dfn[MAXN], record[MAXN], amount;struct data &#123; int next, to; data(int next = 0, int to = 0):next(next), to(to) &#123;&#125;&#125;link[MAXN &lt;&lt; 1];int getDis(int u, int v) &#123; if (pos[u] &gt; pos[v]) swap(u, v); int k = log2(pos[v] - pos[u] + 1); return dep[u] + dep[v] - 2 * min(appear[pos[u]][k], appear[pos[v] - (1 &lt;&lt; k) + 1][k]);&#125;struct diameter &#123; int u, v, w; diameter(int u = 0, int v = 0, int w = -1):u(u), v(v), w(w) &#123;&#125; diameter operator + (const diameter a) const &#123; diameter c = w &gt; a.w ? *this : a; int temp; if ((temp = getDis(u, a.u)) &gt; c.w) c = diameter(u, a.u, temp); if ((temp = getDis(u, a.v)) &gt; c.w) c = diameter(u, a.v, temp); if ((temp = getDis(v, a.u)) &gt; c.w) c = diameter(v, a.u, temp); if ((temp = getDis(v, a.v)) &gt; c.w) c = diameter(v, a.v, temp); return c; &#125;&#125;;struct segment &#123; int l, r; diameter a;&#125;t[MAXN &lt;&lt; 2];void pushup(int x) &#123; t[x].a = t[x &lt;&lt; 1].a + t[x &lt;&lt; 1 | 1].a;&#125;void build(int l, int r, int x) &#123; t[x].l = l, t[x].r = r; if (l == r) &#123; t[x].a.u = t[x].a.v = record[l]; t[x].a.w = 0; return ; &#125; int mid = (l + r) &gt;&gt; 1; build(l, mid, x &lt;&lt; 1); build(mid + 1, r, x &lt;&lt; 1 | 1); pushup(x);&#125;diameter query(int l, int r, int x) &#123; if (l &lt;= t[x].l &amp;&amp; t[x].r &lt;= r) return t[x].a; int mid = (t[x].l + t[x].r) &gt;&gt; 1; diameter res; if (l &lt;= mid) res = res + query(l, r, x &lt;&lt; 1); if (r &gt; mid) res = res + query(l, r, x &lt;&lt; 1 | 1); return res;&#125;void connect(int u, int v) &#123; link[++cnt] = data(head[u], v); head[u] = cnt;&#125;int read() &#123; int x = 0; char c = getchar(); while (c &lt; '0' || c &gt; '9') c = getchar(); while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void DFS(int u, int pre) &#123; appear[++total][0] = dep[u]; pos[u] = total; record[++amount] = u; front[u] = amount; for (int i = head[u]; i; i = link[i].next) &#123; int v = link[i].to; if (v == pre) continue; dep[v] = dep[u] + 1; DFS(v, u); appear[++total][0] = dep[u]; &#125; back[u] = amount;&#125;void init() &#123; DFS(1, 0); int k = log2(total); for (int j = 1; j &lt;= k; ++j) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= total; ++i) appear[i][j] = min(appear[i][j - 1], appear[i + (1 &lt;&lt; (j - 1))][j - 1]);&#125;int main() &#123; n = read(), q = read(); for (int i = 1; i &lt; n; ++i) &#123; int u = read(), v = read(); connect(u, v); connect(v, u); &#125; init(); build(1, n, 1); while (q--) &#123; int u = read(), v = read(); if (front[u] &gt; front[v]) swap(u, v); diameter res; if (front[u] &gt; 1) res = res + query(1, front[u] - 1, 1); if (back[u] + 1 &lt; front[v]) res = res + query(back[u] + 1, front[v] - 1, 1); int realEnd = max(back[u], back[v]); if (realEnd &lt; n) res = res + query(realEnd + 1, n, 1); printf("%d\n", res.w == -1 ? 0 : res.w); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>基础</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>线段树</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 2305 - [NOI2014]购票]]></title>
    <url>%2F2019%2F04%2FLuogu-2305-NOI2014-%E8%B4%AD%E7%A5%A8%2F</url>
    <content type="text"><![CDATA[易得方程： f_i = \max_{d_i \leq l_i + d_j} f_j + d_ip_i - d_jp_i + q_i化成斜率式： f_j = p_id_j + f_i - d_ip_i - q_i从现在开始的写法都好神仙啊！ 对于树上问题考虑点分治，本质是对于一条链遍历子树时重复计算的优化。 那么对于一个分支中心 $r$ 和其管辖的分治区域，以其向上能达到的最高点排序，使其可单调加入点。 同时，对于一片分治区域统计的应是内部对于内部点的贡献。 同时，$(f_j, d_j)$ 单增，维护上凸包，斜率不定，故采用单调栈 $+$ 二分解决问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 200005#define INF 1e15typedef long long lint;using namespace std;struct data &#123; int next, to; data(int next = 0, int to = 0):next(next), to(to) &#123;&#125;&#125;edge[MAXN &lt;&lt; 1];int n, t;lint s[MAXN], p[MAXN], q[MAXN], l[MAXN], total;lint f[MAXN];double h[MAXN];int sta[MAXN], top;int size[MAXN], maxi, root;bool visit[MAXN];int head[MAXN], cnt;lint d[MAXN];int fa[MAXN];struct node &#123; int u; lint l; node (int u = 0, lint l = 0):u(u), l(l) &#123;&#125; bool operator &lt; (const node a) const &#123; return d[u] - l &gt; d[a.u] - a.l; &#125;&#125;a[MAXN];void connect(int u, int v) &#123; edge[++cnt] = data(head[u], v); head[u] = cnt;&#125;lint read() &#123; char c = getchar(); lint x = 0; while (c &lt; '0' || c &gt; '9') c = getchar(); while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void DFS(int u) &#123; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to; if (v == fa[u]) continue; d[v] = d[u] + s[v]; DFS(v); &#125;&#125;double slope(int u, int v) &#123; if (d[v] == d[u]) return -INF; return (double)(f[v] - f[u]) / (double)(d[v] - d[u]);&#125;void getroot(int u, int sum) &#123; size[u] = 1; int val = 0; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to; if (visit[v]) continue; getroot(v, sum); size[u] += size[v]; val = max(val, size[v]); &#125; val = max(val, sum - size[u]); if (val &lt;= maxi) root = u, maxi = val;&#125;void search(int u) &#123; a[++total] = node(u, l[u]); for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to; if (visit[v]) continue; search(v); &#125;&#125;void append(int u) &#123; while (top &gt;= 2 &amp;&amp; slope(sta[top - 1], sta[top]) &lt;= slope(sta[top], u)) --top; sta[++top] = u; h[top] = -INF; h[top - 1] = slope(sta[top - 1], sta[top]);&#125;int query(lint u) &#123; int l = 1, r = top, ans = 1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (h[mid] &lt;= (double)p[u]) &#123; r = mid - 1; ans = mid; &#125; else l = mid + 1; &#125; return sta[ans];&#125;void solve(int u, int sum) &#123; if (sum == 1) return ; root = 0; maxi = 0x3f3f3f3f; getroot(u, sum); int base = root, cur = root; for (int i = head[cur]; i; i = edge[i].next) &#123; int v = edge[i].to; visit[v] = true; sum -= size[v]; &#125; solve(u, sum); total = 0; for (int i = head[cur]; i; i = edge[i].next) &#123; int v = edge[i].to; search(v); &#125; sort(a + 1, a + total + 1); top = 0; for (int i = 1; i &lt;= total; ++i) &#123; int w = a[i].u; while (cur != fa[u] &amp;&amp; d[w] - d[cur] &lt;= l[w]) &#123; append(cur); cur = fa[cur]; &#125; if (!top) continue; int v = query(w); f[w] = min(f[v] + 1ll * (d[w] - d[v]) * p[w] + q[w], f[w]); &#125; for (int i = head[base]; i; i = edge[i].next) &#123; int v = edge[i].to; solve(v, size[v]); &#125;&#125;int main() &#123; n = (int)read(); t = (int)read(); d[1] = 1; memset(f, 0x3f, sizeof(f)); f[0] = f[1] = 0; for (int i = 2; i &lt;= n; ++i) &#123; fa[i] = (int)read(); s[i] = read(); p[i] = read(); q[i] = read(); l[i] = read(); connect(fa[i], i); &#125; DFS(1); solve(1, n); for (int i = 2; i &lt;= n; ++i) printf("%lld\n", f[i]);&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>斜率优化</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>点分治</tag>
        <tag>单调栈</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 4027 - [NOI2007]货币兑换]]></title>
    <url>%2F2019%2F04%2FLuogu-4027-NOI2007-%E8%B4%A7%E5%B8%81%E5%85%91%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[易得方程： f_i = \max \frac{a_ir_kf_k}{a_kr_k + b_k} + \frac{b_if_k}{a_kr_k + b_k}分别令： \begin{align*} x_k &= \frac{a_i}{a_kr_k +b_ｋ}\\ y_k &= \frac{b_i}{a_kr_k + b_k} \end{align*}有： y_k = -\frac{a_i}{b_i}x_k -\frac{f_i}{b_i}那么维护上凸包，发现这里 $k = -\frac{a_i}{b_i}$ 和 $x_k$ 并不是单调递增的，只能用 $\operatorname{CDQ}$ 分治解决。 将数据按照 $k$ 从小到大排序； 对于左区间分治，并将它以 $x$ 排序，计算其上凸包； 对于右区间已然按照 $k$ 排序，利用单调队列贡献左边对右边的答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#define MAXN 100010using namespace std;int n, base;double f[MAXN];int s[MAXN];const double eps = 1e-8;const double INF = 1e9;struct line &#123; double a, b, r, k, x, y; int id; bool operator &lt; (const line a) const &#123; return k &lt; a.k; &#125;&#125;q[MAXN], t[MAXN];void cost(double s, line l, double&amp; x, double&amp; y) &#123; y = s / (l.a * l.r + l.b); x = y * l.r;&#125;double slope(line a, line b) &#123; if (fabs(b.x - a.x) &lt;= eps) return INF; return (b.y - a.y) / (b.x - a.x);&#125;void solve(int l, int r) &#123; if (l == r) &#123; f[l] = max(f[l - 1], f[l]); cost(f[l], q[l], q[l].x, q[l].y); return ; &#125; int mid = (l + r) &gt;&gt; 1, ql = l - 1, qr = mid; for (int i = l; i &lt;= r; ++i) if (q[i].id &lt;= mid) t[++ql] = q[i]; else t[++qr] = q[i]; for (int i = l; i &lt;= r; ++i) q[i] = t[i]; solve(l, mid); int top = 0; for (int i = l; i &lt;= mid; ++i) &#123; while (top &gt;= 2 &amp;&amp; slope(q[s[top]], q[i]) &gt; slope(q[s[top - 1]], q[s[top]])) --top; s[++top] = i; &#125; for (int i = mid + 1; i &lt;= r; ++i) &#123; while (top &gt;= 2 &amp;&amp; slope(q[s[top - 1]], q[s[top]]) &lt;= q[i].k) --top; int j = s[top]; f[q[i].id] = max(f[q[i].id], q[i].a * q[j].x + q[i].b * q[j].y); &#125; solve(mid + 1, r); ql = l; qr = mid + 1; for (int i = l; i &lt;= r; ++i) if (ql &lt;= mid &amp;&amp; (qr &gt; r || q[ql].x &lt; q[qr].x)) t[i] = q[ql++]; else t[i] = q[qr++]; for (int i = l; i &lt;= r; ++i) q[i] = t[i];&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;base); f[0] = base; for (int i = 1; i &lt;= n; ++i) &#123; scanf("%lf%lf%lf", &amp;q[i].a, &amp;q[i].b, &amp;q[i].r); q[i].id = i; q[i].k = -q[i].a / q[i].b; &#125; sort(q + 1, q + n + 1); solve(1, n); printf("%.3f\n", f[n]);&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>斜率优化</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>斜率优化</tag>
        <tag>单调队列</tag>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 4299 - 首都]]></title>
    <url>%2F2019%2F04%2FLuogu-4299-%E9%A6%96%E9%83%BD%2F</url>
    <content type="text"><![CDATA[动态维护树的重心。 首先，树的重心一定在合并的两棵树的重心间的路径上，证明不难，反证法。 那么每次把两个重心之间的路径提取出来，由于在同一棵 $\operatorname{Splay}$ 上，所以可以将区间划分成两个部分。 对于 $\operatorname{Splay}$ 上的一个点 $x$，若其左子树大，则重心必然在左子树；反之在右子树，计算子树大小时注意计算虚边所连的子树的大小。 有一个优化：若左右子树的大小皆小于总大小的一半，那么其必然是重心。 往子树走的过程，本质上就是缩小搜索区间的过程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 100010#define INF 0x3f3f3f3fusing namespace std;int n, m;char opt[14];int ch[MAXN][2], fa[MAXN], size[MAXN], timid[MAXN];int r[MAXN], sta[MAXN], top, ans;int anc[MAXN];void pushup(int u) &#123; size[u] = size[ch[u][0]] + size[ch[u][1]] + timid[u] + 1;&#125;void pushdown(int u) &#123; if (r[u]) &#123; swap(ch[u][0], ch[u][1]); r[ch[u][0]] ^= 1; r[ch[u][1]] ^= 1; r[u] = 0; &#125;&#125;bool isroot(int u) &#123; return ch[fa[u]][0] != u &amp;&amp; ch[fa[u]][1] != u;&#125;int get(int u) &#123; return ch[fa[u]][1] == u;&#125;void rotate(int u) &#123; int v = fa[u], w = fa[v], c = get(u); if (!isroot(v)) ch[w][get(v)] = u; fa[v] = u; fa[u] = w; ch[v][c] = ch[u][c ^ 1]; fa[ch[v][c]] = v; ch[u][c ^ 1] = v; pushup(v); pushup(u);&#125;void splay(int u) &#123; top = 0; sta[++top] = u; for (int i = u; !isroot(i); i = fa[i]) sta[++top] = fa[i]; while (top) pushdown(sta[top--]); for (int f; !isroot(u); rotate(u)) if (!isroot(f = fa[u])) rotate(get(f) == get(u) ? f : u);&#125;void access(int u) &#123; for (int t = 0; u; u = fa[t = u]) &#123; splay(u); timid[u] += size[ch[u][1]]; ch[u][1] = t; timid[u] -= size[ch[u][1]]; pushup(u); &#125;&#125;void evert(int u) &#123; access(u); splay(u); r[u] ^= 1;&#125;void split(int u, int v) &#123; evert(u); access(v); splay(v);&#125;void link(int u, int v) &#123; split(u, v); fa[u] = v; timid[v] += size[u]; pushup(v);&#125;int find(int u) &#123; return u == anc[u] ? u : anc[u] = find(anc[u]);&#125;int read() &#123; char c = getchar(); int x = 0; while (c &lt; '0' || c &gt; '9') c = getchar(); while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;int solve(int u, int v) &#123; split(find(u), v = find(v)); int suml = 0, sumr = 0, x = v, gravity = INF, limit = size[v] &gt;&gt; 1; while (x) &#123; pushdown(x); int curl = suml + size[ch[x][0]], curr = sumr + size[ch[x][1]]; if (max(curl, curr) &lt;= limit) gravity = min(gravity, x); if (curl &lt; curr) &#123; suml += size[ch[x][0]] + timid[x] + 1; x = ch[x][1]; &#125; else &#123; sumr += size[ch[x][1]] + timid[x] + 1; x = ch[x][0]; &#125; &#125; splay(gravity); return gravity;&#125;int main() &#123; n = read(); m = read(); for (int i = 1; i &lt;= n; ++i) &#123; ans ^= i; size[i] = 1; anc[i] = i; &#125; while (m--) &#123; scanf("%s", opt); int u; switch(opt[0]) &#123; case 'X': printf("%d\n", ans); break; case 'Q': u = read(); printf("%d\n", find(u)); break; default: int u = read(), v = read(), fu = find(u), fv = find(v); link(u, v); ans = ans ^ fu ^ fv; int g = solve(u, v); ans ^= g; anc[fu] = anc[fv] = anc[g] = g; break; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>高级</category>
        <category>LCT</category>
      </categories>
      <tags>
        <tag>LCT</tag>
        <tag>树的重心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 2757 - [国家集训队]等差子序列]]></title>
    <url>%2F2019%2F04%2FLuogu-2757-%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-%E7%AD%89%E5%B7%AE%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[好神仙的一道题。 首先对于答案要满足以下式子： a_i + a_k = 2a_j \\ i < j < k正着想，已知 $a_i, a_j$ ，想对于 $j &gt; k$ 判断是否存在 $a_k$ ，除了 $\operatorname{bitset}$ 暴力卡过好像没有别的办法了。 又是一句老话，正难则反。首先回忆一下排列的性质，其是否不重复？思考这样一个事实：已知 $a_i, a_j$ ，若 $2a_j - a_i$ 当前没有出现，则一定在后面出现。 那么对于 $a_j$ ，对于当前数组成的集合，如果 $[1, a_j - 1]$ 和 $[a_j + 1, n]$ 不尽相同，其缺省的数必然在后面出现，此处运用哈希判断即可。 一般是用线段树实现，此处为了卡常写了线段树。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAXN 10010#define lowbit(x) x &amp; -xtypedef unsigned long long ull;using namespace std;const int fac = 13331;int a[MAXN];ull p[MAXN];int n, t;struct bit &#123; ull t[MAXN]; bit () &#123; memset(t, 0, sizeof(t)); &#125; void add(int x) &#123; int base = x; while (x &lt;= n) &#123; t[x] = t[x] + p[x - base]; x += lowbit(x); &#125; &#125; ull query(int x) &#123; int base = x; ull res = 0; while (x) &#123; res = (res + p[base - x] * t[x]); x -= lowbit(x); &#125; return res; &#125; ull query(int l, int r) &#123; return query(r) - p[r - l + 1] * query(l - 1); &#125;&#125;original, opposite;int read() &#123; int x = 0; char c = getchar(); while (c &lt; '0' || c &gt; '9') c = getchar(); while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void init() &#123; p[0] = 1; for (int i = 1; i &lt;= 10000; ++i) p[i] = p[i - 1] * fac;&#125;int main() &#123; t = read(); init(); while (t--) &#123; n = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); original = bit(); opposite = bit(); bool isSolve = false; for (int i = 1; i &lt;= n; ++i) &#123; int len = min(a[i] - 1, n - a[i]); if (!len) goto plus; if (original.query(a[i] - len, a[i] - 1) != opposite.query(n - a[i] - len + 1, n - a[i])) &#123; isSolve = true; break; &#125; plus: original.add(a[i]); opposite.add(n - a[i] + 1); &#125; if (isSolve) puts("Y"); else puts("N"); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>基础</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>线段树</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚树]]></title>
    <url>%2F2019%2F04%2F%E8%99%9A%E6%A0%91%2F</url>
    <content type="text"><![CDATA[对于一类从某一个图中选出 $k_i$ 个点进行操作，且 $\sum \limits_{i = 1}^n k_i$ 处于可以接受的范围内，那么大致就是虚树一类题了。 这类题主要是把有用的点单独抽出来，进行运算，得到答案。 如何进行呢？开一个栈辅助，将点以 $\operatorname{dfn}$ 排序，且对于一个点 $u$ 有以下策略。 若栈为空，加入栈； 作栈顶和 $u$ 的最近公共祖先，若 $\operatorname{sta}[\operatorname{top}] =dep[LCA]$ ，他们是在同一条树链上，直接加入栈； 反之，一直弹栈，同时将栈顶和栈次连边——他们同在一条树链上且中间无点。直到栈空或 $u$ 位于 $\operatorname{sta[top]}$ 与 $\operatorname{sta}[\operatorname{top} - 1]$ 之间，此时栈顶显然无用，与 $\operatorname{LCA}$ 连边并弹出。同时， $u$ 位于 $\operatorname{LCA}$ 的下方，为了保证树链形态需在之后将 $u$ 加入栈。]]></content>
      <categories>
        <category>数据结构</category>
        <category>高级</category>
        <category>虚树</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 4606 - [SDOI2018]战略游戏]]></title>
    <url>%2F2019%2F04%2FLuogu-4606-SDOI2018-%E6%88%98%E7%95%A5%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[首先看到一个熟悉的 $\sum$ 不难想到虚树，结果发现其是一个无向联通图？ 考虑如何满足那些点的要求：显然求的是某一张子图的割点，似乎导向了点双联通分量，是否可以利用圆方树维护之？ 答案是可以的，同时，思考一下圆方虚树上的点，上面除了占领点的圆点，都是符合题目条件的，也有且仅有这些点满足条件，统计一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAXN 200005using namespace std;struct data &#123; int next, to; data(int next = 0, int to = 0):next(next), to(to) &#123;&#125;&#125;;struct graph &#123; int head[MAXN], cnt; data edge[MAXN &lt;&lt; 2]; graph() &#123; memset(head, 0, sizeof(head)); cnt = 0; &#125; void connect(int u, int v) &#123; edge[++cnt] = data(head[u], v); head[u] = cnt; &#125; void construct(int u, int v) &#123; connect(u, v); connect(v, u); &#125;&#125;origin, trans, timid;int t, n, m, amount, q;int dfn[MAXN], low[MAXN], total;int sta[MAXN], top;int number[MAXN], fa[MAXN][18], dep[MAXN];int s[MAXN];int ans;int control[MAXN];int read() &#123; char c = getchar(); int x = 0; while (c &lt; '0' || c &gt; '9') c = getchar(); while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void tarjan(int u, int pre) &#123; dfn[u] = low[u] = ++total; sta[++top] = u; for (int i = origin.head[u]; i; i = origin.edge[i].next) &#123; int v = origin.edge[i].to; if (v == pre) continue; if (!dfn[v]) &#123; tarjan(v, u); low[u] = min(low[u], low[v]); if (low[v] &gt;= dfn[u]) &#123; ++amount; trans.construct(amount, u); int k; do &#123; k = sta[top--]; trans.construct(amount, k); &#125; while (k != v); &#125; &#125; else low[u] = min(low[u], dfn[v]); &#125;&#125;void DFS(int u, int pre) &#123; dfn[u] = ++total; fa[u][0] = pre; dep[u] = dep[pre] + 1; number[u] = number[pre] + (u &lt;= n); for (int i = 1; i &lt;= 17; ++i) fa[u][i] = fa[fa[u][i - 1]][i - 1]; for (int i = trans.head[u]; i; i = trans.edge[i].next) &#123; int v = trans.edge[i].to; if (v == pre) continue; DFS(v, u); &#125;&#125;int LCA(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); for (int i = 17; i &gt;= 0; --i) if (dep[fa[u][i]] &gt;= dep[v]) u = fa[u][i]; if (u == v) return u; for (int i = 17; i &gt;= 0; --i) if (fa[u][i] != fa[v][i]) &#123; u = fa[u][i]; v = fa[v][i]; &#125; return fa[u][0];&#125;int points(int u, int v) &#123; return number[v] - number[u];&#125;void calc(int u) &#123; int size = 0; for (int i = timid.head[u]; i; i = timid.edge[i].next) &#123; int v = timid.edge[i].to; ++size; ans += points(u, v); calc(v); &#125; if (size == 1 &amp;&amp; u == 1 &amp;&amp; !control[u]) ans -= points(1, timid.edge[timid.head[1]].to) - (timid.edge[timid.head[1]].to &lt;= n); if (u == 1 &amp;&amp; (size &gt; 1 || control[1])) ++ans; timid.head[u] = 0; control[u] = 0;&#125;void init() &#123; timid.cnt = trans.cnt = origin.cnt = total = 0; memset(trans.head, 0, sizeof(trans.head)); memset(origin.head, 0, sizeof(origin.head)); memset(dfn, 0, sizeof(dfn)); memset(number, 0, sizeof(number));&#125;bool comp(int a, int b) &#123; return dfn[a] &lt; dfn[b];&#125;int main() &#123; t = read(); while (t--) &#123; amount = n = read(); m = read(); init(); for (int i = 1; i &lt;= m; ++i) origin.construct(read(), read()); tarjan(1, 0); total = 0; DFS(1, 0); q = read(); while (q--) &#123; ans = 0; int k = read(); for (int i = 1; i &lt;= k; ++i) control[s[i] = read()] = true;; sort(s + 1, s + k + 1, comp); sta[top = 1] = 1; for (int i = 1; i &lt;= k; ++i) &#123; if (s[i] == 1) continue; if (top == 1) &#123; sta[++top] = s[i]; continue; &#125; int u = s[i], v = sta[top], w = LCA(u, v); while (top &gt; 1 &amp;&amp; dfn[sta[top - 1]] &gt;= dfn[w]) &#123; timid.connect(sta[top - 1], sta[top]); --top; &#125; if (w != sta[top]) &#123; timid.connect(w, sta[top]); sta[top] = w; &#125; sta[++top] = u; &#125; while (--top) timid.connect(sta[top], sta[top + 1]); calc(1); printf("%d\n", ans - k); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>高级</category>
        <category>圆方树</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>圆方树</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 3345 - [ZJOI2015]幻想乡战略游戏]]></title>
    <url>%2F2019%2F04%2FLuogu-3345-ZJOI2015-%E5%B9%BB%E6%83%B3%E4%B9%A1%E6%88%98%E7%95%A5%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[本质上是求这棵树的带权重心，带修改。考虑用动态点分治解决问题。 首先建出点分树。对于一次修改只需要改变其到点分树根路径上的点即可。 对于 $u$ 点计算答案时，从其往点分树根走，不难发现这样统计会重复，所以维护三个值：$\operatorname{sumv}, \operatorname{sumd}, \operatorname{sumf}$ ，分别表示其在点分树上子树的权值和、子树各点的权值乘上到 $u$ 的距离和、子树各点的权值乘上到 $fa_u$ 的距离和。 对于点分树上，其到根的路径上的点，都需要做一次统计。大致是分成两个部分：$u$ 的子树和通过 $u$ 的祖先到达的点。 对于前者很好统计：直接统计 $\operatorname{sumd_u}$ ； 对于后者，设已然统计到 $u$ 到点分树根上的某一个点 $f$ ： $f$ 的子树已经被统计过，只需要统计 $fa_f$ 不包含 $f$ 的子树，其贡献为：$\operatorname{sumd_{fa_i}} - \operatorname{sumf}_i$； 上面统计的只统计到了到 $fa_f$ 的答案，需要统计他们到 $u$ 的答案，其贡献为：$(\operatorname{sumv}_{fa_f} - \operatorname{sumv}_f) \times l$ ，$l$ 为 $fa_f$ 到 $u$ 的距离。 大致可以写出代码： 12345678int query(int u) &#123; int res = sumd[u]; for (int i = u; fa[i]; i = fa[i]) &#123; int l = length(u, fa[i]); res = res + sumd[fa[i]] - sumf[i] + (sumv[fa[i]] - sumv[i]) * l; &#125; return res;&#125;]]></content>
      <categories>
        <category>思维</category>
        <category>分治</category>
        <category>树分治</category>
        <category>动态点分治</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>动态点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 3768 - 简单的数学题]]></title>
    <url>%2F2019%2F04%2FLuogu-3768-%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目要求： \sum \limits_{i = 1}^n \sum \limits_{j = 1}^n ij\gcd(i, j)易推得： = \sum \limits_{d = 1}^n d^3 \sum \limits_{i = 1}^{\frac{n}{d}}\sum \limits_{j = 1}^{\frac{n}{d}}ij\sum \limits_{e|(i, j)}\mu(e) \\设： s(n) = \sum \limits_{i = 1}^ni有： \begin{align*} &= \sum \limits_{d = 1}^n\ d^3\sum \limits_{e = 1}^n\mu(e)e^2 s(\lfloor \frac{n}{de} \rfloor)^2 \\ &= \sum \limits_{T = 1}s(\lfloor \frac{n}{T} \rfloor)^2 \sum \limits_{d|T}d^3(\frac{T}{d})^2\mu(\frac{T}{d}) \\ &= \sum \limits_{T = 1}s(\lfloor \frac{n}{T} \rfloor)^2 T^2\sum \limits_{d|T}d\mu(\frac{T}{d}) \\ \end{align*}前面的可以整除分块，后面的先转换一下： \begin{align*} &= T^2\sum \limits_{d|T}d\mu(\frac{T}{d}) \\ &= T^2\varphi(T) \\ \end{align*}构造一个函数 $g(x) = x^2$ ，有： \begin{align*} h(n) &= \sum \limits_{d|n}f(n)g(\frac{n}{d}) \\ h(n) &= n^2\sum \limits_{d|n}\varphi(d) \\ h(n) &= n^3 \end{align*}$h(x)$ 的前缀和和 $g(x)$ 任意值依然可以 $O(1)$ 求出，利用杜教筛套路即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;unordered_map&gt;#include &lt;iostream&gt;#define MAXN 8000050#define N 8000000typedef long long lint;using namespace std;lint p, n;lint phi[MAXN];int v[MAXN], prime[MAXN], total;unordered_map&lt;lint, lint&gt; record;lint inv2, inv6;lint power(lint a, lint b) &#123; lint res = 1; while (b) &#123; if (b &amp; 1) res = res * a % p; a = a * a % p; b &gt;&gt;= 1; &#125; return res;&#125;void init() &#123; phi[1] = 1; for (int i = 2; i &lt;= N; ++i) &#123; if (!v[i]) &#123; prime[++total] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= total &amp;&amp; i * prime[j] &lt;= N; ++j) &#123; v[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; phi[i * prime[j]] = phi[i] * prime[j] % p; break; &#125; phi[i * prime[j]] = phi[i] * (prime[j] - 1) % p; &#125; &#125; for (int i = 1; i &lt;= N; ++i) phi[i] = (phi[i - 1] + phi[i] * i % p * i % p) % p;&#125;lint section(lint n) &#123; n %= p; return n * (n + 1) % p * inv2 % p;&#125;lint factor(lint n) &#123; n %= p; return n * (n + 1) % p * (2 * n + 1) % p * inv6 % p;&#125;lint solve(lint n) &#123; if (n &lt;= N) return phi[n]; if (record[n]) return record[n]; lint res = section(n) * section(n) % p; for (lint i = 2, j; i &lt;= n; i = j + 1) &#123; j = n / (n / i); res = (res - (factor(j) - factor(i - 1) + p) % p * solve(n / i) % p) % p; &#125; return record[n] = (res + p) % p;&#125;int main() &#123; scanf("%lld%lld", &amp;p, &amp;n); init(); inv2 = power(2, p - 2); inv6 = power(6, p - 2); lint ans = 0; for (lint i = 1, j; i &lt;= n; i = j + 1) &#123; j = n / (n / i); ans = (ans + section(n / i) * section(n / i) % p * (solve(j) - solve(i - 1)) % p) % p; &#125; printf("%lld\n", (ans + p) % p);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>反演</category>
        <category>莫比乌斯反演</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>莫比乌斯反演</tag>
        <tag>欧拉函数</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 2081 - [NOI2012]迷失游乐园]]></title>
    <url>%2F2019%2F04%2FLuogu-2081-NOI2012-%E8%BF%B7%E5%A4%B1%E6%B8%B8%E4%B9%90%E5%9B%AD%2F</url>
    <content type="text"><![CDATA[考虑将一个点拆成往上走的期望和往下走的期望，分别计为 $up_u, down_u$ 。 对于树的情况，$down_u$ 显然可以直接统计： down_u = \frac{1}{son_u}\sum \limits down_v + w_{u, v}那么 $up_u$ 可以通过换根 $\operatorname{DP}$ 求出： up_v = \frac{up_u + down_u \times son_u - down_v}{deg_u - 1}注意分母为 $0$ 的情况。 现在考虑基环树的情况：首先是套路，基环树一般环和树分开处理。树的情况发现 $down_u$ 的求法套用没有问题，主要偏差出现在 $up_u$ 上。 对于基环树上的点是能够往上走的，不如强行断边——即规定逆时针走或顺时针走，分别统计答案。 可以有方程： \begin{align*} up_u &= \sum \limits_{v \in \circ} (down_v + w_{u, v}) \times p_{u, v} \\ p_{u, v} &= son_v \times \prod \limits_{w \in (u,v)} \frac{1}{son_w + 1} \end{align*}$p_{u, v}$ 在处在顺/逆时针的最后一个位置时要特判，答案为： \operatorname{ans} =\frac{1}{n}\sum \limits_{i = 1}^n \frac{up_i \times (deg_i - son_i) + down_i \times son_i}{deg_i}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 100005using namespace std;int n, m;int deg[MAXN];int head[MAXN], cnt;bool visit[MAXN], iscircle[MAXN];int loop[MAXN], fa[MAXN], son[MAXN], val[MAXN], energe[MAXN], total;double up[MAXN], down[MAXN];struct data &#123; int next, to, cost; data(int next = 0, int to = 0, int cost = 0):next(next), to(to), cost(cost) &#123;&#125;&#125;edge[MAXN &lt;&lt; 1];void connect(int u, int v, int w) &#123; edge[++cnt] = data(head[u], v, w); head[u] = cnt;&#125;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void DFS1(int u, int pre) &#123; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to, w = edge[i].cost; if (v == pre || iscircle[v]) continue; ++son[u]; DFS1(v, u); down[u] = down[u] + down[v] + w; &#125; if (son[u] != 0) down[u] = down[u] / son[u];&#125;void DFS2(int u, int pre) &#123; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to, w = edge[i].cost; if (v == pre || iscircle[v]) continue; up[v] = w + ((deg[u] - son[u]) * up[u] + down[u] * son[u] - down[v] - w) / (double)max(deg[u] - 1, 1); DFS2(v, u); &#125;&#125;void find(int u, int pre) &#123; visit[u] = true; fa[u] = pre; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to, w = edge[i].cost; if (v == pre) continue; if (total) return ; if (visit[v]) &#123; for (int j = u; j != fa[v] &amp;&amp; j; j = fa[j]) &#123; loop[++total] = j; energe[total] = val[j]; iscircle[j] = true; &#125; energe[total] = w; return ; &#125; val[v] = w; find(v, u); &#125;&#125;int afterward(int x) &#123; return x == total ? 1 : x + 1;&#125;int preward(int x) &#123; return x == 1 ? total : x - 1;&#125;int main() &#123; n = read(); m = read(); for (int i = 1; i &lt;= m; ++i) &#123; int u = read(), v = read(), w = read(); connect(u, v, w); connect(v, u, w); ++deg[u]; ++deg[v]; &#125; if (m == n - 1) &#123; DFS1(1, 0); DFS2(1, 0); &#125; else &#123; find(1, 0); for (int i = 1; i &lt;= total; ++i) DFS1(loop[i], 0); for (int i = 1; i &lt;= total; ++i) &#123; int u = afterward(i), w = 0; double p = 0.5; while (u != i) &#123; p = p / (double)(son[loop[u]] + 1); w = w + energe[preward(u)]; up[loop[i]] = up[loop[i]] + (down[loop[u]] + w) * p * (afterward(u) == i ? son[loop[u]] + 1 : son[loop[u]]); u = afterward(u); &#125; u = preward(i); w = 0; p = 0.5; while (u != i) &#123; p /= (double)(son[loop[u]] + 1); w = w + energe[u]; up[loop[i]] = up[loop[i]] + (down[loop[u]] + w) * p * (preward(u) == i ? son[loop[u]] + 1 : son[loop[u]]); u = preward(u); &#125; &#125; for (int i = 1; i &lt;= total; ++i) DFS2(loop[i], 0); &#125; double ans = 0; for (int i = 1; i &lt;= n; ++i) ans = ans + (up[i] * (deg[i] - son[i]) + down[i] * son[i]) / deg[i]; printf("%f\n", ans / n);&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>树形DP</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>基环树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DP优化小结]]></title>
    <url>%2F2019%2F04%2FDP%E4%BC%98%E5%8C%96%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[这篇文章是对常见 $\operatorname{DP}$ 优化套路的一些总结。 单调队列优化适用范围适用于优化以下方程： \begin{align*} f_i &= \max_{l_i}^{i - 1} f_j + w_j + w_i \\ l_i &\leq l_{i + 1} \end{align*}这类方程的显著特点是 $i, j$ 变量分离，直接利用单调队列维护其决策区间，队首为最优决策点。 斜率优化适用范围适用于优化以下方程： f_i = \max_{j = 1}^{i - 1}f_j + w_iw_j + v_i + v_j这种方程的特点就是含有 $w_i, w_j$ 的乘积项，其 $i, j$ 并没有分离，当然一般还会有分别关于 $i, j$ 的变量。 不看 $\max$ ，有： \begin{align*} f_j + v_j &= f_i - w_iw_j - v_i\\ f_j + v_j &= -w_iw_j + f_i - v_i \end{align*}可以看作一条以 $-w_i$ 为斜率，$f_i - v_i$ 为截距的直线，看这个斜率便可以判断是上凸壳还是下凸壳了。 每一次加入一个点 $(w_j, f_j + v_j)$ ，每一次查询是以一条斜率为 $-w_i$ 的直线去贴近那些点，得到的最大的截距。 只有上凸壳上的点或者下凸壳上的点会产生贡献，其余可以忽略。 判断凸壳求最大值便是维护上凸壳，反之维护下凸壳。 总结斜率 斜率单调暴力移指针，斜率不单调二分找答案。 注意：该处的斜率单调应当是针对于凸壳而言的。 $x$ 坐标 $x$ 坐标单调开单调队列，$x$ 坐标不单调开平衡树 $/$ $\operatorname{CDQ}$ 分治。 决策单调性适用范围适用于优化以下方程： f_i = \max_j^{i - 1} f_j + w(j, i)只要 $w(i, j)$ 满足任意四边形不等式即可。 凸四边形不等式满足以下不等式： a < b < c < d \\ w(a, c) + w(b, d) \leq w(a, d) + w(b, c)那么有对于决策 $u, v$ ，且 $u &lt; v$ ，若决策 $v$ 优于 $u$ ，则以后决策 $v$ 皆优于 $u$ 。 凹四边形不等式满足以下不等式： a < b < c < d \\ w(a, c) + w(b, d) \geq w(a, d) + w(b, c)那么有对于决策 $u, v$ ，且 $u &lt; v$ ，若决策 $u$ 优于 $v$ ，则以后决策 $u$ 皆优于 $v$ 。 总结凸四边形不等式一般用单调队列维护，凹四边形不等式一般用单调栈维护。 其判断依据皆基于其性质。 同时，对于一类以以下形式转移的方程： f_{i, \forall} = \max f_{i - 1, \forall}利用分治进行优化，代码实现简单。 带权二分适用范围当我们遇到这样一类题型：做一个决策，要求作 $m$ 次决策，且随着决策的次数越多决策带来的利益就越小。 通俗地讲，对于一个取得越多越优，且得到贡献越来越少的物品，限制最多选 $m$ 个，求解最优答案。 数学可以这样表示：设决策利益为 $g(x)$ ，则$g(x) - g(x - 1) &gt; g(x + 1) - g(x)$ 。 实现首先先假设这是一个最大化问题。 我们先不考虑限制，通过一次普通的 $\operatorname{DP}$ ，我们可以知道不考虑限制时，我们作了 $p$ 次决策。此时我们给决策加上代价 $c$ 。这时候再进行 $\operatorname{DP}$ ，此次作了 $q$ 次决策，其中，$p$ 和 $q$ 不尽相同。也就是意味着，代价 $c$ 会使决策改变。显然，会使决策次数变少。 于是，当决策次数大于 $m$ 时，应该减小 $c$ ；反之，应该加大 $c$ 。通过这样的二分，一定能够使决策次数等于 $m$ 。 证明由于 $\operatorname{DP}$ 是基于最优决策下的，也就是对于每个操作代价增加 $c$ 的情况下，求得了当前最优解，是取 $k$ 个的最优解。那么将每个操作价值还原，也就是在总答案加上 $m \times c$ ，其仍然是取 $k$ 个的最优解。]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>决策单调性</tag>
        <tag>单调栈</tag>
        <tag>algorithm</tag>
        <tag>DP</tag>
        <tag>斜率优化</tag>
        <tag>单调队列</tag>
        <tag>带权二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 4709 - [JSOI2011]柠檬]]></title>
    <url>%2F2019%2F04%2FBZOJ-4709-JSOI2011-%E6%9F%A0%E6%AA%AC%2F</url>
    <content type="text"><![CDATA[折腾了我好久的一道题，莫名其妙证明了一个函数满足四边形不等式然而好像不用。 分析一下可以发现对于一段变柠檬的区间，首尾相同，否则分出去显然更优，用 $f_i$ 表示前 $i$ 个贝壳变柠檬的最大数目，$s_i$ 为前 $i$ 个为 $a_i$ 的数目： f_i = \max_{j = 1}^{i} f_{j - 1} + a_i(s_i - s_j + 1)^2后面那个函数是满足凹四边形不等式的，所以该方程满足决策单调性，此处的意思为当 $u$ 在某一个时刻比 $v$ 好时 $(u &lt; v)$ ，他之后就永远比 $v$ 好。 对于两个顺序决策 $u, v$ ，必然存在一个分界点使往左 $v$ 优，往右 $u$ 优。 三个顺序决策 $u, v, w$ ，其中 $w$ 是新加入的决策，倘若 $u, v$ 的分界点小于 $v, w$ 的分界点，$v$ 决策显然无用。 抑或是栈顶元素 $u$ 的决策区间已然完结了，那么弹出栈顶。 二分的作用是找到最早的 $u$ 比 $v$ 优的位置。 不得不感叹国内资源还是差，竟然罕有人能够解释清楚的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#define MAXN 100005typedef long long lint;using namespace std;int n, s[MAXN], a[MAXN], c[MAXN];lint f[MAXN];vector&lt;int&gt; g[MAXN];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;lint calc(int n, lint m) &#123; return f[n - 1] + 1ll * a[n] * m * m;&#125;int bound(int u, int v) &#123; int l = 1, r = n, res = n + 1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (calc(u, mid - s[u] + 1) &gt;= calc(v, mid - s[v] + 1)) &#123; r = mid - 1; res = mid; &#125; else l = mid + 1; &#125; return res;&#125;int main() &#123; n = read(); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = read(); s[i] = ++c[a[i]]; while (g[a[i]].size() &gt;= 2 &amp;&amp; bound(g[a[i]][g[a[i]].size() - 2], g[a[i]][g[a[i]].size() - 1]) &lt;= bound(g[a[i]][g[a[i]].size() - 1], i)) g[a[i]].pop_back(); g[a[i]].push_back(i); while (g[a[i]].size() &gt;= 2 &amp;&amp; bound(g[a[i]][g[a[i]].size() - 2], g[a[i]][g[a[i]].size() - 1]) &lt;= s[i]) g[a[i]].pop_back(); f[i] = calc(g[a[i]][g[a[i]].size() - 1], s[i] - s[g[a[i]][g[a[i]].size() - 1]] + 1); &#125; printf("%lld\n", f[n]);&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>决策单调性</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>决策单调性</tag>
        <tag>四边形不等式</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LOJ 6039 - 「雅礼集训 2017 Day5」珠宝]]></title>
    <url>%2F2019%2F04%2FLOJ-6039-%E3%80%8C%E9%9B%85%E7%A4%BC%E9%9B%86%E8%AE%AD-2017-Day5%E3%80%8D%E7%8F%A0%E5%AE%9D%2F</url>
    <content type="text"><![CDATA[十分神仙的题，乍一看是一道简单的 $01$ 背包，实际上数据规模大的可怕。 数据有一个特点就是代价极小，应从此处入手。 显然有一种贪心：相同代价的，先取价值大的。基于代价相同列一下方程： f_{i, j} = \max_{k} (f_{i - 1, j - k \times i} + \sum \limits_{l = 1}^k v_{i, l})和常规的背包方程略有不同，因为借用了贪心的思想，最后一项由于斜率单调递减，大致是满足四边形不等式的，易证故此处不证。那么该方程满足决策单调性，但基于模 $ i $ 相同的情况。 所以针对模 $i$ 相同的值分别处理，利用分治计算——网上大部分言论认为无法用二分实现，因为无法快速计算最优决策点。其实不然，但是对于此类由 $f_{i - 1, \forall}$ 转移到 $f_{i, \forall}$ 的方程利用分治大量降低代码复杂度和思维难度。 分治是这么做的：对于一段查询区间 $[l, r]$ ，确定其决策点在 $[u, v]$ 中，那么那么查询区间中查询何处以 $mid$ 作为最优决策点，$[l, mid]$ 必然比该决策点小，$[mid + 1, r]$ 同理，同时决策点范围区间也被相应划分，注意同时包含决策点 $w$ 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define MAXC 305#define MAXK 50005#define MAXN 10000005typedef long long lint;using namespace std;int n, k;const int C = 300;lint f[MAXC][MAXK];vector&lt;lint&gt; gem[MAXC], w[MAXC];int section[MAXN], total;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;bool comp(lint a, lint b) &#123; return a &gt; b;&#125;lint calc(int c, int u, int v) &#123; int p = (v - u) / c; if (p &gt; gem[c].size()) return -1; return f[c - 1][u] + w[c][p];&#125;void solve(int c, int l, int r, int u, int v) &#123; int mid = (l + r) &gt;&gt; 1, w = 0; lint maxi = -1; for (int i = u; i &lt;= min(mid, v); ++i) &#123; lint val = calc(c, section[i], section[mid]); if (val &gt; maxi) &#123; maxi = val; w = i; &#125; &#125; if (l == r) &#123; f[c][section[l]] = maxi; return ; &#125; solve(c, l, mid, u, w); solve(c, mid + 1, r, w, v);&#125;int main() &#123; n = read(); k = read(); for (int i = 1; i &lt;= n; ++i) &#123; int c = read(), v = read(); gem[c].push_back(v); &#125; for (int i = 1; i &lt;= C; ++i) &#123; sort(gem[i].begin(), gem[i].end(), comp); lint sum = 0; w[i].push_back(sum); for (int j = 0; j &lt; gem[i].size(); ++j) w[i].push_back((sum = sum + gem[i][j])); for (int j = 0; j &lt; i; ++j) &#123; section[total = 1] = j; while (section[total] + i &lt;= k) &#123; ++total; section[total] = section[total - 1] + i; &#125; solve(i, 1, total, 1, total); &#125; &#125; for (int i = 1; i &lt;= k; ++i) printf("%lld ", f[C][i]); puts("");&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>决策单调性</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>决策单调性</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 4822 - [BJWC2012]冻结]]></title>
    <url>%2F2019%2F04%2FLuogu-4822-BJWC2012-%E5%86%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一道分层图最短路的模版题。 不得不说分层图着实是一种很有趣又很实用的想法：将图划分层 $k$ 部分，每个部分之间的转移代表着花费一次代价。这也就意味着这类题目通常有一些特殊的代价，且其使用次数与点数之积能够接受。 对于该题，建分层图就结束了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 5005#define MAXM 100005#define INF 0x3f3f3f3fusing namespace std;int n, m, k; int head[MAXN], cnt;int dis[MAXN];bool visit[MAXN];struct data &#123; int next, to, cost; data(int next = 0, int to = 0, int cost = 0):next(next), to(to), cost(cost) &#123;&#125;&#125;edge[MAXM &lt;&lt; 2];struct node &#123; int u, d; node(int u = 0, int d = 0):u(u), d(d) &#123;&#125; bool operator &lt; (const node a) const &#123; return d &gt; a.d; &#125;&#125;;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void connect(int u, int v, int w) &#123; edge[++cnt] = data(head[u], v, w); head[u] = cnt;&#125;void construct(int u, int v, int w) &#123; connect(u, v, w); connect(v, u, w);&#125;void Dijkstra() &#123; priority_queue&lt;node&gt; q; memset(dis, INF, sizeof(dis)); dis[1] = 0; q.push(node(1, 0)); while (!q.empty()) &#123; int u = q.top().u; q.pop(); if (visit[u]) continue; visit[u] = true; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to, w = edge[i].cost; if (dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; q.push(node(v, dis[v])); &#125; &#125; &#125;&#125;int main() &#123; n = read(); m = read(); k = read(); for (int i = 1; i &lt;= m; ++i) &#123; int u = read(), v = read(), w = read(); for (int j = 0; j &lt;= k; ++j) construct(u + j * n, v + j * n, w); for (int j = 1; j &lt;= k; ++j) &#123; connect(u + (j - 1) * n, v + j * n, w / 2); connect(v + (j - 1) * n, u + j * n, w / 2); &#125; &#125; Dijkstra(); int ans = INF; for (int i = 0; i &lt;= k; ++i) ans = min(ans, dis[n + i * n]); printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>最短路</category>
        <category>分层图</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>最短路</tag>
        <tag>分层图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 3255 - [JLOI2013]地形生成]]></title>
    <url>%2F2019%2F04%2FLuogu-3255-JLOI2013-%E5%9C%B0%E5%BD%A2%E7%94%9F%E6%88%90%2F</url>
    <content type="text"><![CDATA[还是一道很不错的计数题目。 对于第一问是可以不进行 $\operatorname{DP}$ 的：考虑将山从大到小构建答案数列的过程，发现对于任意高度较其高的山可以视作相同的山，将他们看作一个暂时构造完成的数列。把这座山加入，无非是进行放置空位的选择，再考虑上关键值的限制，其对答案的贡献应为： \operatorname{ans} = \operatorname{ans} \times \min(i, \operatorname{sum} + \operatorname{key}_i)其中，$\operatorname{sum}$ 为高度与此山相同的山的数目。 分析第二问，对于高度相同的山仍然可以按照第一问处理，只是高度相同的山加入序列时会产生重复贡献的情况，同时因为关键值的存在而不能直接计算。针对高度相同分别处理，考虑 $\operatorname{DP}$ ，设 $f_{i, j}$ 为在将 $i$ 座山，插入前 $j$ 个空的方案数： f_{i, j} = \sum \limits_{k = 1}^{j} f_{i - 1, k}很好理解的 $\operatorname{DP}$ ，可以简化使复杂度正确： f_{i, j} = f_{i, j - 1} + f_{i - 1,j}复杂度 $O(n^2)$ 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAXN 1005using namespace std;const int mod = 2011;int n;int f[MAXN];struct node &#123; int h, k; node(int h = 0, int k = 0):h(h), k(k) &#123;&#125;&#125;a[MAXN];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;bool comp(node a, node b) &#123; return a.h &gt; b.h || (a.h == b.h &amp;&amp; a.k &lt; b.k);&#125;int solve1() &#123; int sum = 0, ans = 1; for (int i = 1; i &lt;= n; ++i) &#123; if (a[i].h == a[i - 1].h) ++sum; else sum = 0; ans = ans * min(i, a[i].k + sum) % mod; &#125; return ans;&#125;int solve2() &#123; int ans = 1; for (int i = 1; i &lt;= n; ++i) &#123; int j = i; while (a[j + 1].h == a[j].h) ++j; memset(f, 0, sizeof(f)); f[0] = 1; for (int p = i; p &lt;= j; ++p) for (int q = 1; q &lt;= min(a[p].k, i) - 1; ++q) f[q] = (f[q - 1] + f[q]) % mod; int sum = 0; for (int l = 0; l &lt;= min(a[j].k, i) - 1; ++l) sum = (sum + f[l]) % mod; ans = ans * sum % mod; swap(i, j); &#125; return ans;&#125;int main() &#123; n = read(); for (int i = 1; i &lt;= n; ++i) &#123; a[i].h = read(); a[i].k = read(); &#125; sort(a + 1, a + n + 1, comp); printf("%d %d\n", solve1(), solve2());&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>计数DP</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>solution</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 3214 - [HNOI2011]卡农]]></title>
    <url>%2F2019%2F04%2FLuogu-3214-HNOI2011-%E5%8D%A1%E5%86%9C%2F</url>
    <content type="text"><![CDATA[题目十分冗长，给出题意简化版： 求从集合 $S = \{1, 2, \dots , n\}$ 中选出 $m$ 个非空子集，两两不同，且每个元素出现的次数必须是偶数次。 利用可以递推解决问题，设 $f_i$ 为选出 $i$ 个满足题意的子集的方案数。 现下有三个限制条件：第一个略；第二个暂时不做考虑，先考虑第三个。 首先对于 $i - 1$ 个集合，定然能添置一个集合使其成立，那么结合限制条件一有： f_i = A^{i - 1}_{2^n - 1} - f_{i - 1}现在考虑限制条件二，显然前 $i - 1$ 个集合存在且仅存在一个集合与第 $i$ 个集合相同。枚举该集合的位置、可行种类数，有总方程式： f_i = A^{i - 1}_{2^n - 1} - f_{i - 1} - (i - 1)(2^n - 1 - (i - 2))f_{i - 2}12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define MAXN 1000006typedef long long lint;using namespace std;const int mod = 100000007;int n, m;lint A[MAXN], f[MAXN];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;lint power(lint a, int b) &#123; lint res = 1; while (b) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;int main() &#123; n = read(); m = read(); f[0] = 1; A[0] = 1; lint base = power(2, n) - 1, div = 1; for (int i = 1; i &lt;= m; ++i) &#123; A[i] = A[i - 1] * (base - i + 1) % mod; div = div * i % mod; &#125; for (int i = 2; i &lt;= m; ++i) f[i] = (A[i - 1] - f[i - 1] - (base - (i - 2)) * (i - 1) % mod * f[i - 2]) % mod; printf("%lld\n", (f[m] * power(div, mod - 2) % mod + mod) % mod);&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>计数DP</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>solution</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 4025 - 二分图]]></title>
    <url>%2F2019%2F03%2FBZOJ-4025-%E4%BA%8C%E5%88%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[判断二分图的操作利用并查集——维护距离并且判断奇环。 对于题目的要求可以采用一个通用的做法：对于时间进行分治：考虑一个近似于线段树的结构，一条边最多会被算到 $\log n$ 个区间里。对于每一个叶子结点，利用并查集辅助判断即可，有点类似标记永久化线段树的思想。 同时在大区间就不能构成的其分治子区间显然不行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAXN 200005typedef std::pair&lt;int, int&gt; pa;using namespace std;int n, m, t;int ans[MAXN];int fa[MAXN], size[MAXN], val[MAXN];struct edge &#123; int u, v, l, r; edge(int u = 0, int v = 0, int l = 0, int r = 0):u(u), v(v), l(l), r(r) &#123;&#125;&#125;;vector&lt;edge&gt; a;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;int get(int x) &#123; while (x != fa[x]) x = fa[x]; return x;&#125;int length(int x) &#123; int k = 0; while (x != fa[x]) &#123; k ^= val[x]; x = fa[x]; &#125; return k;&#125;bool merge(int u, int v, stack&lt;pa&gt;&amp; s) &#123; int fu = get(u), fv = get(v); if (fu == fv) return false; if (size[fu] &gt; size[fv]) swap(fu, fv); val[fu] = length(u) ^ length(v) ^ 1; fa[fu] = fv; size[fv] += size[fu]; s.push(make_pair(fu, fv)); return true;&#125;void remove(stack&lt;pa&gt;&amp; s) &#123; while (!s.empty()) &#123; int u = s.top().first, v = s.top().second; fa[u] = u; val[u] = 0; size[v] -= size[u]; s.pop(); &#125;&#125;void init() &#123; for (int i = 1; i &lt;= n; ++i) &#123; fa[i] = i; size[i] = 1; &#125;&#125;void solve(int l, int r, vector&lt;edge&gt;&amp; w) &#123; vector&lt;edge&gt; u, v; stack&lt;pa&gt; s; int mid = (l + r) &gt;&gt; 1; for (int i = 0; i &lt; w.size(); ++i) &#123; if (w[i].l &lt;= l &amp;&amp; r &lt;= w[i].r) &#123; if (!merge(w[i].u, w[i].v, s) &amp;&amp; !(length(w[i].u) ^ length(w[i].v))) &#123; for (int i = l; i &lt;= r; ++i) ans[i] = 0; remove(s); return ; &#125; &#125; else &#123; if (w[i].l &lt;= mid) u.push_back(w[i]); if (w[i].r &gt; mid) v.push_back(w[i]); &#125; &#125; if (l != r) &#123; solve(l, mid, u); solve(mid + 1, r, v); &#125; remove(s);&#125;int main() &#123; n = read(); m = read(); t = read(); for (int i = 1; i &lt;= m; ++i) &#123; int u = read(), v = read(), l = read() + 1, r = read(); a.push_back(edge(u, v, l, r)); &#125; for (int i = 1; i &lt;= n; ++i) &#123; fa[i] = i; size[i] = 1; &#125; for (int i = 1; i &lt;= t; ++i) ans[i] = true; solve(1, t, a); for (int i = 1; i &lt;= t; ++i) if (ans[i]) puts("Yes"); else puts("No");&#125;]]></content>
      <categories>
        <category>思维</category>
        <category>分治</category>
        <category>线段树分治</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>线段树分治</tag>
        <tag>并查集</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 5176 - 公约数]]></title>
    <url>%2F2019%2F03%2FLuogu-5176-%E5%85%AC%E7%BA%A6%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目要求我们求这个式子： \sum \limits_{i = 1}^n\sum \limits_{j = 1}^m\sum \limits_{k = 1}^p \gcd(i \cdot j, i \cdot k, j \cdot k) \times \gcd(i, j, k) \times (\frac{\gcd(i, j)}{\gcd(i, k)\times \gcd(j, k)} + \frac{\gcd(i, k)}{\gcd(i, j)\times \gcd(j, k)} + \frac{\gcd(j, k)}{\gcd(i, j)\times \gcd(i, k)})式子很长，可不是嘛，前面的非常干扰我们反演，尝试替换一下： \gcd(i \cdot j, i \cdot k, j \cdot k) = \frac{\gcd(i, j) \times \gcd(i, k) \times \gcd(j, k)}{gcd(i, j, k)}可以对于每一个质因子 $p$ 进行考虑，其显然是 $p^{\min(c_i + c_j, c_i + c_k, c_j + c_k)}$ ，那么转换后的式子显然最小的会多统计一次，除去即可。 那么原式为： \begin{align*} &\sum \limits_{i = 1}^n\sum \limits_{j = 1}^m\sum \limits_{k = 1}^p gcd(i,j)^2 + \gcd(i, k)^ 2 + \gcd(j, k)^2 \\ = & p\sum \limits_{i = 1}^n \sum \limits_{j = 1}^m \gcd(i, j)^2 + m\sum \limits_{i = 1}^n \sum \limits_{j = 1}^p \gcd(i, j)^2 + n\sum \limits_{i = 1}^m \sum \limits_{j = 1}^p \gcd(i, j)^2 \end{align*}显然可以分开计算，随便算一个： \begin{align*} & \sum \limits_{i = 1}^n \sum \limits_{j = 1}^m \gcd(i, j)^2 \\ =& \sum \limits_{d = 1}^{\min(n, m)} d^2 \sum \limits_{i = 1}^n \sum \limits_{j = 1}^m [\gcd(i, j) = d] \\ =& \sum \limits_{d = 1}^{\min(n, m)} d^2 \sum \limits_{i = 1}^{\frac{n}{d}} \sum \limits_{j = 1}^{\frac{m}{d}} \sum \limits_{t | d}\mu(t) \\ =& \sum \limits_{d = 1}^{\min(n, m)} d^2 \sum \limits_{t = 1}^{\min(\frac{n}{d}, \frac{m}{d})}\mu(t) \cdot \frac{n}{dt} \cdot \frac{m}{dt} \\ =& \sum \limits_{T = 1}^{\min(n, m)} \frac{n}{T} \cdot \frac{m}{T} \sum \limits_{d|T}d^2 \mu(\frac{T}{d}) \\ \end{align*}后面是两个积性函数的卷积，那么也可以线性筛，有以下定理： f(x \times p) = f(x) \times p^2分情况讨论，对象为 $x \times p$ ： 对于 $p\mid d$ 且 $p^2 \nmid d$ 的部分：可以从 $x$ 直接继承来，只是 $d^2 \rightarrow d^2 \times p^2$ ； 对于 $p^2 \mid d$ 的部分：$\mu = 0$ ，且 $x$ 无产生相对应贡献，不用记入，对于原数 $p | d$ 的部分计入情况 3. ； 对于 $p \nmid d$ 的部分：同情况 1. 。 那么可以线性筛了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define MAXN 20000005typedef long long lint;using namespace std;const int mod = 1e9 + 7, N = 2e7;int t, n, m, p;int prime[MAXN], total;lint f[MAXN];bool v[MAXN];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;lint power(lint a, int b) &#123; lint res = 1; while (b) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;void init(int n) &#123; f[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (!v[i]) &#123; prime[++total] = i; f[i] = (1ll * i * i % mod - 1 + mod) % mod; &#125; for (int j = 1; j &lt;= total &amp;&amp; 1ll * i * prime[j] &lt;= n; ++j) &#123; v[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; f[i * prime[j]] = f[i] * prime[j] % mod * prime[j] % mod; break; &#125; f[i * prime[j]] = f[i] * f[prime[j]]; &#125; &#125; for (int i = 1; i &lt;= n; ++i) f[i] = (f[i - 1] + f[i]) % mod;&#125;lint solve(int n, int m) &#123; lint res = 0; int limit = min(n, m); for (int i = 1, j; i &lt;= limit; i = j + 1) &#123; j = min(n / (n / i), m / (m / i)); res = (res + 1ll * (n / i) * (m / i) % mod * (f[j] - f[i - 1] + mod) % mod) % mod; &#125; return res;&#125;int main() &#123; t = read(); init(N); while (t--) &#123; n = read(); m = read(); p = read(); lint ans = (solve(n, m) * p % mod + solve(m, p) * n % mod + solve(n, p) * m % mod) % mod; printf("%lld\n", ans); &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>反演</category>
        <category>莫比乌斯反演</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>gcd</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合卷积]]></title>
    <url>%2F2019%2F03%2F%E9%9B%86%E5%90%88%E5%8D%B7%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[集合卷积是一类特殊的卷积。由于集合操作的不同，大致可以分为集合并卷积、集合交卷积、集合对称差卷积、子集卷积四种。 集合并卷积定义首先定义 $S$ 为全集，那么集合并卷积满足以下形式： f_i = \sum \limits_{j \subseteq S}\sum \limits_{k \subseteq S} [j \cup k = i] g_jh_k用程序可以如此表示： f_i = \sum \limits_{j | k = i} g_jh_k快速沃尔什变换首先，$A$ 是一个集合幂级数，换而言之就是一个多项式，默认长度为 $n$ 。 变换对于快速沃尔什变换： F(A) = (F(A_1), F(A_0 + A_1))其中，逗号相连表示前者取前 $2^{n - 1}$ ，后者取后 $2^{n - 1}$ 位。$A_0$ 表示首位为 $0$ 的集合幂级数， $A_1$ 表示首位为 $1$ 的集合幂级数。 证明首先，显然首位为 $0$ 或 $1$ 的都会贡献到首位为 $1$ 上面去。 显然有： F(A + B) = F(A) + F(B)同时需要证明： F(A | B) = F(A) \times F(B)利用数学归纳法，证明有： \begin{align*} F(A | B) &= F((A|B)_0, (A|B)_1) \\ F(A | B) &= F(A_0|B_0, A_0|B_1 + A_1|B_0 + A_1|B_1) \\ F(A | B) &= (F(A_0|B_0), F(A_0|B_0 + A_0|B_1 + A_1|B_0 + A_1|B_1)) \\ F(A | B) &= (F(A_0) \times F(B_0), (F(A_0) + F(A_1)) \times (F(B_0) + F(B_1)))\\ F(A | B) &= (F(A_0) \times F(B_0), F(A_0 + A_1) \times F(B_0 + B_1)) \\ F(A | B) &= (F(A_0) + F(A_0 + A_1)) \times (F(B_0) + F(B_0 + B_1))\\ F(A | B) &= F(A) + F(B) \end{align*}逆变换逆变换有： F(x) = (F(x_0 - x_1), F(x_1))快速莫比乌斯变换难用数学表示，只作代码记录： 对于其逆变换有： 集合交卷积定义首先定义 $S$ 为全集，那么集合并卷积满足以下形式： f_i = \sum \limits_{j \subseteq S}\sum \limits_{k \subseteq S} [j \cup k = i] g_jh_k用程序可以如此表示： f_i = \sum \limits_{j \& k = i} g_jh_k快速沃尔什变换集合对称差卷积快速沃尔什变换子集卷积快速莫比乌斯变换]]></content>
      <categories>
        <category>数学</category>
        <category>集合</category>
      </categories>
      <tags>
        <tag>FWT</tag>
        <tag>algorithm</tag>
        <tag>FMT</tag>
        <tag>集合幂级数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 2093 - [国家集训队]JZPFAR]]></title>
    <url>%2F2019%2F03%2FLuogu-2093-%5B%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%5DJZPFAR%2F</url>
    <content type="text"><![CDATA[$\operatorname{kd tree}$ 的求第 $k$ 远的模版题，缺少重构操作以及插入操作，那两个操作也挺好写就把这题记录一下好了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define MAXN 100005#define MAXD 2#define INF 0x3f3f3f3ftypedef long long lint;typedef std::pair&lt;lint, int&gt; pa;using namespace std;int n, m, D;int ch[MAXN][2], maxi[MAXN][MAXD], mini[MAXN][MAXD], root;int a[MAXN];struct node &#123; lint d; int id; node(lint d = 0, int id = 0):d(d), id(id) &#123;&#125; bool operator &lt; (const node a) const &#123; return d &gt; a.d || (d == a.d &amp;&amp; id &lt; a.id); &#125;&#125;;priority_queue&lt;node&gt; q;struct point &#123; int d[MAXD], id; point(int x = 0, int y = 0, int z = 0) &#123; d[0] = x; d[1] = y; id = z; &#125;&#125;p[MAXN];int read() &#123; char c = getchar(); int x = 0, s = 1; while (!isdigit(c)) &#123; if (c == '-') s = -1; c = getchar(); &#125; while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x * s;&#125;bool comp(int a, int b) &#123; return p[a].d[D] &lt; p[b].d[D];&#125;void pushup(int x) &#123; for (int i = 0; i &lt; 2; ++i) &#123; maxi[x][i] = max(maxi[x][i], max(maxi[ch[x][0]][i], maxi[ch[x][1]][i])); mini[x][i] = min(mini[x][i], min(mini[ch[x][0]][i], mini[ch[x][1]][i])); &#125;&#125;void init(int x) &#123; for (int i = 0; i &lt; 2; ++i) mini[x][i] = maxi[x][i] = p[x].d[i];&#125;void build(int l, int r, int&amp; x) &#123; int mid = (l + r) &gt;&gt; 1; D ^= 1; nth_element(a + l, a + mid, a + r + 1, comp); x = a[mid]; init(x); if (l &lt; mid) build(l, mid - 1, ch[x][0]); if (r &gt; mid) build(mid + 1, r, ch[x][1]); pushup(x);&#125;lint sqr(lint a) &#123; return a * a;&#125;lint length(point u, point v) &#123; lint res = 0; for (int i = 0; i &lt; 2; ++i) res = res + sqr(u.d[i] - v.d[i]); return res;&#125;lint length(int u, point v) &#123; lint res = 0; for (int i = 0; i &lt; 2; ++i) res = res + max(sqr(v.d[i] - maxi[u][i]), sqr(v.d[i] - mini[u][i])); return res;&#125;void query(int u, point v) &#123; if (!u) return ; lint cur = length(p[u], v); if (cur &gt; q.top().d || (cur == q.top().d &amp;&amp; q.top().id &lt; p[u].id)) &#123; q.pop(); q.push(node(cur, p[u].id)); &#125; lint d[] = &#123;length(ch[u][0], v), length(ch[u][1], v)&#125;; int w = d[1] &gt;= d[0]; if (d[w] &gt;= q.top().d) query(ch[u][w], v); if (d[w ^ 1] &gt;= q.top().d) query(ch[u][w ^ 1], v);&#125;int main() &#123; memset(mini, INF, sizeof(mini)); n = read(); for (int i = 1; i &lt;= n; ++i) &#123; int x = read(), y = read(); p[i] = point(x, y, i); a[i] = i; &#125; D = 1; build(1, n, root); m = read(); while (m--) &#123; int x = read(), y = read(), k = read(); while (!q.empty()) q.pop(); for (int i = 1; i &lt;= k; ++i) q.push(node(-INF, 0)); query(root, point(x, y)); printf("%d\n", q.top().id); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>高级</category>
        <category>kd tree</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>堆</tag>
        <tag>kd tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FZOJ 189 - 森林]]></title>
    <url>%2F2019%2F03%2FFZOJ-189-%E6%A3%AE%E6%9E%97%2F</url>
    <content type="text"><![CDATA[显然是需要找一个“三叉戟”，就是两条不相交的链。 显然的，必定有一条是树的直径。 若他们都不是树的直径，那么有两种情况： 两条最多只有一条与直径相交，将一条链换成树的直径必然更优； 两条都与直径相交： 若都被直径所包含，显然换成直径更优，另随便找一条不与直径相交的链； 若只有部分包含，由于其不被包含的链不属于直径，一定没有直径上面的边优，那么应该将两条链合并成直径，剩余部分可以另行组成一条链，一定更优； 所以必然有一条是树的直径。 那么有两种方法，都是基于动态增量维护树的直径的： $\operatorname{LCT}$动态增量维护出直径，查询整棵树中不相交于直径，且最长的链的长度。 利用 $\operatorname{LCT}$ 和 $\operatorname{multiset}$ 可以维护之，时间复杂度 $O(n \log^2 n)$ 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#define INF 0x3f3f3f3f#define MAXN 400005using namespace std;int t, n, p, q;int ans;int fa[MAXN], ch[MAXN][2], size[MAXN];int maxl[MAXN], maxr[MAXN], maxi[MAXN];bool rev[MAXN];multiset&lt;int&gt; s[MAXN];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void reverse(int u) &#123; if (!u) return ; rev[u] ^= 1; swap(ch[u][0], ch[u][1]); swap(maxl[u], maxr[u]);&#125;void pushup(int);void pushdown(int u) &#123; if (rev[u]) &#123; reverse(ch[u][0]); reverse(ch[u][1]); rev[u] ^= 1; pushup(u); &#125;&#125;bool isroot(int u) &#123; return ch[fa[u]][0] != u &amp;&amp; ch[fa[u]][1] != u;&#125;int get(int u) &#123; return ch[fa[u]][1] == u;&#125;int get(multiset&lt;int&gt;&amp; s) &#123; return s.empty() ? 0 : *s.rbegin();&#125;void pushup(int u) &#123; pushdown(u); size[u] = size[ch[u][0]] + size[ch[u][1]] + 1; maxi[u] = max(get(s[u]), max(maxi[ch[u][0]], maxi[ch[u][1]])); maxl[u] = max(maxl[ch[u][0]], size[ch[u][0]] + max(maxl[ch[u][1]] + 1, get(s[u]))); maxr[u] = max(maxr[ch[u][1]], size[ch[u][1]] + max(maxr[ch[u][0]] + 1, get(s[u])));&#125;void rotate(int u) &#123; int v = fa[u], w = fa[v], c = get(u); if (!isroot(v)) ch[w][get(v)] = u; fa[u] = w; fa[v] = u; ch[v][c] = ch[u][c ^ 1]; if (ch[v][c]) fa[ch[v][c]] = v; ch[u][c ^ 1] = v; pushup(v); pushup(u);&#125;void down(int u) &#123; if (!isroot(u)) down(fa[u]); pushdown(u);&#125;void splay(int u) &#123; down(u); for (int f; !isroot(u); rotate(u)) if (!isroot(f = fa[u])) rotate(get(u) == get(f) ? f : u);&#125;void access(int u) &#123; for (int t = 0; u; t = u, u = fa[u]) &#123; splay(u); if (ch[u][1]) s[u].insert(maxl[ch[u][1]] + 1); ch[u][1] = t; if (ch[u][1]) s[u].erase(s[u].find(maxl[ch[u][1]] + 1)); pushup(u); &#125;&#125;void evert(int u) &#123; access(u); splay(u); reverse(u);&#125;void link(int u, int v) &#123; evert(u); evert(v); fa[u] = v; s[v].insert(maxl[u] + 1); pushup(v); pushdown(v);&#125;int query(int u, int v) &#123; evert(u); access(v); splay(v); return size[v] - 1;&#125;void append(int u, int v, int w) &#123; int a = query(u, v), b = query(u, w), c = query(v, w); if (b &gt; a) &#123; a = b; q = w; &#125; if (c &gt; a) p = w;&#125;int solve(int u, int v) &#123; evert(u); access(v); splay(v); return size[v] - 1 + max(maxi[v] - 1, 0);&#125;int main() &#123; t = read(); n = read(); p = q = 1; maxl[0] = maxr[0] = maxi[0] = -INF; pushup(1); for (int i = 1; i &lt; n; ++i) &#123; int u = read() ^ ans, v = i + 1; pushup(v); link(u, v); append(p, q, v); printf("%d\n", ans = solve(p, q)); &#125;&#125; 结论法名字很玄学，上面的性质不够，需要再推导一个结论：第三边只增不减。 尝试证明： 若增量的点构成一条新的直径： 若是与原直径组合，那么取原来的第三边一定不减。 若不是与原直径而是和等价类组合，显然原来的第三边最多是一条半径，那么选取原来的一条直径作为第三边即可，显然不减。 若增量的点不参与构成直径： 显然只增不减。 在程序中，我们可以动态增量维护直径，利用结论维护第三边，复杂度是优秀的 $O(n \log n)$ 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAXN 200010using namespace std;int t, n, ans;int p, q, third;int dep[MAXN], fa[MAXN][20];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;int LCA(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); for (int i = 19; i &gt;= 0; --i) if (dep[fa[u][i]] &gt;= dep[v]) u = fa[u][i]; if (u == v) return u; for (int i = 19; i &gt;= 0; --i) if (fa[u][i] != fa[v][i]) &#123; u = fa[u][i]; v = fa[v][i]; &#125; return fa[u][0];&#125;int query(int u, int v) &#123; return dep[u] + dep[v] - dep[LCA(u, v)] * 2;&#125;int query(int u, int v, int w) &#123; int a = LCA(u, w), b = LCA(v, w); if (a == b) return dep[w] + dep[LCA(u, v)] - dep[a] * 2; if (dep[a] &lt; dep[b]) return dep[w] - dep[b]; return dep[w] - dep[a];&#125;void append(int u, int v, int w) &#123; int a = query(u, v), b = query(u, w), c = query(v, w); if (a &lt; b) &#123; a = b; q = w; &#125; if (a &lt; c) p = w; if (p == u &amp;&amp; q == v) third = max(third, query(u, v, w)); else &#123; if (p == u &amp;&amp; LCA(w, v) != v) third = max(third, query(u, w, q)); if (q == v &amp;&amp; LCA(w, u) != u) third = max(third, query(v, w, p)); &#125;&#125;int main() &#123; t = read(); n = read(); p = q = 1; for (int i = 1; i &lt; n; ++i) &#123; int u = read() ^ ans, v = i + 1; fa[v][0] = u; dep[v] = dep[u] + 1; for (int j = 1; j &lt;= 19; ++j) fa[v][j] = fa[fa[v][j - 1]][j - 1]; append(p, q, v); printf("%d\n", ans = (query(p, q) + max(third - 1, 0))); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>高级</category>
        <category>LCT</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>思维题</tag>
        <tag>LCT</tag>
        <tag>树的直径</tag>
        <tag>动态增量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 3311 - [SDOI2014]数数]]></title>
    <url>%2F2019%2F03%2FLuogu-3311-SDOI2014-%E6%95%B0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[看到 $n$ 的范围，不难想到是数位 $\operatorname{DP}$ ，同时又因为其判断子串，不难想到是 $\operatorname{AC}$ 自动机。 那么把 $\operatorname{DP}$ 的过程当作是 $\operatorname{AC}$ 自动机上跑匹配的过程：匹配到了，则证明这个状态不可非法。 其余的就是常规的数位 $\operatorname{DP}$ 了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#define MAXN 1610typedef long long lint;using namespace std;const int mod = 1e9 + 7;int m, length;char s[MAXN], n[MAXN];int ch[MAXN][27], fail[MAXN], size[MAXN], total, root;int f[MAXN][MAXN];bool visit[MAXN][MAXN];bool match[MAXN];void insert(char* s) &#123; int n = strlen(s + 1), u = root; for (int i = 1; i &lt;= n; ++i) &#123; int c = s[i] - '0'; if (!ch[u][c]) ch[u][c] = ++total; u = ch[u][c]; &#125; match[u] = true;&#125;void build() &#123; queue&lt;int&gt; q; for (int i = 0; i &lt;= 9; ++i) if (ch[root][i]) q.push(ch[root][i]); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt;= 9; ++i) if (ch[u][i]) &#123; fail[ch[u][i]] = ch[fail[u]][i]; match[ch[u][i]] |= match[fail[ch[u][i]]]; q.push(ch[u][i]); &#125; else ch[u][i] = ch[fail[u]][i]; &#125;&#125;int DFS(int u, int l, bool isLimit, bool isZero) &#123; if (l == length + 1) return 1; if (!isLimit &amp;&amp; !isZero &amp;&amp; visit[u][l]) return f[u][l]; int limit = isLimit ? n[l] - '0' : 9; int val = 0; for (int i = 0; i &lt;= limit; ++i) &#123; if (isZero &amp;&amp; !i) val = (val + DFS(root, l + 1, isLimit &amp;&amp; i == limit, isZero &amp;&amp; !i)) % mod; else if (!match[ch[u][i]]) val = (val + DFS(ch[u][i], l + 1, isLimit &amp;&amp; i == limit, isZero &amp;&amp; !i)) % mod; &#125; if (!isZero &amp;&amp; !isLimit) &#123; f[u][l] = val; visit[u][l] = true; &#125; return val;&#125;void solve() &#123; printf("%d\n", DFS(root, 1, 1, 1) - 1);&#125;int main() &#123; scanf("%s%d", n + 1, &amp;m); length = strlen(n + 1); for (int i = 1; i &lt;= m; ++i) &#123; scanf("%s", s + 1); insert(s); &#125; build(); solve();&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>数位DP</category>
      </categories>
      <tags>
        <tag>数位DP</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FZOJ 182 - 定价]]></title>
    <url>%2F2019%2F02%2FFZOJ-182-%E5%AE%9A%E4%BB%B7%2F</url>
    <content type="text"><![CDATA[堆题果然一般都是思维题和细节题…… 这题其实就是一个进位题，只不过加了无数限制。 首先，进位可以表示为：从高往低，找到第一个不能为 $1$ 位，往前找到一个可以为 $1$ 并且此时不为 $1$ 的位，将其置为 $1$ ，将其后的位置为 $0$ 。 复杂度要求应该是 $O(nq \log n)$ 的，这就要求单次 $O(n \log n)$ 的查询复杂度，需要对上面进行优化。 不难发现此时不为 $1$ 的位是可以预处理出来的：对每一位必然存在多个可行区间，超过可行区间即不能再放 $1$ 。利用珂朵莉树维护这个区间，这里的珂朵莉树复杂度是严格 $O(q)$ 的。 那么开始模拟进位的过程，需要一个堆来维护每一位 $1$ 的可行区间。 维护出上一位的 $1$ 位； 查询当前位哪些必须从 $0$ 置 $1$ ，找到最高的那一位 $m$ ；将这些位置 $0$ ，且将他们从堆中删除； 往前找没有置 $1$ 且可以置 $1$ 的位，将其置 $1$ ，将其可行区间加入堆；否则无解； 继续下一位。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;#define MAXN 1010using namespace std;typedef set&lt;pair&lt;int, int&gt;&gt;::iterator it;typedef set&lt;int&gt;::iterator jt;typedef long long lint;const int mod = 1e9 + 7;unordered_map&lt;int, set&lt;pair&lt;int, int&gt;&gt;&gt; column;set&lt;int&gt; row[MAXN], bits;int n, m, q;struct heap &#123; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; p, q; void push(pair&lt;int, int&gt; x) &#123; p.push(x); &#125; void pop(pair&lt;int, int&gt; x) &#123; q.push(x); &#125; void clear() &#123; while (!q.empty()) q.pop(); while (!p.empty()) p.pop(); &#125; bool empty() &#123; return q.size() == p.size(); &#125; pair&lt;int, int&gt; top() &#123; while (!q.empty() &amp;&amp; p.top() == q.top()) &#123; q.pop(); p.pop(); &#125; return p.top(); &#125;&#125;candinates;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void unavailable(int r, int c) &#123; row[r].erase(c); it i = column[c].lower_bound(make_pair(r, 0)); if (i == column[c].end() || i -&gt; first != r) --i; int u = i -&gt; first, v = i -&gt; second; column[c].erase(i); if (u != r) column[c].insert(make_pair(u, r - 1)); if (v != r) column[c].insert(make_pair(r + 1, v));&#125;void available(int r, int c) &#123; row[r].insert(c); it i = column[c].lower_bound(make_pair(r, 0)); int u = r, v = r; if (i != column[c].begin()) &#123; it j = i; --j; while (j -&gt; second == u - 1) &#123; u = j -&gt; first; if (j == column[c].begin()) &#123; column[c].erase(j); break; &#125; column[c].erase(j--); &#125; &#125; it j = i; while (j != column[c].end() &amp;&amp; j -&gt; first == v + 1) &#123; v = j -&gt; second; column[c].erase(j++); &#125; column[c].insert(make_pair(u, v));&#125;lint power(lint a, int b) &#123; lint res = 1; while (b) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;int get(int r, int c) &#123; it i = column[c].lower_bound(make_pair(r, 0)); if (i == column[c].end() || i -&gt; first != r) --i; return i -&gt; second;&#125;lint solve() &#123; bits.clear(); candinates.clear(); lint sum = 0, ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; int maxi = 0; while (!candinates.empty() &amp;&amp; candinates.top().first &lt; i) &#123; maxi = max(maxi, candinates.top().second); candinates.pop(candinates.top()); &#125; bool isfail = false; while (true) &#123; jt j = row[i].upper_bound(maxi); if (j == row[i].end()) &#123; isfail = true; break; &#125; while(!bits.empty() &amp;&amp; *bits.begin() &lt; *j) &#123; int cur = *bits.begin(); sum = (sum - power(2, cur - 1) + mod) % mod; bits.erase(cur); int pos = get(i - 1, cur); if (pos != i - 1) candinates.pop(make_pair(pos, cur)); &#125; if (bits.empty() || *bits.begin() != *j) &#123; int cur = *j; sum = (sum + power(2, cur - 1)) % mod; bits.insert(cur); int pos = get(i, cur); candinates.push(make_pair(pos, cur)); break; &#125; else maxi = *j; &#125; if (isfail) return -1; ans = (ans + sum) % mod; &#125; return ans;&#125;int main() &#123; n = read(); m = read(); q = read(); while (q--) &#123; int opt = read(); if (opt == 1) &#123; int r = read(), c = read(); c = m - c + 1; if (row[r].count(c)) unavailable(r, c); else available(r, c); &#125; else printf("%lld\n", solve()); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>基础</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>堆</tag>
        <tag>珂朵莉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LOJ 2731 - 「JOISC 2016 Day 1」棋盘游戏]]></title>
    <url>%2F2019%2F02%2FLOJ-2731-%E3%80%8CJOISC-2016-Day-1%E3%80%8D%E6%A3%8B%E7%9B%98%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[一道十分麻烦的 $\operatorname{DP}$ 。 无解当且仅当第一行或第三行存在连续的两个空格子——当然首尾一定不能为空。 状态可以从左右或者是上下转移而来。 一三行的格子显然是可以任意时刻填的，中间的格子只能依靠别的进行转移，所以设计：$f_{i, j, 0/1}​$ 表示第 $i​$ 列，第二行的空格子是在第 $j​$ 个被填的（此时包含一三行的状态），$0​$ 表示依靠上下转移， $1​$ 表示依靠左右转移，即右边的空格子必须在其之前填或已填。 定义 $c$ 为当前列一三行空格子的数目，$s$ 为已填数，那么可以列出转移方程： \begin{align*} f_{i, j, 0} &= \operatorname{A}(j - 1, c) \times \sum \limits_{i = 1}^{s - c - 1} f_{i - 1, k, 0} + \operatorname{A}(j - 1, c) \times \sum \limits_{k = j - c - 1}^{s - c - 1}f_{i - 1, k, 1}\\ \end{align*}解释一下：第一项是之前上下转移的方案数，直接把一三行随便插到前面；第二项是之前靠左右转移的方案数，一三行依然是随便插，需要保证前面有足够空位； 当 $c = 1$ 时： f_{i, j, 1} = (s - j)\sum \limits_{k = 1}^{\min(j - 1, s - c - 1)}f_{i - 1, k, 0}即将一三行的格子随便插到前面。 当 $c = 2​$ 时： f_{i, j, 1} = A(s - j, 2)\sum \limits_{k = 1}^{\min(s - c - 1, j - 1)}f_{i - 1, k, 0} + (s - j) (j - 1)\sum \limits_{k = 1}^{\max(0, j - 2)}f_{i - 1, k, 0}前者是一三行全部放后面；后者是一三行一个放前，一个放后。这是为了重复计数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define MAXN 2005typedef long long lint;using namespace std;const int mod = 1e9 + 7;int sum, whole;int n, m;char board[4][MAXN];lint f[MAXN * 3][MAXN * 3][2];lint fac[MAXN * 3], inf[MAXN * 3], ans;lint power(lint a, int b) &#123; lint res = 1; while (b) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;void init(int n) &#123; inf[0] = fac[0] = 1; for (int i = 1; i &lt;= n; ++i) fac[i] = fac[i - 1] * i % mod; inf[n] = power(fac[n], mod - 2); for (int i = n - 1; i &gt;= 1; --i) inf[i] = inf[i + 1] * (i + 1) % mod;&#125;lint C(int n, int m) &#123; if (n &lt; m) return 0; return fac[n] * inf[m] % mod * inf[n - m] % mod;&#125;lint A(int n, int m) &#123; if (n &lt; m) return 0; return fac[n] * inf[n - m] % mod;&#125;void add(int i) &#123; for (int j = 1; j &lt;= sum; ++j) &#123; f[i][j][0] = (f[i][j][0] + f[i][j - 1][0]) % mod; f[i][j][1] = (f[i][j][1] + f[i][j - 1][1]) % mod; &#125;&#125;lint solve() &#123; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= 3; j += 2) if (board[j][i] == 'x' &amp;&amp; (i == 1 || i == n || board[j][i - 1] != 'o' || board[j][i + 1] != 'o')) return 0; if (board[2][1] == 'x') &#123; sum = f[1][1][0] = 1; if (board[2][2] == 'o' || n == 1) &#123; sum = 0; whole = 1; &#125; &#125; ans = 1; for (int i = 2; i &lt;= n; ++i) &#123; int cur = (board[1][i] == 'x') + (board[3][i] == 'x'); if (board[2][i] == 'o') &#123; whole += cur; ans = ans * fac[cur] % mod * C(whole, cur) % mod; continue; &#125; sum += cur + 1; for (int j = 1; j &lt;= sum; ++j) &#123; if (sum == cur + 1) &#123; if (j == sum) f[i][j][0] = fac[cur]; if (i &lt; n &amp;&amp; j != sum) f[i][j][1] = fac[cur]; continue; &#125; f[i][j][0] = (f[i][j][0] + A(j - 1, cur) * f[i - 1][sum - cur - 1][0] % mod) % mod; f[i][j][0] = (f[i][j][0] + A(j - 1, cur) * (f[i - 1][sum - cur - 1][1] - f[i - 1][max(j - cur - 1, 0)][1] + mod) % mod) % mod; if (i == n) continue; if (cur == 1) f[i][j][1] = (f[i][j][1] + f[i - 1][min(j - 1, sum - cur - 1)][0] % mod * (sum - j) % mod) % mod; if (cur == 2) &#123; f[i][j][1] = (f[i][j][1] + A(sum - j, 2) % mod * f[i - 1][min(j - 1, sum - cur - 1)][0] % mod) % mod; f[i][j][1] = (f[i][j][1] + fac[cur] * f[i - 1][max(0, j - cur)][0] % mod * (sum - j) % mod * (j - 1) % mod) % mod; &#125; &#125; if (i == n || board[2][i + 1] == 'o') &#123; whole += sum; lint res = 0; for (int j = 1; j &lt;= sum; ++j) &#123; res = (res + f[i][j][0]) % mod; if (i != n) res = (res + f[i][j][1]) % mod; &#125; ans = ans * res % mod * C(whole, sum) % mod; sum = 0; &#125; add(i); &#125; return ans;&#125;int main() &#123; scanf("%d", &amp;n); init(n * 3); for (int i = 1; i &lt;= 3; ++i) scanf("%s", board[i] + 1); printf("%lld\n", solve());&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>计数DP</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>solution</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 3451 - Normal]]></title>
    <url>%2F2019%2F02%2FBZOJ-3451-Normal%2F</url>
    <content type="text"><![CDATA[这是一道在数据结构上计算期望的题。 对于这种题一般有两种做法：一种是总大小除以总路径——这题显然不可取，另一种是直接计算期望。 考虑点分治的过程，复杂度其实就是在点分树上，每一个点的子树的大小之和。尝试给他列出式子，这里需要一个非常神仙的函数： \operatorname{anc}(u, v) = \begin{cases} 1 & \mbox{u是v的祖先} \\ 0 & \mbox{u不是v的祖先} \end{cases}只有 $2$ 种取值，再设概率函数 $\operatorname{E}(u, v)$ 表示 $u$ 是 $v$ 的祖先的期望。 那么答案显然为： \sum \limits_{i = 1}^n \sum \limits_{j = 1}^n \operatorname{E}(u, v)如何计算 $\operatorname{E}$ ？ 若对于一个点对 $u, v$ ，且 $u$ 是 $v$ 的祖先，那么 $E(u, v) = \frac{1}{\operatorname{dis}(u, v) + 1}$ 。 那么计算出分母即可，即统计不同点对距离的数量，点分治 $ + ​$ $\operatorname{FFT}​$ 即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#define MAXN 100010typedef long long lint;using namespace std;const double PI = acos(-1.0);int n;int head[MAXN], cnt, maxd = 0;int r[MAXN];int size[MAXN], maxi[MAXN], root, sum;int ans[MAXN];lint f[MAXN], g[MAXN];int s[MAXN], total = 0;bool visit[MAXN];struct data &#123; int next, to; data(int next = 0, int to = 0):next(next), to(to) &#123;&#125;&#125;edge[MAXN &lt;&lt; 1];struct complex &#123; double x, y; complex(double x = 0, double y = 0):x(x), y(y) &#123;&#125; complex operator + (const complex a) const &#123; return complex(x + a.x, y + a.y); &#125; complex operator - (const complex a) const &#123; return complex(x - a.x, y - a.y); &#125; complex operator * (const complex a) const &#123; return complex(x * a.x - y * a.y, x * a.y + y * a.x); &#125;&#125;self[MAXN], part[MAXN];void FFT(complex* a, int n, int type) &#123; for (int i = 0; i &lt; n; ++i) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int i = 1; i &lt; n; i &lt;&lt;= 1) &#123; complex wn(cos(PI / i), type * sin(PI / i)); for (int j = 0; j &lt; n; j += (i &lt;&lt; 1)) &#123; complex w(1, 0); for (int k = 0; k &lt; i; ++k) &#123; complex x = a[j + k], y = w * a[j + k + i]; a[j + k] = x + y; a[j + k + i] = x - y; w = w * wn; &#125; &#125; &#125;&#125;void connect(int u, int v) &#123; edge[++cnt] = data(head[u], v); head[u] = cnt;&#125;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void getroot(int u, int pre) &#123; size[u] = 1; maxi[u] = 0; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to; if (visit[v] || v == pre) continue; getroot(v, u); size[u] += size[v]; maxi[u] = max(maxi[u], size[v]); &#125; maxi[u] = max(maxi[u], sum - size[u]); if (maxi[root] &gt; maxi[u]) root = u;&#125;void DFS(int u, int pre, int d) &#123; s[++total] = d; maxd = max(maxd, d); for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to; if (v == pre || visit[v]) continue; DFS(v, u, d + 1); &#125;&#125;int init(int n) &#123; int limit = 1, size = 0; while (limit &lt;= n) &#123; limit &lt;&lt;= 1; ++size; &#125; for (int i = 0; i &lt; limit; ++i) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (size - 1)); return limit;&#125;void add() &#123; int limit = init(maxd &lt;&lt; 1); for (int i = 0; i &lt; limit; ++i) &#123; self[i] = part[i] = complex(); self[i].x = f[i]; &#125; for (int i = 1; i &lt;= total; ++i) part[s[i]].x += 1; FFT(part, limit, 1); FFT(self, limit, 1); for (int i = 0; i &lt; limit; ++i) self[i] = self[i] * part[i]; FFT(self, limit, -1); for (int i = 0; i &lt; limit; ++i) ans[i] += lint(self[i].x / limit + 0.5); for (int i = 1; i &lt;= total; ++i) ++f[s[i]]; total = 0;&#125;void solve(int u) &#123; visit[u] = true; maxd = 0; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to; if (visit[v]) continue; DFS(v, u, 1); add(); &#125; int limit = init(maxd); for (int i = 0; i &lt; limit; ++i) &#123; ans[i] += f[i]; f[i] = 0; &#125; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to; if (visit[v]) continue; sum = size[v]; root = 0; getroot(v, 0); solve(root); &#125;&#125;int main() &#123; n = read(); for (int i = 1; i &lt; n; ++i) &#123; int u = read() + 1, v = read() + 1; connect(u, v); connect(v, u); &#125; sum = maxi[0] = n; getroot(1, 0); solve(root); double res = 0; for (int i = 1; i &lt;= n; ++i) res = res + ((double)ans[i] / (double)(i + 1)); printf("%.4f\n", n + 2 * res);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>期望</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>期望</tag>
        <tag>FFT</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FZOJ 4055 - password]]></title>
    <url>%2F2019%2F02%2FFZOJ-4055-password%2F</url>
    <content type="text"></content>
      <tags>
        <tag>solution</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 500F - New Year Shopping]]></title>
    <url>%2F2019%2F02%2FCodeforces-500F-New-Year-Shopping%2F</url>
    <content type="text"><![CDATA[一道很有意思的 $\operatorname{DP}$ 。 显然是做 $01$ 背包，但是有区间限定范围，显然得针对每一次询问重新做，复杂度无法接受。 但是任意种商品上架时间都是恒定的，若将商品看作一个点，可以理解成：查询 $(a_i - p, a_i]$ 中的点作 $01$ 背包。 对于查询固定长度区间的问题，有一种通用的做法：将物品按时间分类，$t \in [(i - 1)\frac{l}{p}, i \frac{l}{p}]$ 属于同一类，$\frac{l}{p}$ 为关键点，那么每一次查询必然经过一个关键点。 对于一个关键点，分别向左向右记录到 $1 \sim p$ 个位置的 $01$ 背包，每次从上一位转移。统计答案时，找到合法区间，以关键点为中心，分割成左右两块，枚举给左边的钱数，求最大值即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAXN 4050using namespace std;const int C = 4000;int n, p, m;int pre[MAXN][MAXN], suf[MAXN][MAXN];struct data &#123; int cost, value, time, id; bool operator &lt; (const data b) const &#123; return time &lt; b.time; &#125;&#125;a[MAXN];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void build() &#123; for (int i = 1; i &lt;= n; ++i) if (a[i].id != a[i - 1].id) &#123; for (int j = C; j &gt;= a[i].cost; --j) pre[i][j] = a[i].value; &#125; else &#123; memcpy(pre[i], pre[i - 1], sizeof(pre[i])); for (int j = C; j &gt;= a[i].cost; --j) pre[i][j] = max(pre[i][j], pre[i - 1][j - a[i].cost] + a[i].value); &#125; for (int i = n; i &gt;= 1; --i) if (a[i].id != a[i + 1].id) &#123; for (int j = C; j &gt;= a[i].cost; --j) suf[i][j] = a[i].value; &#125; else &#123; memcpy(suf[i], suf[i + 1], sizeof(suf[i])); for (int j = C; j &gt;= a[i].cost; --j) suf[i][j] = max(suf[i][j], suf[i + 1][j - a[i].cost] + a[i].value); &#125;&#125;int main() &#123; n = read(); p = read(); for (int i = 1; i &lt;= n; ++i) &#123; a[i].cost = read(); a[i].value = read(); a[i].id = (a[i].time = read()) / p + 1; &#125; sort(a + 1, a + n + 1); build(); m = read(); while (m--) &#123; int cur = read(), cash = read(), ans = 0, l = 0, r = 0; for (int i = 1; i &lt;= n; ++i) if (a[i].time &lt;= cur &amp;&amp; a[i].time + p &gt; cur) &#123; if (!l) l = i; r = i; &#125; if (a[l].id == a[r].id) &#123; if (r &lt; n &amp;&amp; a[r].id == a[r + 1].id) l = 0; else r = 0; &#125; for (int i = 0; i &lt;= cash; ++i) ans = max(ans, suf[l][i] + pre[r][cash - i]); printf("%d\n", ans); &#125;&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>背包</category>
        <category>01背包</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>01背包</tag>
        <tag>定区间划分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 995F - Cowmpany Cowmpensation]]></title>
    <url>%2F2019%2F02%2FCodeforces-995F-Cowmpany-Cowmpensation%2F</url>
    <content type="text"><![CDATA[首先这题应该是有两个解法的： 容斥 $\operatorname{DP}$容斥 $\operatorname{DP}$ 特指一些需要排列组合 $+$ 容斥原理的 $\operatorname{DP}$ ，属于特殊的计数 $\operatorname{DP}$ ，这题应该归纳于这个范畴。 这一类 $\operatorname{DP}$ 具有一定显著的特征：首先设计一个状态 $A$ ，表示至少如何如何；接着设计另外一个状态 $B$ ，表示恰好如何如何，符合题目要求。同时，$A$ 应该是易于求出的，$B$ 应该是可以被 $A$ 表达的。 利用这个思路，设计该题 $\operatorname{DP}$ 。 首先应该注意到本题是一个堆，本质是堆的计数，能够 $O(\log n)$ 求解。但是由于限定权值范围为 $1e 9$ ，所以只能 $O(n^2)$ 求解，设计状态 $f_{i, j}$ 表示以 $i$ 为根的子树，最大标号是 $j$ ，那么： \begin{align*} f_{u, i} = \prod_v\sum \limits_{j = 1}^i f_{v, j} \end{align*}这是由于已经确定了最大标号，自然，子树的标号只要小于等于其即可。 再设计 $g_i​$ 表示以 $1​$ 为根，最大标号为 $i​$ 且标号种类为 $i​$ 的方案数，如果统计出，答案为： ans = \sum \limits_{i = 1}^n g_i \times \begin{pmatrix} n \\ i\end{pmatrix}考虑如何用 $f$ 表示 $g$ 。由于 $f_{1, i}$ 表示的颜色最多只有 $i$ 种，所以需要容斥减去小于 $i$ 种的情况，不难发现满足的情况都是只有 $i$ 种颜色，且所有颜色统一被替换成较大的颜色才能满足，所以： g_i = f_{1, i} - \sum \limits_{j = 1}^{j - 1}g_j \times \begin{pmatrix} i \\ j \end{pmatrix}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAXN 3050typedef long long lint;using namespace std;const int mod = 1e9 + 7;int n, d;int head[MAXN], cnt;lint f[MAXN][MAXN], h[MAXN][MAXN], g[MAXN];lint C[MAXN][MAXN];struct data &#123; int next, to; data(int next = 0, int to = 0):next(next), to(to) &#123;&#125;&#125;edge[MAXN &lt;&lt; 1];void connect(int u, int v) &#123; edge[++cnt] = data(head[u], v); head[u] = cnt;&#125;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;lint power(lint a, int b) &#123; lint res = 1; while (b) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;void DFS(int u, int pre) &#123; for (int i = 1; i &lt;= n; ++i) f[u][i] = 1; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to; if (v == pre) continue; DFS(v, u); for (int j = 1; j &lt;= n; ++j) f[u][j] = f[u][j] * f[v][j] % mod; &#125; for (int i = 1; i &lt;= n; ++i) f[u][i] = f[u][i - 1] + f[u][i];&#125;void init() &#123; C[0][0] = 1; for (int i = 1; i &lt;= n; ++i) C[i][0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= i; ++j) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;&#125;lint c(int n, int m) &#123; lint res = 1; for (int i = n; i &gt;= n - m + 1; --i) res = res * i % mod; for (int i = 1; i &lt;= m; ++i) res = res * power(i, mod - 2) % mod; return res;&#125;int solve() &#123; DFS(1, 0); init(); for (int i = 1; i &lt;= n; ++i) &#123; g[i] = f[1][i]; for (int j = 1; j &lt; i; ++j) g[i] = (g[i] - g[j] * C[i][j] % mod) % mod; &#125; lint ans = 0; for (int i = 1; i &lt;= min(d, n); ++i) ans = (ans + c(d, i) * g[i] % mod) % mod; return ans % mod;&#125;int main() &#123; n = read(); d = read(); for (int i = 2; i &lt;= n; ++i) &#123; int f = read(); connect(f, i); &#125; int ans = solve(); printf("%d\n", ans);&#125; 拉格朗日插值可以很轻松地求出 $f_1 \sim f_n$ ，题目要求 $f_d$ ，利用拉格朗日插值可以在 $O(n)$ 时间内求出。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define MAXN 3050typedef long long lint;using namespace std;const int mod = 1e9 + 7;int n, d;int head[MAXN], cnt;lint f[MAXN][MAXN];struct data &#123; int next, to; data(int next = 0, int to = 0):next(next), to(to) &#123;&#125;&#125;edge[MAXN &lt;&lt; 1];void connect(int u, int v) &#123; edge[++cnt] = data(head[u], v); head[u] = cnt;&#125;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void DFS(int u, int pre) &#123; for (int i = 1; i &lt;= n; ++i) f[u][i] = 1; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to; if (v == pre) continue; DFS(v, u); for (int j = 1; j &lt;= n; ++j) f[u][j] = f[u][j] * f[v][j] % mod; &#125; for (int i = 1; i &lt;= n; ++i) f[u][i] = (f[u][i - 1] + f[u][i]) % mod;&#125;lint power(lint a, int b) &#123; lint res = 1; while (b) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;int solve() &#123; DFS(1, 0); lint res = 0, val = 1; if (d &lt;= n) return (int)f[1][d]; for (int i = 1; i &lt;= n; ++i) val = val * power(i, mod - 2) % mod * (d - i) % mod; for (int i = 0; i &lt;= n; ++i) &#123; res = (res + ((n - i) &amp; 1 ? -1 : 1) * f[1][i] * val % mod + mod) % mod; val = val * (d - i) % mod * power(d - i - 1, mod - 2) % mod * (n - i) % mod * power(i + 1, mod - 2) % mod; &#125; return (int)res;&#125;int main() &#123; n = read(); d = read(); for (int i = 2; i &lt;= n; ++i) &#123; int f = read(); connect(f, i); &#125; int ans = solve(); printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>计数DP</category>
        <category>容斥DP</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>solution</tag>
        <tag>计数</tag>
        <tag>拉格朗日插值</tag>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[HDU 3472 - HS BDC]]></title>
    <url>%2F2019%2F02%2FHDU-3472-HS-BDC%2F</url>
    <content type="text"><![CDATA[显然是一道欧拉路径问题，不一样的是可以将字符串反转。 考虑建图，那么就是一条边可以随意定向，是一个混合图求欧拉路径的问题。 有一种解法：先将边随意定向，求出每一个点 $d_i = outdegree_i - indegree_i$ 。一条边 $(u, v)$ 更改方向，对于 $u$ 和 $v$ 的 $d$ 的奇偶性都不会进行改变。这恰好符合欧拉路径的判定问题：只有两个点度数为 $1$ ，其余点度数为 $0$ 。 对于欧拉路径，我们已经可以找到起点和终点 $s, t$ ，连边 $(s, t)$ ，便可以转化成欧拉回路问题。 显然对于 $d_i &gt; 0$ 的点，我们需要使其降为 $0$ ， $d_i &lt; 0$ 的点，使其升为 $0$ 。 那么应该这么建图： 对于 $d_i &gt; 0​$ ，连 $(S, i, \frac{d_i}{2})​$ 对于 $d_i &lt; 0$ ，连 $(i, T, \frac{-d_i}{2})$ 对于一条随意定向边 $(u, v)$ ，连 $(u, v, 1)$ 跑一遍最大流，若满流则有解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#define MAXN 205#define MAXM 1005#define MAXA 25#define INF 0x3f3f3f3fusing namespace std;int t, n, m;int kase = 0;int S, T;char str[MAXN];int head[MAXN], cnt;int d[MAXN], deg[MAXN], fa[MAXN], s;bool visit[MAXN];struct data &#123; int next, to, flow; data(int next = 0, int to = 0, int flow = 0):next(next), to(to), flow(flow) &#123;&#125;&#125;edge[(MAXN + MAXM) &lt;&lt; 1];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;int find(int x) &#123; return x == fa[x] ? x : fa[x] = find(fa[x]);&#125;void connect(int u, int v, int w) &#123; edge[++cnt] = data(head[u], v, w); head[u] = cnt; edge[++cnt] = data(head[v], u, 0); head[v] = cnt;&#125;void init() &#123; memset(head, 0, sizeof(head)); memset(visit, 0, sizeof(visit)); cnt = 1; s = 0; for (int i = 1; i &lt;= n; ++i) &#123; fa[i] = i; deg[i] = 0; &#125;&#125;bool BFS() &#123; queue&lt;int&gt; q; q.push(S); memset(d, 0, sizeof(d)); d[S] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to, f = edge[i].flow; if (d[v] || !f) continue; d[v] = d[u] + 1; if (v == T) return true; q.push(v); &#125; &#125; return false;&#125;int update(int u, int f) &#123; if (u == T) return f; int r = f; for (int i = head[u]; i &amp;&amp; r; i = edge[i].next) &#123; int v = edge[i].to, f = edge[i].flow; if (d[v] != d[u] + 1 || !f) continue; int k = update(v, min(r, f)); if (!k) d[v] = -1; edge[i].flow -= k; edge[i ^ 1].flow += k; r -= k; &#125; return f - r;&#125;int dinic() &#123; int flow = 0, cur = 0; while (BFS()) while ((cur = update(S, INF))) flow += cur; return flow;&#125;int calc() &#123; int sum = 0; for (int i = 1; i &lt;= n; ++i) if (abs(deg[i]) &amp; 1) ++sum; return sum;&#125;bool isconnect() &#123; for (int i = 1; i &lt;= n; ++i) if (visit[i]) for (int j = 1; j &lt;= n; ++j) if (visit[j] &amp;&amp; find(i) != find(j)) return false; return true;&#125;int main() &#123; t = read(); while (t--) &#123; m = read(); n = 26; init(); for (int i = 1; i &lt;= m; ++i) &#123; scanf("%s", str + 1); int u = str[1] - 'a' + 1, v = str[strlen(str + 1)] - 'a' + 1, d = read(), fu = find(u), fv = find(v); ++deg[u]; --deg[v]; visit[u] = true; visit[v] = true; if (fu != fv) fa[fu] = fv; if (d) connect(u, v, 1); &#125; int t = calc(); printf("Case %d: ", ++kase); if (!isconnect() || t &gt; 2 || t == 1) &#123; puts("Poor boy!"); continue; &#125; S = n + 1; T = S + 1; if (t == 2) &#123; int u = 0, v = 0; for (int i = 1; i &lt;= n; ++i) if (abs(deg[i]) &amp; 1) (deg[i] &gt; 0 ? u : v) = i; ++deg[u]; --deg[v]; connect(u, v, 1); &#125; int sum = 0; for (int i = 1; i &lt;= n; ++i) if (deg[i] &gt; 0) &#123; connect(S, i, deg[i] / 2); sum += deg[i] / 2; &#125; else if (deg[i] &lt; 0) connect(i, T, -deg[i] / 2); if (dinic() == sum) puts("Well done!"); else puts("Poor boy!"); &#125;&#125;]]></content>
      <categories>
        <category>网络流</category>
        <category>最大流</category>
        <category>混合图欧拉路径</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>网络最大流</tag>
        <tag>混合图欧拉路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 3680 - Intervals]]></title>
    <url>%2F2019%2F02%2FPOJ-3680-Intervals%2F</url>
    <content type="text"><![CDATA[区间 $K$ 覆盖指的是给定一些区间 $[a_i, b_i]$ ，有权值 $w_i$ ，要求每一个点不能被覆盖超过 $k$ 次，求最大权值。 考虑这么建图：$(i, i + 1, \infty, 1) \cap (a_i, b_i, 1, w_i)\cap(S, 1, k, 0) \cap (n, T, k, 0)$，第三项指容量，第四项指边权。 若每一个点被覆盖超过 $k$ 次，那么必然存在一条边其容量大于 $k$ ，由于源点的流量限制不可能成立。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 405#define INF 0x3f3f3f3fusing namespace std;int t, n, m, k;int S, T;int head[MAXN], cnt, sorted[MAXN];int d[MAXN], cap[MAXN], pre[MAXN];bool inq[MAXN];struct node &#123; int u, v, w;&#125;a[MAXN];struct data &#123; int next, to, flow, cost; data(int next = 0, int to = 0, int flow = 0, int cost = 0):next(next), to(to), flow(flow), cost(cost) &#123;&#125;&#125;edge[MAXN * MAXN * 2];void connect(int u, int v, int f, int w) &#123; edge[++cnt] = data(head[u], v, f, w); head[u] = cnt; edge[++cnt] = data(head[v], u, 0, -w); head[v] = cnt;&#125;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void init() &#123; memset(head, 0, sizeof(head)); cnt = 1;&#125;bool SPFA() &#123; queue&lt;int&gt; q; q.push(S); memset(d, INF, sizeof(d)); d[S] = 0; cap[S] = INF; while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = false; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to, w = edge[i].cost, f = edge[i].flow; if (d[v] &gt; d[u] + w &amp;&amp; f) &#123; d[v] = d[u] + w; pre[v] = i; cap[v] = min(cap[u], f); if (!inq[v]) &#123; inq[v] = true; q.push(v); &#125; &#125; &#125; &#125; return d[T] != INF;&#125;int update() &#123; int u = T; while (u != S) &#123; int i = pre[u]; edge[i].flow -= cap[T]; edge[i ^ 1].flow += cap[T]; u = edge[i ^ 1].to; &#125; return d[T] * cap[T];&#125;int EK() &#123; int cost = 0; while (SPFA()) cost += update(); return cost;&#125;int main() &#123; t = read(); while (t--) &#123; init(); m = read(); k = read(); for (int i = 1; i &lt;= m; ++i) &#123; sorted[i * 2] = a[i].u = read(); sorted[i * 2 - 1] = a[i].v = read(); a[i].w = read(); &#125; sort(sorted + 1, sorted + m * 2 + 1); n = int(unique(sorted + 1, sorted + m * 2 + 1) - sorted) - 1; for (int i = 1; i &lt;= m; ++i) &#123; int u = (int)(lower_bound(sorted + 1, sorted + n + 1, a[i].u) - sorted), v = (int)(lower_bound(sorted + 1, sorted + n + 1, a[i].v) - sorted), w = a[i].w; connect(u, v, 1, -w); &#125; S = n + 1; T = S + 1; connect(S, 1, k, 0); for (int i = 1; i &lt; n; ++i) connect(i, i + 1, INF, 0); connect(n, T, k, 0); printf("%d\n", -EK()); &#125;&#125;]]></content>
      <categories>
        <category>网络流</category>
        <category>最大流</category>
        <category>区间K覆盖</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>网络最大流</tag>
        <tag>区间K覆盖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 925C - Big Secret]]></title>
    <url>%2F2019%2F02%2FCodeforces-925C-Big-Secret%2F</url>
    <content type="text"><![CDATA[异或一般是需要按位处理的，考虑异或前缀和 $x$ 与当前数 $a_i$ ，单调递增的条件是： a_i \oplus x > x设最高位为 $t$ ，其编号为 $s$ 。那么对于每个 $a_i$ 的第 $t$ 位 ，显然只能有 $1$ 个 $1$ ，否则不成立；对于次高位 $t - 1$ ，若 $a_s$ 的 $t - 1$ 位为 $1$ ，那么次高位总共可以有 $3$ 个 $1$ ，不考虑 $a_s$ 则可以有 $2$ 个 $1$ 。 形式化的，我们可以得到规律： 对于最高位不是当前位的数，若当前位为 $1$ 的个数为 $x$ ，那么可以以当前为作为最高位的个数为 $x + 1$ 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;#define MAXN 100005#define MAXD 61typedef long long lint;using namespace std;bool visit[MAXN];int n, m;vector&lt;lint&gt; g[MAXN];const int d = 60;lint a[MAXN], b[MAXN], ans;lint read() &#123; char c = getchar(); lint x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;int main() &#123; n = (int)read(); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = read(); for (int j = d - 1; j &gt;= 0; --j) if (a[i] &gt;&gt; j &amp; 1) &#123; g[j].push_back(a[i]); break; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; bool issolve = false; for (int j = 0; j &lt; d; ++j) &#123; if (ans &gt;&gt; j &amp; 1 || g[j].empty()) continue; issolve = true; ans ^= g[j].back(); b[i] = g[j].back(); g[j].pop_back(); break; &#125; if (!issolve) &#123; puts("No"); return 0; &#125; &#125; puts("Yes"); for (int i = 1; i &lt;= n; ++i) printf("%lld ", b[i]);&#125;]]></content>
      <categories>
        <category>思维</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>贪心</tag>
        <tag>异或</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大权闭合子图]]></title>
    <url>%2F2019%2F02%2F%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[最大权闭合子图是网络流的一种经典模型。 定义割割 $(S, T)$ 是一种点的划分方式，满足一定不存在 $u \in S, v \in T, (u, v)$。 闭合子图对于一个有向图，选出一个点集 $V$ ，使得所有节点的后续节点依然属于 $V$ 。 下图是一个闭合子图。 最大权闭合子图对于一个有向图，其节点有权值。对于该有向图的所有闭合子图，其权值之和被称作最大权闭合子图。 与网络流的转化对于一般的图来说：首先建立源点 $s$ 和汇点 $t$，将源点 $s$ 与所有权值为正的点相连，容量为权值；将所有权值为负的点与汇点 $t$ 相连，容量为权值的绝对值；权值为 $0$ 的点不做处理；同时将原来的边容量设置为 $\infty$ 。 下图为一实例： 结论最大权闭合子图的权值等于所有正权点之和减去最小割。 证明首先证明两个引理： 引理 $1$最小割一定是简单割。 证明简单割指的是割 $(S, T)$ 的每一条割边都与源点或汇点相连。 由于该图的特殊性，只有与源点相连或与汇点相连的边不为 $\infty$ ，所以任意包含 $\infty$ 一定不是最小割，所以最小割一定是简单割。 引理 $2$简单割与闭合子图对应。 证明闭合子图 $V$ 中的点和源点构成 $S$ ，其余点和汇点构成 $T$ 。 反证法，证明闭合子图是简单割：若不是，则有一条边 $(u, v), u \in S, v \in T, c(u, v) = \infty$ ，显然不成立。 同样地，证明简单割是闭合子图：若不是，则有一条边 $(u, v),u\in S, v \in T, c(u, v) = \infty $ ，显然不成立。 定理最小割是最大权的闭合子图。 割的容量 $C(S, T) = $ $T$ 中所有正权点的权值之和 $+$ $S$ 中所有负权点的权值绝对值之和。 闭合子图的权值 $W = $ $S$ 中所有正权点的权值之和 $-$ $S$ 中所有负权点的权值绝对值之和。 那么：$C(S,T)+W=​$ $T​$ 中所有正权点的权值之和 $+​$ $S​$ 中所有正权点的权值之和 $=​$ 所有正权点的权值之和。 于是：$W = C(S, T) - $ 所有正权点的权值之和。]]></content>
      <categories>
        <category>网络流</category>
        <category>最大流</category>
        <category>最大权闭合子图</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>网络最大流</tag>
        <tag>最大权闭合子图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[??? - [FOI2019]排序]]></title>
    <url>%2F2019%2F02%2FFOI2019-%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>数据结构</category>
        <category>基础</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[势能分析]]></title>
    <url>%2F2019%2F02%2F%E5%8A%BF%E8%83%BD%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[势能法将数据结构和势能关联起来——对于一个初始化的数据结构 $D_0$ 执行 $n$ 个操作， $c_i$ 为 $n$ 个操作的实际代价， $D_i$ 为 $i$ 此操作之后的数据结构。势函数 $\phi$ 将每个数据结构 $D_i$ 映射到一个实数 $\phi(D_i)$ ，为 $D_i$ 的势。 定义第 $i$ 个操作的摊还代价用势函数定义为： \hat{c_i} = c_i + \phi(D_i) - \phi(D_{i - 1}) \tag{1}意即：每个操作的摊还代价为实际代价加上操作引起的势变化。所以总摊还代价为： \begin{align*} & \sum \limits_{i = 1}^n \hat{c_i} \\ = & \sum \limits_{i = 1}^n (c_i + \phi(D_i) - \phi(D_{i - 1})) \\ = & \sum \limits_{i = 1}^n c_i + \phi(D_n) - \phi(D_0) \tag{2} \end{align*}根据 $(1)$ 能得到每个步骤的摊还代价， $(2)$ 能算出总实际代价的上界或下界：$\phi(D_n) - \phi(D_0)$ 正为上，负为下。 实例对于一个势能分析，选取一个正确的势函数至关重要。 栈定义 $\phi$ 为当前栈中的数据量。 $\operatorname{PUSH}$ 压入一个对象，势差为 $1$ ，实际代价为 $1$ ，摊还代价为 $2$ 。 $\operatorname{POP}$ 弹出 $x$ 个对象，势差为 $-x$ ，实际代价为 $x$ ，摊还代价为 $0$ 。 所以每一个操作的摊还代价都是 $O(1)$ ，所以 $n$ 个操作的总代价为上界 $O(n)$ 。 均摊复杂度为 $\frac{O(n)}{n} = O(1)$ $\operatorname{Splay}$分析栈没有意思，分析一下 $\operatorname{Splay}​$ 。 定义势能 $\phi(u)$ 为 $u$ 在当前树中的子树大小取对数，即：$r(u) = \log s_u$ ： \phi = \sum \limits_u r(u)首先： T = \sum \limits_{i = 1}^m c_i + \phi(D_m) - \phi(D_0)显然 $\phi \in [0, n \log n]$ ，则： \phi(D_m) - \phi(D_0) \leq O(n \log n)后者上界已然求出，现在需要求出 $c_i$ 的上界，尝试对 $c_i$ 也进行势能分析。 $\operatorname{Zig}$即 $u$ 旋转到父亲 $v$ ： \begin{align*} & 1 + r'(u) - r(u) + r'(v) - r(v) \\ = & 1 + r'(v) - r(u) \\ \leq & 1 + r'(u) - r(u) \end{align*}$\operatorname{ZigZig}$即将 $u$ 往上同方向旋转两层至 $w$ ： \begin{align*} & 2 + r'(u) + r'(v) + r'(w) - r(u) - r(v) - r(w) \\ = & 2 + r'(v) + r'(w) - r(u) - r(v) \\ \leq & 2 + r'(u) + r'(w) - 2r(u) \\ \end{align*}由于： \begin{align*} & r(u) + r'(w) - 2r'(u) \\ = & \log(\frac{s_u}{s'_u}) + log(\frac{s'_w}{s'_u}) \\ \leq& -2 \end{align*}所以： \begin{align*} & 2 + r'(u) + r'(v) + r'(w) - r(u) - r(v) - r(w) \\ \leq & 3(r'(u) - r(u)) \\ \end{align*}$\operatorname{ZigZag}$即将 $u$ 往上不同方向旋转两层至 $w​$ ： \begin{align*} & 2 + r'(u) + r'(v) + r'(w) - r(u) - r(v) - r(w) \\ = & 2 + r'(v) + r'(w) - r(u) - r(v) \\ \leq & 2 + r'(v) + r'(w) - 2r(u) \\ \end{align*}由于： \begin{align*} & r'(v) + r'(w) - 2r'(u) \\ = & \log(\frac{s'_v}{s'_u}) + log(\frac{s'_w}{s'_u}) \\ \leq& -2 \end{align*}所以： \begin{align*} & 2 + r'(u) + r'(v) + r'(w) - r(u) - r(v) - r(w) \\ = & 2(r'(u) - r(u)) \end{align*}合并分析那么可以得到以下三种情况的均摊复杂度： 状态 复杂度 单旋 $1 + r’(u) - \phi(u)$ 正旋正旋 $3(r’(u) - \phi(u))$ 正旋逆旋 $2(r’(u) - \phi(u))$ 那么根据 $(1)$ ，均摊复杂度： \begin{align*} \phi & = 1 + 3(r(\operatorname{root}) - r(u)) \\ & = O(\log(\frac{n}{s_u})) \end{align*}$n$ 个节点，$m$ 此操作的总复杂度为： O(n \log n + m \log n)所以，一般将当前点旋到根以保证复杂度，维持势能函数不变。]]></content>
      <categories>
        <category>数学</category>
        <category>复杂度</category>
      </categories>
      <tags>
        <tag>势能</tag>
        <tag>复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 4069 - [SDOI2016]游戏]]></title>
    <url>%2F2019%2F02%2FLuogu-4069-SDOI2016-%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[对于 $\operatorname{Alice}$ 的操作，发现是在一条直线上取一些点。对于一条路径 $u \rightarrow w \rightarrow v$ ，考虑分情况讨论 -]]></content>
      <categories>
        <category>数据结构</category>
        <category>基础</category>
        <category>线段树</category>
        <category>李超线段树</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
        <tag>李超线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 4097 - [HEOI2013]Segment]]></title>
    <url>%2F2019%2F02%2FLuogu-4097-HEOI2013-Segment%2F</url>
    <content type="text"><![CDATA[这题可以看作李超线段树的模版题，并不是特别难的一个东西，基于线段树标记永久化。 具体用来解决这样一类问题：给定一个二维平面以及几条线段，求所有线段与 $x = k$ 交点 $y$ 的最大值或最小值。 最小值与最大值同理，暂且先考虑最大值： 可见 $y$ 越大交点一定越高，也就意味着这一条线段有一部分暴露在外面。 考虑利用线段树维护一个区间的最优势线段，即暴露最多的线段。 由于目标线段一定暴露，查询的时候必然有一个线段树区间的最优势线段为目标，利用标记永久化，将线段树上根到底的路径全部统计答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define MAXN 100005using namespace std;const int mod = 39989, INF = 1e9;const double eps = 1e-7;int n, m;struct line &#123; double k, b; int tag; line(double k = 0, double b = 0, int tag = 0):k(k), b(b), tag(tag) &#123;&#125; double calc(int x) &#123; return k * x + b; &#125;&#125;;struct segment &#123; int l, r; line a; bool isable;&#125;t[MAXN &lt;&lt; 2];void pushdown(int x, line a) &#123; if (!t[x].isable) &#123; t[x].isable = true; t[x].a = a; return ; &#125; double l1 = t[x].a.calc(t[x].l), r1 = t[x].a.calc(t[x].r), l2 = a.calc(t[x].l), r2 = a.calc(t[x].r); if (l2 &lt;= l1 &amp;&amp; r2 &lt;= r1) return ; if (l2 &gt;= l1 &amp;&amp; r2 &gt;= r1) &#123; t[x].a = a; return ; &#125; double cross = (a.b - t[x].a.b) / (t[x].a.k - a.k); int mid = (t[x].l + t[x].r) &gt;&gt; 1; if (cross &lt;= mid) pushdown(x &lt;&lt; 1, r1 &gt; r2 ? a : t[x].a); else pushdown(x &lt;&lt; 1 | 1, l1 &gt; l2 ? a : t[x].a); if ((l1 &lt; l2 &amp;&amp; cross &gt; mid) || (r1 &lt; r2 &amp;&amp; cross &lt;= mid)) t[x].a = a;&#125;void build(int l, int r, int x = 1) &#123; t[x].l = l; t[x].r = r; t[x].isable = false; if (l == r) return ; int mid = (l + r) &gt;&gt; 1; build(l, mid, x &lt;&lt; 1); build(mid + 1, r, x &lt;&lt; 1 | 1);&#125;void insert(int l, int r, line a, int x = 1) &#123; if (l &lt;= t[x].l &amp;&amp; t[x].r &lt;= r) &#123; pushdown(x, a); return ; &#125; int mid = (t[x].l + t[x].r) &gt;&gt; 1; if (l &lt;= mid) insert(l, r, a, x &lt;&lt; 1); if (r &gt; mid) insert(l, r, a, x &lt;&lt; 1 | 1);&#125;line query(int p, int x = 1) &#123; if (t[x].l == t[x].r) return t[x].a; int mid = (t[x].l + t[x].r) &gt;&gt; 1; line res; if (p &lt;= mid) res = query(p, x &lt;&lt; 1); else res = query(p, x &lt;&lt; 1 | 1); if (!t[x].isable) return res; if (!res.tag || res.calc(p) &lt; t[x].a.calc(p) || (fabs(res.calc(p) - t[x].a.calc(p)) &lt; eps &amp;&amp; t[x].a.tag &lt; res.tag)) res = t[x].a; return res;&#125;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;int main() &#123; n = read(); int ans = 0; build(1, mod); while (n--) &#123; int opt = read(); if (!opt) &#123; int k = (read() + ans - 1) % mod + 1; printf("%d\n", ans = query(k).tag); &#125; else &#123; int l1 = (read() + ans - 1) % mod + 1, r1 = (read() + ans - 1) % INF + 1, l2 = (read() + ans - 1) % mod + 1, r2 = (read() + ans - 1) % INF + 1; if (l1 == l2) &#123; insert(l1, l2, line(0, max(r1, r2), ++m)); continue; &#125; if (l2 &lt; l1) &#123; swap(l1, l2); swap(r1, r2); &#125; double k = (double)(r2 - r1) / (double)(l2 - l1), b = (double)r2 - k * l2; insert(l1, l2, line(k, b, ++m)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>基础</category>
        <category>线段树</category>
        <category>李超线段树</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>线段树</tag>
        <tag>李超线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 5055 - 可持久化文艺平衡树]]></title>
    <url>%2F2019%2F02%2FLuogu-5055-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%87%E8%89%BA%E5%B9%B3%E8%A1%A1%E6%A0%91%2F</url>
    <content type="text"><![CDATA[与可持久化普通平衡树的区别仅在于 $\operatorname{split}$ 的区别：普通是以 $\operatorname{value}$ 为标准，文艺是以 $\operatorname{size}$ 为标准。 同时，下传标记的时候也会对树结构进行更改，需要重新新建节点记录。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define MAXN 200005typedef long long lint;using namespace std;int n, m;int root[MAXN];struct treap &#123; int l, r, size, val, grade, rev; lint sum;&#125;t[MAXN * 80];lint read() &#123; char c = getchar(); lint x = 0, s = 1; while (!isdigit(c)) &#123; if (c == '-') s = -1; c = getchar(); &#125; while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x * s;&#125;int append(int w) &#123; int u = ++m; t[u].sum = t[u].val = w; t[u].size = 1; t[u].grade = rand(); return u;&#125;void pushup(int u) &#123; t[u].size = t[t[u].l].size + t[t[u].r].size + 1; t[u].sum = t[t[u].l].sum + t[t[u].r].sum + t[u].val;&#125;int clone(int u) &#123; int v = ++m; t[v] = t[u]; return v;&#125;void pushdown(int u) &#123; if (t[u].rev) &#123; if (t[u].l) t[u].l = clone(t[u].l); if (t[u].r) t[u].r = clone(t[u].r); swap(t[u].l, t[u].r); t[u].rev ^= 1; if (t[u].l) t[t[u].l].rev ^= 1; if (t[u].r) t[t[u].r].rev ^= 1; &#125;&#125;int merge(int u, int v) &#123; if (!u || !v) return u + v; if (t[u].grade &lt; t[v].grade) &#123; pushdown(u); t[u].r = merge(t[u].r, v); pushup(u); return u; &#125; pushdown(v); t[v].l = merge(u, t[v].l); pushup(v); return v;&#125;void split(int k, int r, int&amp; u, int&amp; v) &#123; if (!r) &#123; u = v = 0; return ; &#125; pushdown(r); if (t[t[r].l].size &lt; k) &#123; u = clone(r); split(k - t[t[r].l].size - 1, t[r].r, t[u].r, v); pushup(u); &#125; else &#123; v = clone(r); split(k, t[r].l, u, t[v].l); pushup(v); &#125;&#125;void reverse(int&amp; r, int p, int q) &#123; int u, v, w; split(p - 1, r, u, v); split(q - p + 1, v, v, w); t[v].rev ^= 1; r = merge(merge(u, v), w);&#125;void insert(int&amp; r, int p, int x) &#123; int u, v, w = append(x); split(p, r, u, v); r = merge(merge(u, w), v);&#125;void remove(int&amp; r, int p) &#123; int u, v, w; split(p - 1, r, u, v); split(1, v, v, w); r = merge(u, w);&#125;lint query(int&amp; r, int p, int q) &#123; int u, v, w; split(p - 1, r, u, v); split(q - p + 1, v, v, w); lint res = t[v].sum; r = merge(merge(u, v), w); return res;&#125;int main() &#123; n = (int)read(); lint ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; int ver = (int)read(), opt = (int)read(); root[i] = root[ver]; if (opt == 1) &#123; int p = int(read() ^ ans), x = int(read() ^ ans); insert(root[i], p, x); &#125; else if (opt == 2) &#123; int p = int(read() ^ ans); remove(root[i], p); &#125; else if (opt == 3) &#123; int l = int(read() ^ ans), r = int(read() ^ ans); reverse(root[i], l, r); &#125; else &#123; int l = int(read() ^ ans), r = int(read() ^ ans); printf("%lld\n", ans = query(root[i], l, r)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>可持久化</category>
        <category>平衡树</category>
      </categories>
      <tags>
        <tag>可持久化</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 3835 - 可持久化平衡树]]></title>
    <url>%2F2019%2F02%2FLuogu-3835-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%B9%B3%E8%A1%A1%E6%A0%91%2F</url>
    <content type="text"><![CDATA[对于一个需要保存历史版本的平衡树，需要旋转的 $\operatorname{Splay}$ 显然不在考虑范围内，再者其是均摊复杂度；替罪羊树可写，实现较困难，算法竞赛中不太实用；普通 $\operatorname{Treap}$ 也是由于旋转被摒弃，剩下的只有无旋 $\operatorname{Treap}$ 了。 同时，其实现十分简单：对于每一次的 $\operatorname{merge}$ 和 $\operatorname{split}$ ，这两个过程中所有被分裂的节点、作为合并的某个子树的根节点，全部改用赋值为旧节点的新节点，和旧节点或者新节点相连，以作为当前版本的修改。此时可持久化结构不能想象成主席树的链式结构，与原树某条链上的节点相连；而是一个新的树形结构，与原来树中的某些节点相连。 由于仍有运用上一版本节点，复杂度仍是 $O(\log n)$ 。思想和主席树还是大致一样的。 有一个小优化： $\operatorname{split}$ 和 $\operatorname{merge}$ 一定是成对出现的，其中参与可持久化的节点是相同的，可以只复制 $\operatorname{split}$ 中的节点，优化空间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 500005using namespace std;const int INF = 2147483647;int n, total;int root[MAXN];struct balance &#123; int l, r, grade, size, val;&#125;t[MAXN * 50];int read() &#123; char c = getchar(); int x = 0, s = 1; while (!isdigit(c)) &#123; if (c == '-') s = -1; c = getchar(); &#125; while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x * s;&#125;int append(int v) &#123; int u = ++total; t[u].val = v; t[u].grade = rand(); t[u].size = 1; return u;&#125;void pushup(int u) &#123; t[u].size = t[t[u].l].size + t[t[u].r].size + 1;&#125;int merge(int u, int v) &#123; if (!u || !v) return u + v; if (t[u].grade &lt; t[v].grade) &#123; t[u].r = merge(t[u].r, v); pushup(u); return u; &#125; t[v].l = merge(u, t[v].l); pushup(v); return v;&#125;void split(int k, int r, int&amp; u, int&amp; v) &#123; if (!r) &#123; u = v = 0; return ; &#125; if (t[r].val &lt;= k) &#123; u = ++total; t[u] = t[r]; split(k, t[r].r, t[u].r, v); pushup(u); &#125; else &#123; v = ++total; t[v] = t[r]; split(k, t[r].l, u, t[v].l); pushup(v); &#125;&#125;void remove(int&amp; r, int k) &#123; int u, v, w; split(k, r, u, w); split(k - 1, u, u, v); v = merge(t[v].l, t[v].r); r = merge(merge(u, v), w);&#125;void insert(int&amp; r, int k) &#123; int u, v = append(k), w; split(k, r, u, w); r = merge(merge(u, v), w);&#125;int getkth(int r, int k) &#123; int u = r; while (true) &#123; if (t[t[u].l].size + 1 == k) return t[u].val; else if (t[t[u].l].size &gt;= k) u = t[u].l; else &#123; k -= t[t[u].l].size + 1; u = t[u].r; &#125; &#125;&#125;int getrank(int&amp; r, int k) &#123; int u, v, res; split(k - 1, r, u, v); res = t[u].size + 1; r = merge(u, v); return res;&#125;int getpre(int&amp; r, int k) &#123; int u, v, res; split(k - 1, r, u, v); if (!u) return -INF; res = getkth(u, t[u].size); r = merge(u, v); return res;&#125;int getsuf(int&amp; r, int k) &#123; int u, v, res; split(k, r, u, v); if (!v) return INF; res = getkth(v, 1); r = merge(u, v); return res;&#125;int main() &#123; n = read(); for (int i = 1; i &lt;= n; ++i) &#123; int ver = read(), opt = read(), w = read(); root[i] = root[ver]; if (opt == 1) insert(root[i], w); else if (opt == 2) remove(root[i], w); else if (opt == 3) printf("%d\n", getrank(root[i], w)); else if (opt == 4) printf("%d\n", getkth(root[i], w)); else if (opt == 5) printf("%d\n", getpre(root[i], w)); else printf("%d\n", getsuf(root[i], w)); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>可持久化</category>
        <category>平衡树</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>可持久化</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 4098 - [HEOI2013]ALO]]></title>
    <url>%2F2019%2F02%2FLuogu-4098-HEOI2013-ALO%2F</url>
    <content type="text"><![CDATA[假设 $a$ 为次大值，那么可能存在一段连续区间满足条件。 以坐标为序，且只考虑权值比 $a$ 大的点。设 $l$ 为 $a$ 的前驱的前驱， $r$ 为后继的后继，那么这些区间的交集可以表示为： [l + 1, r - 1]当然前提是： l \leq r - 212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;iostream&gt;#define MAXN 50010using namespace std;const int d = 30;int n;int a[MAXN], b[MAXN];int ch[MAXN * 35][2], size[MAXN * 35], total;int root[MAXN];set&lt;int&gt; s;bool comp(int x, int y) &#123; return a[x] &gt; a[y];&#125;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;int insert(int v, int x) &#123; int u = ++total, r = u; size[u] = size[v] + 1; for (int i = d; i &gt;= 0; --i) &#123; int w = x &gt;&gt; i &amp; 1; ch[u][w ^ 1] = ch[v][w ^ 1]; ch[u][w] = ++total; u = ch[u][w]; v = ch[v][w]; size[u] = size[v] + 1; &#125; return r;&#125;int query(int u, int v, int x) &#123; int res = 0; for (int i = d; i &gt;= 0; --i) &#123; int w = x &gt;&gt; i &amp; 1; if (size[ch[v][w ^ 1]] - size[ch[u][w ^ 1]]) &#123; u = ch[u][w ^ 1]; v = ch[v][w ^ 1]; res |= (1 &lt;&lt; i); &#125; else &#123; u = ch[u][w]; v = ch[v][w]; &#125; &#125; return res;&#125;int main() &#123; n = read(); for (int i = 1; i &lt;= n; ++i) &#123; root[i] = insert(root[i - 1], a[i] = read()); b[i] = i; &#125; sort(b + 1, b + n + 1, comp); int ans = 0; s.insert(0); s.insert(-1); s.insert(n + 1); s.insert(n + 2); s.insert(b[1]); for (int i = 2; i &lt;= n; ++i) &#123; int l = max(1, *--(--s.lower_bound(b[i])) + 1), r = min(n, *++s.upper_bound(b[i]) - 1); s.insert(b[i]); if (l &lt;= r) ans = max(ans, query(root[l - 1], root[r], a[b[i]])); &#125; printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>可持久化</category>
        <category>01Trie</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>可持久化</tag>
        <tag>01Trie</tag>
        <tag>异或</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 4592 - [TJOI2018]异或]]></title>
    <url>%2F2019%2F02%2FLuogu-4592-TJOI2018-%E5%BC%82%E6%88%96%2F</url>
    <content type="text"><![CDATA[这道题可以看成两个问：查询子树与查询树上路径。 对于前者，通过 $\operatorname{DFS}$ 序，能够转化成序列问题，利用可持久化 $\operatorname{01Trie}$ 解决。 对于后者，对于每一个点 $i$ ，从根到 $i$ 建立可持久化 $\operatorname{01Trie}$ ，继承方式参考主席树，那么树上路径的查询转化成两条链的查询，此处不需要合并可以分开做。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define MAXN 100010using namespace std;int n, m;const int d = 30;int val[MAXN];int head[MAXN], cnt;int dep[MAXN], fa[MAXN][19], dfn[MAXN], rev[MAXN], size[MAXN], total;struct data &#123; int next, to; data(int next = 0, int to = 0):next(next), to(to) &#123;&#125;&#125;edge[MAXN &lt;&lt; 1];struct trie &#123; int root[MAXN], ch[MAXN * 60][2], size[MAXN * 60], total; trie() &#123; memset(root, 0, sizeof(root)); memset(ch, 0, sizeof(ch)); memset(size, 0, sizeof(size)); total = 0; &#125; void insert(int cur, int pre, int x) &#123; int v = root[pre], u = ++total; root[cur] = u; size[u] = size[v] + 1; for (int i = d; i &gt;= 0; --i) &#123; int c = x &gt;&gt; i &amp; 1; ch[u][c ^ 1] = ch[v][c ^ 1]; ch[u][c] = ++total; u = ch[u][c]; v = ch[v][c]; size[u] = size[v] + 1; &#125; &#125; int query(int u, int v, int x) &#123; u = root[u]; v = root[v]; int res = 0; for (int i = d; i &gt;= 0; --i) &#123; int c = x &gt;&gt; i &amp; 1; if (size[ch[v][c ^ 1]] - size[ch[u][c ^ 1]]) &#123; res |= (1 &lt;&lt; i); u = ch[u][c ^ 1]; v = ch[v][c ^ 1]; &#125; else &#123; u = ch[u][c]; v = ch[v][c]; &#125; &#125; return res; &#125;&#125;seg, top;void connect(int u, int v) &#123; edge[++cnt] = data(head[u], v); head[u] = cnt;&#125;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void DFS(int u, int pre) &#123; dep[u] = dep[pre] + 1; size[u] = 1; fa[u][0] = pre; dfn[u] = ++total; rev[total] = u; top.insert(u, pre, val[u]); for (int i = 1; i &lt;= 17; ++i) fa[u][i] = fa[fa[u][i - 1]][i - 1]; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to; if (v == pre) continue; DFS(v, u); size[u] += size[v]; &#125;&#125;int LCA(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); for (int i = 17; i &gt;= 0; --i) if (dep[fa[u][i]] &gt;= dep[v]) u = fa[u][i]; if (u == v) return u; for (int i = 17; i &gt;= 0; --i) if (fa[u][i] != fa[v][i]) &#123; u = fa[u][i]; v = fa[v][i]; &#125; return fa[u][0];&#125;int main() &#123; n = read(); m = read(); for (int i = 1; i &lt;= n; ++i) val[i] = read(); for (int i = 1; i &lt; n; ++i) &#123; int u = read(), v = read(); connect(u, v); connect(v, u); &#125; DFS(1, 0); for (int i = 1; i &lt;= n; ++i) seg.insert(i, i - 1, val[rev[i]]); for (int i = 1; i &lt;= m; ++i) &#123; int opt = read(), u = read(), v = read(); if (opt == 1) printf("%d\n", seg.query(dfn[u] - 1, dfn[u] + size[u] - 1, v)); else &#123; int w = read(), anc = LCA(u, v); printf("%d\n", max(top.query(fa[anc][0], u, w), top.query(fa[anc][0], v, w))); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>可持久化</category>
        <category>01Trie</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>可持久化</tag>
        <tag>01Trie</tag>
        <tag>异或</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 3689 - 异或之]]></title>
    <url>%2F2019%2F02%2FBZOJ-3689-%E5%BC%82%E6%88%96%E4%B9%8B%2F</url>
    <content type="text"><![CDATA[惭愧，看了题解才会。 首先，对于每一个 $(i, j)$ ，枚举 $i$ ，在后面找到一个 $j$ 使其最大。可持久化 $\operatorname{01 Trie}$ 即可实现，现在 $j$ 的查找区间应该是 $[i + 1, n]$ 。 对于每一个 $i$ ，我们都将其加入大根堆中。当 $(i, j)$ 产生贡献，会分为两个区间继续查找： $[i + 1, j - 1] \cup [j + 1, n]$ 。在从中找到使 $i$ 最大的 $j_1, j_2$ ，加入堆。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt; #define MAXN 100050 using namespace std; int n, k;int a[MAXN];int root[MAXN], total;const int d = 31;int ch[MAXN * 70][2], size[MAXN * 70], tag[MAXN * 70]; struct node &#123; int v, l, r, p, a; node(int v = 0, int l = 0, int r = 0, int p = 0, int a = 0):v(v), l(l), r(r), p(p), a(a) &#123;&#125; bool operator &lt; (const node b) const &#123; return v &gt; b.v; &#125;&#125;; priority_queue&lt;node&gt; q; int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125; int insert(int v, int p, int w) &#123; int u = ++total, r = u; for (int i = d; i &gt;= 0; --i) &#123; int c = w &gt;&gt; i &amp; 1; ch[u][c] = ++total; ch[u][c ^ 1] = ch[v][c ^ 1]; u = ch[u][c]; v = ch[v][c]; size[u] = size[v] + 1; &#125; tag[u] = p; return r;&#125; int query(int u, int v, int w) &#123; for (int i = d; i &gt;= 0; --i) &#123; int c = w &gt;&gt; i &amp; 1; if (size[ch[v][c]] - size[ch[u][c]]) &#123; u = ch[u][c]; v = ch[v][c]; &#125; else &#123; u = ch[u][c ^ 1]; v = ch[v][c ^ 1]; &#125; &#125; return tag[v];&#125; int main() &#123; n = read(); k = read(); for (int i = 1; i &lt;= n; ++i) root[i] = insert(root[i - 1], i, a[i] = read()); for (int i = 1; i &lt; n; ++i) &#123; int t = query(root[i], root[n], a[i]); q.push(node(a[i] ^ a[t], i + 1, n, t, a[i])); &#125; while (k--) &#123; node u = q.top(); q.pop(); printf("%d ", u.v); if (u.l != u.p) &#123; int t = query(root[u.l - 1], root[u.p - 1], u.a); q.push(node(u.a ^ a[t], u.l, u.p - 1, t, u.a)); &#125; if (u.r != u.p) &#123; int t = query(root[u.p], root[u.r], u.a); q.push(node(u.a ^ a[t], u.p + 1, u.r, t, u.a)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>可持久化</category>
        <category>01Trie</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>可持久化</tag>
        <tag>01Trie</tag>
        <tag>异或</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 4103 - [SC2015]异或运算]]></title>
    <url>%2F2019%2F02%2FBZOJ-4103-SC2015-%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[发现询问次数 $p$ 极少，行数 $n$ 极少，考虑对这两个进行操作。 对于列建立可持久化 $\operatorname{01 Trie}$ ，每一次查询时，把查询行代表的数字丢到 $\operatorname{01Trie}$ 里面查，类似于二分的过程； 假设该位为 $1$ 时： 若其个数 $s$ 小于 $k$ ，因为其不属于这前 $k$ 大， $k = k - s$ ，所有根往置 $0$ 点走； 反之往置 $1$ 点走。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt; #define MAXN 300005 using namespace std; const int D = 30;int n, m, q;int a[MAXN], b[MAXN];int ch[MAXN * 50][2], size[MAXN * 50], total;int root[MAXN];int u[MAXN], v[MAXN]; int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125; int insert(int v, int x) &#123; int u = ++total, r = u; size[u] = size[v] + 1; for (int i = D; i &gt;= 0; --i) &#123; int w = x &gt;&gt; i &amp; 1; ch[u][w ^ 1] = ch[v][w ^ 1]; ch[u][w] = ++total; u = ch[u][w]; v = ch[v][w]; size[u] = size[v] + 1; &#125; return r;&#125; int query(int l, int r, int c, int d, int k) &#123; for (int i = l; i &lt;= r; ++i) &#123; u[i] = root[c - 1]; v[i] = root[d]; &#125; int res = 0; for (int i = D; i &gt;= 0; --i) &#123; int sum = 0; for (int j = l; j &lt;= r; ++j) &#123; int w = a[j] &gt;&gt; i &amp; 1; sum += size[ch[v[j]][w ^ 1]] - size[ch[u[j]][w ^ 1]]; &#125; if (sum &lt; k) &#123; k -= sum; for (int j = l; j &lt;= r; ++j) &#123; int w = a[j] &gt;&gt; i &amp; 1; u[j] = ch[u[j]][w]; v[j] = ch[v[j]][w]; &#125; &#125; else &#123; res |= (1 &lt;&lt; i); for (int j = l; j &lt;= r; ++j) &#123; int w = a[j] &gt;&gt; i &amp; 1; u[j] = ch[u[j]][w ^ 1]; v[j] = ch[v[j]][w ^ 1]; &#125; &#125; &#125; return res;&#125; int main() &#123; n = read(); m = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); for (int i = 1; i &lt;= m; ++i) root[i] = insert(root[i - 1], b[i] = read()); q = read(); while (q--) &#123; int a = read(), b = read(), c = read(), d = read(), k = read(); printf("%d\n", query(a, b, c, d, k)); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>可持久化</category>
        <category>01Trie</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>可持久化</tag>
        <tag>01Trie</tag>
        <tag>异或</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 3272 - [SCOI2011]地板]]></title>
    <url>%2F2019%2F02%2FLuogu-3272-SCOI2011-%E5%9C%B0%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[对于一个 “$L​$” ，可以把他看作两种插头的结合体：还能转向的插头，不能转向的插头。这样能够涵盖所有的情况。 那么用 $0$ 来表示不放置， $1$ 表示还能转向， $2$ 表示不能转向，四进制状态压缩： $\operatorname{original}$ $\operatorname{transfered}$ $(0, 0)$ $(0, 0) \cup (1, 1)$ $(1,0)$ $(0, 1) \cup (2, 0)$ $(0, 1)$ $(1, 0) \cup (0, 2)$ $(2, 0)$ $(0, 0) \cup (0, 2)$ $(0, 2)$ $(0, 0) \cup (2, 0)$ $(1, 1)$ $(0, 0)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define MAXN 11#define MAXS 2 &lt;&lt; 22#define MAXM 110using namespace std;const int mod = 20110520;const int HASH = 299987;int n, m;int bit[MAXN];int head[MAXS], cnt[2], q[2][MAXS], v[2][MAXS], suffix[MAXS];int a[MAXM][MAXN], x, y;char s[MAXM];void init() &#123; bit[0] = 1; for (int i = 1; i &lt;= 10; ++i) bit[i] = bit[i - 1] &lt;&lt; 2;&#125;void insert(int cur, int state, int amount) &#123; int u = state % HASH + 1; for (int i = head[u]; i; i = suffix[i]) &#123; if (q[cur][i] == state) &#123; v[cur][i] = (v[cur][i] + amount) % mod; return ; &#125; &#125; suffix[++cnt[cur]] = head[u]; q[cur][cnt[cur]] = state; v[cur][cnt[cur]] = amount; head[u] = cnt[cur];&#125;void solve() &#123; int cur = 0; cnt[cur] = 1; v[cur][1] = 1; int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= cnt[cur]; ++j) q[cur][j] &lt;&lt;= 2; for (int j = 1; j &lt;= m; ++j) &#123; int last = cur; cur ^= 1; cnt[cur] = 0; memset(head, 0, sizeof(head)); for (int k = 1; k &lt;= cnt[last]; ++k) &#123; int state = q[last][k], amount = v[last][k], w1 = state &gt;&gt; ((j - 1) &lt;&lt; 1) &amp; 3, w2 = state &gt;&gt; (j &lt;&lt; 1) &amp; 3; if (!a[i][j]) &#123; if (!w1 &amp;&amp; !w2) insert(cur, state, amount); &#125; else if (!w1 &amp;&amp; !w2) &#123; if (a[i + 1][j]) insert(cur, state ^ bit[j - 1], amount); if (a[i][j + 1]) insert(cur, state ^ bit[j], amount); if (a[i][j + 1] &amp;&amp; a[i + 1][j]) insert(cur, state ^ (bit[j] &lt;&lt; 1) ^ (bit[j - 1] &lt;&lt; 1), amount); &#125; else if (!w1 &amp;&amp; w2 == 1) &#123; if (a[i + 1][j]) insert(cur, state ^ bit[j] ^ bit[j - 1], amount); if (a[i][j + 1]) insert(cur, state ^ bit[j] ^ (bit[j] &lt;&lt; 1), amount); &#125; else if (w1 == 1 &amp;&amp; !w2) &#123; if (a[i + 1][j]) insert(cur, state ^ bit[j - 1] ^ (bit[j - 1] &lt;&lt; 1), amount); if (a[i][j + 1]) insert(cur, state ^ bit[j - 1] ^ bit[j], amount); &#125; else if (!w1 &amp;&amp; w2 == 2) &#123; if (i == x &amp;&amp; j == y) ans = (ans + amount) % mod; if (a[i + 1][j]) insert(cur, state ^ (bit[j] &lt;&lt; 1) ^ (bit[j - 1] &lt;&lt; 1), amount); insert(cur, state ^ (bit[j] &lt;&lt; 1), amount); &#125; else if (w1 == 2 &amp;&amp; !w2) &#123; if (i == x &amp;&amp; j == y) ans = (ans + amount) % mod; if (a[i][j + 1]) insert(cur, state ^ (bit[j] &lt;&lt; 1) ^ (bit[j - 1] &lt;&lt; 1), amount); insert(cur, state ^ (bit[j - 1] &lt;&lt; 1), amount); &#125; else if (w1 == 1 &amp;&amp; w2 == 1) &#123; if (i == x &amp;&amp; j == y) ans = (ans + amount) % mod; insert(cur, state ^ bit[j] ^ bit[j - 1], amount); &#125; &#125; &#125; &#125; printf("%d\n", ans);&#125;int main() &#123; init(); scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) &#123; scanf("%s", s + 1); for (int j = 1; j &lt;= m; ++j) &#123; if (n &gt; m) a[i][j] = s[j] == '_'; else a[j][i] = s[j] == '_'; &#125; &#125; if (n &lt; m) swap(n, m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) if (a[i][j]) &#123; x = i; y = j; &#125; solve();&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>插头DP</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>插头DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 842D - Vitya and Strange Lesson]]></title>
    <url>%2F2019%2F02%2FCodeforces-842D-Vitya-and-Strange-Lesson%2F</url>
    <content type="text"><![CDATA[可以想到是线性基或者 $\operatorname{01 Trie}$ ，由于要支持修改，只能选择后者。 异或我们分位考虑，考虑不同情况的影响： $\operatorname{case 1}$ $\operatorname{case 2}$ $\operatorname{case 3}$ $\operatorname{case 4}$ $1$ $0$ $1$ $0$ $1$ $1$ $0$ $0$ $0$ $1$ $1$ $0$ 非常基础，从中可以看出只有 $1$ 有影响，在 $\operatorname{01 Trie}$ 上体现的就是交换左右儿子，对于一整层，显然可以打个标记。 再说说怎么处理答案，由于是找到没出现过的，首先先强制对齐，高位走 $0$ 一定更优，那么只需要检查走 $0$ 是否有解。设层高为 $i$ 只需要判断子树大小 $s$ 是否满足： s < 2^i满足则对于这颗子树有解，往下走进行相似判断。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAXN 3000005#define MAXD 20using namespace std;const int d = 18;int n, m;int a[MAXN], root = 1;int ch[MAXN][2], total = 1;int size[MAXN];bool rev[MAXD], record[MAXN];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void build(int x) &#123; if (record[x]) return ; record[x] = true; int u = root; ++size[u]; for (int i = d; i &gt;= 0; --i) &#123; int suf = x &gt;&gt; i &amp; 1; if (!ch[u][suf]) ch[u][suf] = ++total; u = ch[u][suf]; ++size[u]; &#125;&#125;int query() &#123; int u = root, ans = 0; for (int i = d; i &gt;= 0; --i) if (rev[i]) &#123; if (size[ch[u][1]] &lt; (1 &lt;&lt; i)) u = ch[u][1]; else &#123; u = ch[u][0]; ans |= (1 &lt;&lt; i); &#125; &#125; else &#123; if (size[ch[u][0]] &lt; (1 &lt;&lt; i)) u = ch[u][0]; else &#123; u = ch[u][1]; ans |= (1 &lt;&lt; i); &#125; &#125; return ans;&#125;void change(int x) &#123; for (int i = d; i &gt;= 0; --i) rev[i] ^= x &gt;&gt; i &amp; 1;&#125;int main() &#123; n = read(); m = read(); for (int i = 1; i &lt;= n; ++i) build(read()); for (int i = 1; i &lt;= m; ++i) &#123; change(read()); printf("%d\n", query()); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>基础</category>
        <category>01Trie</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>01Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 3402 - 可持久化并查集]]></title>
    <url>%2F2019%2F02%2FLuogu-3402-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[由于需要可持久化，不能进行路径压缩。为了保证复杂度，必须进行按秩合并，这里以深度作秩，深度小的合并到深度大的上。 接下来利用可持久化数组进行维护 $\operatorname{father}$ 即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAXN 100005using namespace std;int n, m, total;int root[MAXN &lt;&lt; 1];struct segment &#123; int l, r, fa, dep;&#125;t[MAXN &lt;&lt; 6];int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;int build(int l, int r) &#123; int x = ++total; if (l == r) &#123; t[x].fa = l; return x; &#125; int mid = (l + r) &gt;&gt; 1; t[x].l = build(l, mid); t[x].r = build(mid + 1, r); return x;&#125;void update(int l, int r, int p, int x) &#123; if (l == r) &#123; ++t[x].dep; return ; &#125; int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) update(l, mid, p, t[x].l); else update(mid + 1, r, p, t[x].r);&#125;int query(int l, int r, int p, int x) &#123; if (l == r) return x; int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) return query(l, mid, p, t[x].l); else return query(mid + 1, r, p, t[x].r);&#125;int modify(int l, int r, int p, int v, int y) &#123; int x = ++total; t[x] = t[y]; if (l == r) &#123; t[x].fa = v; t[x].dep = t[y].dep; return x; &#125; int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) t[x].l = modify(l, mid, p, v, t[y].l); else t[x].r = modify(mid + 1, r, p, v, t[y].r); return x;&#125;int query(int r, int x) &#123; int y = query(1, n, x, r); if (t[y].fa == x) return y; return query(r, t[y].fa);&#125;int merge(int r, int a, int b) &#123; int u = query(r, a), v = query(r, b); if (u != v) &#123; if (t[u].dep &gt; t[v].dep) swap(u, v); r = modify(1, n, t[u].fa, t[v].fa, r); if (t[u].dep == t[v].dep) update(1, n, t[v].fa, r); &#125; return r;&#125;int main() &#123; n = read(); m = read(); root[0] = build(1, n); for (int i = 1; i &lt;= m; ++i) &#123; int opt = read(), a, b, k; root[i] = root[i - 1]; if (opt == 1) &#123; a = read(); b = read(); root[i] = merge(root[i], a, b); &#125; else if (opt == 2) &#123; k = read(); root[i] = root[k]; &#125; else &#123; a = read(); b = read(); if (query(root[i], a) == query(root[i], b)) puts("1"); else puts("0"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>可持久化</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>可持久化</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 2109 - [NOI2007]生成树计数]]></title>
    <url>%2F2019%2F01%2FLuogu-2109-NOI2007-%E7%94%9F%E6%88%90%E6%A0%91%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目误导向，只能作为对拍程序。 观察题目，不难发现 $k$ 极小，提示可以利用 $k$ 进行状态压缩。同时 $n$ 极大，不是矩阵加速就是计数类问题。这里显然是矩阵加速了。 设 $f_{i, j}$ 为第 $i$ 个格子，往前 $k$ 个点的连通状态为 $j$ 的方案数，打表不难发现总数不大，先预处理出最多 $52$ 种个状态。 考虑一个状态的前驱，只能先枚举点 $i$ 和其他的连边： 不能构成环 不能缺少某一连通分量 基于以上信息和连边，可以推出下一步的状态。进行矩阵快速幂了即可解决问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAXT 1 &lt;&lt; 16#define MAXS 55#define MAXK 6typedef long long lint;using namespace std;const int mod = 65521;lint n;int k;int record[MAXT], state[MAXS], m;int sum[MAXS];int fa[MAXS], mul[] = &#123;1, 1, 1, 3, 16, 125&#125;;int ans;struct matrix &#123; int a[MAXS][MAXS]; matrix() &#123; memset(a, 0, sizeof(a)); &#125; matrix operator * (const matrix b) const &#123; matrix c; for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= m; ++j) for (int k = 1; k &lt;= m; ++k) c.a[i][j] = (c.a[i][j] + 1ll * a[i][k] * b.a[k][j] % mod) % mod; return c; &#125;&#125;base, trans;matrix operator ^ (matrix a, lint b) &#123; matrix res; for (int i = 1; i &lt;= m; ++i) res.a[i][i] = 1; while (b) &#123; if (b &amp; 1) res = res * a; a = a * a; b &gt;&gt;= 1; &#125; return res;&#125;lint read() &#123; char c = getchar(); lint x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void DFS(int d, int s, int limit) &#123; if (d == k) &#123; record[s] = ++m; state[m] = s; return ; &#125; for (int i = 1; i &lt;= limit + 1; ++i) DFS(d + 1, s | (i &lt;&lt; (d * 3)), max(limit, i));&#125;int get(int x) &#123; return x == fa[x] ? x : fa[x] = get(fa[x]);&#125;void suffix(int i, int connect) &#123; int current = state[i], afterward = 0; for (int j = 0; j &lt;= k; ++j) fa[j] = j; for (int j = 0; j &lt;= k; ++j) for (int l = j + 1; l &lt;= k; ++l) &#123; if ((current &gt;&gt; (j * 3) &amp; 7) == (current &gt;&gt; (l * 3) &amp; 7)) fa[get(j)] = get(l); &#125; for (int j = 0; j &lt;= k; ++j) if (connect &gt;&gt; j &amp; 1) &#123; if (get(j) != get(k)) fa[get(j)] = get(k); else return ; &#125; bool islegal = false; for (int j = 1; j &lt;= k; ++j) if (get(j) == get(0)) &#123; islegal = true; break; &#125; if (!islegal) return ; int amount = 0; for (int j = 0; j &lt; k; ++j) &#123; if (afterward &gt;&gt; (j * 3) &amp; 7) continue; afterward |= (++amount) &lt;&lt; (j * 3); for (int l = j + 1; l &lt; k; ++l) if (get(l + 1) == get(j + 1)) afterward |= amount &lt;&lt; (l * 3); &#125; ++trans.a[i][record[afterward]];&#125;int main() &#123; k = (int)read(); n = read(); DFS(0, 0, 0); for (int i = 1; i &lt;= m; ++i) for (int j = 0; j &lt; (1 &lt;&lt; k); ++j) suffix(i, j); base = trans ^ (n - k); int ans = 0; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 0; j &lt;= k; ++j) sum[j] = 0; for (int j = 0; j &lt; k; ++j) ++sum[state[i] &gt;&gt; (j * 3) &amp; 7]; int res = 1; for (int j = 1; j &lt;= k; ++j) res = 1ll * res * mul[sum[j]] % mod; ans = (ans + 1ll * res * base.a[i][1] % mod) % mod; &#125; printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>状压DP</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>状压DP</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 5056 - 插头DP]]></title>
    <url>%2F2019%2F01%2FLuogu-5056-%E6%8F%92%E5%A4%B4DP%2F</url>
    <content type="text"><![CDATA[这是一道插头 $DP$ 的模版题，简单介绍一下： 插头 $DP$ 主要用的是逐格递推的思想：假想有一条线划分了已解决的状态和未解决的状态，那么插头 $DP$ 就是对这条轮廓线进行 $DP$ 。 状态这么设计：$0$ 表示没有插头， $1$ 表示左插头， $2$ 表示右插头，发现是三进制状态，强行扩充成四进制状态。 由于状态数较多，又有冗余的存在，所以利用 $\operatorname{hash}​$ 来进行状态转移。 分别对转移进行解析： 换行时的转移： 结束时，轮廓线应当是一条直线，但由于上一轮转移时，为了方便尚未左移，所以需要将继承的所有状态左移。 同行时的转移： 对于当前 $DP$ 的格子，与轮廓线有两个接触面：左和上，分别记为 $w_1, w_2$，都可以用来放置插头。 新建一个连通分量： 当且仅当 $w_1 = w_2 = 0$ 时，才能新建连通分量。 合并两个连通分量： $w_1 = 0 \ \cap \ w_2 \neq 0​$ 上边有插头左边没有，向右转移时状态不发生改变；向下转移时状态改变。 $w_1 \neq 0 \ \cap \ w_2 = 0$ 左边有插头上边没有，向下转移时状态不发生改变；向右转移时状态改变。 $w_1 = w_2 = 1​$ 左上都有左插头，需要在右边找到一个最近的匹配的右插头，将其替换成左插头。 $w_1 = w_2 = 2​$ 左上都有右插头，需要在左边找到一个最近的匹配的左插头，将其替换成右插头。 保持原来的连通分量： $w_1 = 1 \ \cap \ w_2 = 2$ 已成回路，合并答案。 $w_1 = 2 \ \cap \ w_2 = 1$ 消除插头，继续匹配。 详情参见代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;typedef long long lint;#define MAXN 13#define MAXS 2 &lt;&lt; 24#define MAXH 300000using namespace std;char s[MAXN &lt;&lt; 1];int mod = 299987;int n, m;int tx, ty;int head[MAXH + 100], cnt[2], suffix[MAXS];lint bit[MAXN + 1];int a[MAXN + 10][MAXN + 10];lint que[2][MAXS], val[2][MAXS];void insert(int cur, lint state, lint sum) &#123; lint u = state % mod + 1; for (int i = head[u]; i; i = suffix[i]) if (que[cur][i] == state) &#123; val[cur][i] += sum; return ; &#125; suffix[++cnt[cur]] = head[u]; head[u] = cnt[cur]; que[cur][cnt[cur]] = state; val[cur][cnt[cur]] = sum;&#125;void solve() &#123; int cur = 0; lint ans = 0; cnt[cur] = 1; que[cur][1] = 0; val[cur][1] = 1; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= cnt[cur]; ++j) que[cur][j] &lt;&lt;= 2; for (int j = 1; j &lt;= m; ++j) &#123; memset(head, 0, sizeof(head)); int last = cur; cur ^= 1; cnt[cur] = 0; for (int k = 1; k &lt;= cnt[last]; ++k) &#123; lint state = que[last][k], amount = val[last][k]; int w1 = (state &gt;&gt; ((j - 1) &lt;&lt; 1)) &amp; 3, w2 = (state &gt;&gt; (j &lt;&lt; 1)) &amp; 3; if (!a[i][j]) &#123; if (!w1 &amp;&amp; !w2) insert(cur, state, amount); &#125; else if (!w1 &amp;&amp; !w2) &#123; if (a[i + 1][j] &amp;&amp; a[i][j + 1]) insert(cur, state ^ bit[j - 1] ^ (bit[j] &lt;&lt; 1), amount); &#125; else if (!w1 &amp;&amp; w2) &#123; if (a[i][j + 1]) insert(cur, state, amount); if (a[i + 1][j]) insert(cur, state ^ (bit[j] * w2) ^ (bit[j - 1] * w2), amount); &#125; else if (w1 &amp;&amp; !w2) &#123; if (a[i + 1][j]) insert(cur, state, amount); if (a[i][j + 1]) insert(cur, state ^ (bit[j] * w1) ^ (bit[j - 1] * w1), amount); &#125; else if (w1 == 1 &amp;&amp; w2 == 1) &#123; int p = 1; for (int l = j + 1; l &lt;= m; ++l) &#123; if (((state &gt;&gt; (l &lt;&lt; 1)) &amp; 3) == 1) ++p; if (((state &gt;&gt; (l &lt;&lt; 1)) &amp; 3) == 2) --p; if (!p) &#123; insert(cur, state ^ bit[j] ^ bit[j - 1] ^ bit[l] ^ (bit[l] &lt;&lt; 1), amount); break; &#125; &#125; &#125; else if (w1 == 2 &amp;&amp; w2 == 2) &#123; int p = 1; for (int l = j - 2; l &gt;= 0; --l) &#123; if (((state &gt;&gt; (l &lt;&lt; 1)) &amp; 3) == 1) --p; if (((state &gt;&gt; (l &lt;&lt; 1)) &amp; 3) == 2) ++p; if (!p) &#123; insert(cur, state ^ (bit[j] &lt;&lt; 1) ^ (bit[j - 1] &lt;&lt; 1) ^ (bit[l] &lt;&lt; 1) ^ bit[l], amount); break; &#125; &#125; &#125; else if (w1 == 2 &amp;&amp; w2 == 1) insert(cur, state ^ (bit[j - 1] &lt;&lt; 1) ^ bit[j], amount); else if (i == tx &amp;&amp; j == ty) ans += amount; &#125; &#125; &#125; printf("%lld\n", ans);&#125;void init() &#123; bit[0] = 1; for (int i = 1; i &lt; 13; ++i) bit[i] = bit[i - 1] &lt;&lt; 2;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) &#123; scanf("%s", s + 1); for (int j = 1; j &lt;= m; ++j) &#123; a[i][j] = s[j] == '.'; if (a[i][j]) &#123; tx = i; ty = j; &#125; &#125; &#125; init(); solve();&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>插头DP</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>插头DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 2624 - [HNOI2008]明明的烦恼]]></title>
    <url>%2F2019%2F01%2FLuogu-2624-HNOI2008-%E6%98%8E%E6%98%8E%E7%9A%84%E7%83%A6%E6%81%BC%2F</url>
    <content type="text"><![CDATA[设总共有 $c$ 个点不受限制，此时 $\operatorname{Prufer}$ 序列的总长度为：$s = \sum \limits_{i = 1}^n(d_i - 1)$。 有两种思考方式，稍作记录： 先考虑受限制的点排列的方案数为：$\frac{s!}{\prod \limits_{i = 1}^c(d_i - 1)!}$ ，他们的位置不是固定的，枚举位置的方案数为 $\begin{pmatrix} n - 2 \\ s \end{pmatrix}$ ，总方案数为： \begin{align*} &\begin{pmatrix} n - 2 \\ s \end{pmatrix}\frac{s!}{\prod \limits_{i = 1}^c(d_i - 1)!} \\ = &\frac{(n - 2)!}{(n - sum - 2)!\times \prod \limits_{i = 1}^c(d_i - 1)!} \end{align*}对于那些不受限制的点，枚举放置：$(n - c)^{n - sum - 2}$ ，所以总方案数为： \frac{(n - 2)!}{(n - sum - 2)!\times \prod \limits_{i = 1}^c(d_i - 1)!} \times (n - c)^{n - sum - 2} 把不受限制的点当作一个整体，将其视作可重集计数问题，那么方案数为： \frac{(n - 2)!}{(n - sum - 2)!\times \prod \limits_{i = 1}^c(d_i - 1)!}然后在枚举不受限制的点的放置： \frac{(n - 2)!}{(n - sum - 2)!\times \prod \limits_{i = 1}^c(d_i - 1)!} \times (n - c)^{n - sum - 2} 过程的一致性，思考的多样性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 10010using namespace std;int d[MAXN];int n;int read() &#123; char c = getchar(); int x = 0, s = 1; while (!isdigit(c)) &#123; if (c == '-') s = -1; c = getchar(); &#125; while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x * s;&#125;struct bint &#123; int a[MAXN], n; bint(int x = 0) &#123; n = 0; memset(a, 0, sizeof(a)); while (x) &#123; a[++n] = x % 10; x /= 10; &#125; &#125; bint operator * (const bint b) const &#123; bint c; c.n = n + b.n - 1; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= b.n; ++j) &#123; c.a[i + j - 1] = c.a[i + j - 1] + a[i] * b.a[j]; if (c.a[i + j - 1] &gt; 9) &#123; c.a[i + j] += c.a[i + j - 1] / 10; c.a[i + j - 1] %= 10; &#125; &#125; c.n += c.a[c.n + 1] &gt; 0; return c; &#125; bint operator / (const int b) const &#123; bint c; c.n = n; int res = 0; for (int i = n; i; --i) &#123; res = (res * 10 + a[i]); if (res &gt;= b)&#123; c.a[i] = res / b; res %= b; &#125; &#125; while (c.n &amp;&amp; !c.a[c.n]) --c.n; return c; &#125; bint operator ^ (int b) const &#123; bint res(1), a = *this; while (b) &#123; if (b &amp; 1) res = res * a; a = a * a; b &gt;&gt;= 1; &#125; return res; &#125; void output() &#123; for (int i = n; i; --i) putchar(a[i] + '0'); puts(""); &#125;&#125;ans(1);int main() &#123; n = read(); int sum = 0, amount = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (i &lt;= n - 2) ans = ans * bint(i); d[i] = read(); if (d[i] != -1) &#123; sum += d[i] - 1; ++amount; &#125; if (!d[i]) &#123; puts("0"); return 0; &#125; &#125; if (sum &gt; 2 * n - 2) &#123; puts("0"); return 0; &#125; ans = ans * ((bint)(n - amount) ^ (n - 2 - sum)); for (int i = 2; i &lt;= n - 2 - sum; ++i) ans = ans / i; for (int i = 1; i &lt;= n; ++i) if (d[i] != -1) for (int j = 2; j &lt;= d[i] - 1; ++j) ans = ans / j; ans.output();&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>组合数学</category>
        <category>Prufer序列</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>Prufer序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 3264 - [JLOI2015]管道连接]]></title>
    <url>%2F2019%2F01%2FLuogu-3264-JLOI2015-%E7%AE%A1%E9%81%93%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[这道题的斯坦纳树比较特殊，应该是斯坦纳森林。 对于斯坦纳森林，首先进行一次斯坦纳树，需要最后剖分其子树，进行一次子集 $DP$ ，合并答案即可。 最初做一遍斯坦纳树是为了方便，由于题目要求只有频道相同的重要信号站需要相连，所以需要剖分他的子树成一个个子集。接着枚举合法的子集，并将这些合法的子集合并即可。 合法指的是：包含同一种频道的所有信号站。这就意味着，如果只包含要求的部分，那就不合法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;map&gt;#define MAXM 3050#define MAXN 1050#define MAXP 11#define INF 0x3f3f3f3fusing namespace std;int n, m, p;int c[MAXN], sum[MAXP];int record[MAXN], belong[MAXN];int head[MAXN], cnt;bool inq[MAXN];int f[1 &lt;&lt; MAXP][MAXN];int ans[1 &lt;&lt; MAXP];struct data &#123; int next, to, cost; data(int next = 0, int to = 0, int cost = 0):next(next), to(to), cost(cost) &#123;&#125;&#125;edge[MAXM &lt;&lt; 1];void connect(int u, int v, int w) &#123; edge[++cnt] = data(head[u], v, w); head[u] = cnt;&#125;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void SPFA(int s) &#123; memset(inq, 0, sizeof(inq)); queue&lt;int&gt; q; for (int i = 1; i &lt;= n; ++i) if (f[s][i] != INF) &#123; q.push(i); inq[i] = true; &#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = false; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to, w = edge[i].cost; if (f[s][v] &gt; f[s][u] + w) &#123; f[s][v] = f[s][u] + w; if (!inq[v]) &#123; q.push(v); inq[v] = true; &#125; &#125; &#125; &#125;&#125;bool islegal(int s) &#123; memset(sum, 0, sizeof(sum)); for (int i = 0; i &lt; p; ++i) if (s &gt;&gt; i &amp; 1) ++sum[belong[i + 1]]; for (int i = 1; i &lt;= 10; ++i) if (sum[i] &amp;&amp; sum[i] != c[i]) return false; return true;&#125;int main() &#123; n = read(); m = read(); p = read(); for (int i = 1; i &lt;= m; ++i) &#123; int u = read(), v = read(), w = read(); connect(u, v, w); connect(v, u, w); &#125; memset(f, INF, sizeof(f)); for (int i = 1; i &lt;= p; ++i) &#123; int x = read(), y = read(); record[i] = y; belong[i] = x; f[1 &lt;&lt; (i - 1)][y] = 0; ++c[x]; &#125; int limit = (1 &lt;&lt; p) - 1; for (int s = 0; s &lt;= limit; ++s) &#123; for (int i = 1; i &lt;= n; ++i) &#123; for (int t = (s - 1) &amp; s; t; t = (t - 1) &amp; s) f[s][i] = min(f[s][i], f[t][i] + f[s ^ t][i]); &#125; SPFA(s); &#125; memset(ans, INF, sizeof(ans)); for (int s = 0; s &lt;= limit; ++s) if (islegal(s)) for (int i = 1; i &lt;= n; ++i) ans[s] = min(f[s][i], ans[s]); for (int s = 0; s &lt;= limit; ++s) if (islegal(s)) for (int t = (s - 1) &amp; s; t; t = (t - 1) &amp; s) ans[s] = min(ans[s], ans[s ^ t] + ans[t]); printf("%d\n", ans[limit]);&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>斯坦纳树</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>斯坦纳树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斯特林数]]></title>
    <url>%2F2019%2F01%2F%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0%2F</url>
    <content type="text"><![CDATA[第一类斯特林数定义表示 $n$ 个不同元素构成 $m$ 个圆排列的数目，记为 $\begin{bmatrix} n \\ m\end{bmatrix}$ 。 第二类斯特林数定义表示 $n$ 个不同小球放在 $m$ 个相同盒子的方案数，记为 $\begin{Bmatrix}n \\ m \end{Bmatrix}$ 。 递推 \begin{Bmatrix}n \\ m\end{Bmatrix} = \begin{Bmatrix}n - 1 \\ m - 1 \end{Bmatrix} + m\begin{Bmatrix} n - 1 \\ m \end{Bmatrix}通项 \begin{Bmatrix} n \\ m\end{Bmatrix} = \frac{1}{m!}\sum \limits_{k = 0}^m(-1)^k\begin{pmatrix}m \\ k \end{pmatrix}(m - k)^n枚举空盒，枚举放的盒子。 组合等式等式 $1$ n^m = \sum \limits_{k = 0}^m \begin{Bmatrix} m \\ k\end{Bmatrix}n^{\underline{k}}证明我只会用数学归纳法证明。 \sum \limits_{k = 0}^m\begin{Bmatrix}m \\ k\end{Bmatrix}n^{\underline{k}} \\ = \sum \limits_{k = 1}^mk\begin{Bmatrix}m - 1 \\ k\end{Bmatrix}n^{\underline{k}} + \sum \limits_{k = 1}^m\begin{Bmatrix}m - 1 \\ k - 1\end{Bmatrix}n^{\underline{k}} \\ = \sum \limits_{k = 1}^mk\begin{Bmatrix}m - 1 \\ k\end{Bmatrix}n^{\underline{k}} + \sum \limits_{k = 0}^{m - 1}\begin{Bmatrix}m - 1 \\ k\end{Bmatrix}n^{\underline{k + 1}} \\ = \sum \limits_{k = 1}^mk\begin{Bmatrix}m - 1 \\ k\end{Bmatrix}n^{\underline{k}} + \sum \limits_{k = 0}^{m - 1}(n - k)\begin{Bmatrix}m - 1 \\ k\end{Bmatrix}n^{\underline{k}} \\ = (n - k + k)\cdot n^{m - 1} \\ = n^m等式 $2$ n^{\underline m} = \begin{pmatrix} n \\ m \end{pmatrix}m!证明由于形如上面那个就咕咕咕了。 变式 n^m = \sum \limits_{k = 0}^m \begin{Bmatrix} m \\ k\end{Bmatrix}\begin{pmatrix}n \\ k\end{pmatrix}k!等式 $3$ n^{\overline{m}} = \sum \limits_{k = 0}^m \begin{bmatrix}n \\ k \end{bmatrix}n^k证明由于形如上上面那个就咕咕咕了。 斯特林反演反演公式 f(n) = \sum \limits_{k = 0}^n\begin{Bmatrix}n \\ k \end{Bmatrix} g(k) \Longleftrightarrow g(n) = \sum \limits_{k = 0}^n(-1)^{n - k}\begin{bmatrix} n \\ k\end{bmatrix}f(k)证明反转公式 [n = m] = \sum \limits_{k = m}^n(-1)^{n - k}\begin{bmatrix}n \\ k\end{bmatrix}\begin{Bmatrix}i \\ m \end{Bmatrix} \\ [n = m] = \sum \limits_{k = m}^n(-1)^{k - m}\begin{Bmatrix}n \\ k\end{Bmatrix}\begin{bmatrix}k \\ m \end{bmatrix}证明需要阶乘幂的转化公式： n^{\overline m} = (-1)^n(-n)^{\underline{m}} \\ n^{\underline m} = (-1)^n(-n)^{\overline{m}} \\稍作变换： n^m = \sum \limits_{k = 0}^m \begin{Bmatrix}m \\ k \end{Bmatrix}n^{\underline{k}} \\ = \sum \limits_{k = 0}^m \begin{Bmatrix}m \\ k \end{Bmatrix}(-1)^k(-n)^{\overline{k}} \\ = \sum \limits_{k = 0}^m \begin{Bmatrix}m \\ k \end{Bmatrix}(-1)^k\sum \limits_{j = 0}^k \begin{bmatrix}k \\ j \end{bmatrix}(-n)^j \\ = \sum \limits_{j = 0}^m \begin{bmatrix}m \\ j \end{bmatrix}n^j\sum \limits_{k = j}^m \begin{Bmatrix}k \\ j \end{Bmatrix}(-1)^{k - j}得到了一个反转公式，另一个类似，不证。 证明现在可以证明斯特林反演了： \because f(n) = \sum \limits_{k = 0}^n\begin{Bmatrix}n \\ k \end{Bmatrix} g(k) \\ \therefore g(n) = \sum \limits_{j = 0}^n[j = n]f(j) \\ = \sum \limits_{j = 0}^n \sum \limits_{k = j}^n(-1)^{n - k}\begin{bmatrix}n \\ k\end{bmatrix}\begin{Bmatrix}k\\ j\end{Bmatrix}g(j) \\ = \sum \limits_{k = 0}^n (-1)^{n - k}\begin{bmatrix}n \\ k\end{bmatrix}\sum \limits_{j = 0}^k \begin{Bmatrix}k\\ j\end{Bmatrix}g(j) \\ = \sum \limits_{k = 0}^n (-1)^{n - k}\begin{bmatrix}n \\ k\end{bmatrix} f(k)]]></content>
      <categories>
        <category>数学</category>
        <category>组合数学</category>
        <category>斯特林数</category>
      </categories>
      <tags>
        <tag>斯特林反演</tag>
        <tag>algorithm</tag>
        <tag>斯特林数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 3067 - [USACO12OPEN]平衡的奶牛群]]></title>
    <url>%2F2019%2F01%2FLuogu-3067-USACO12OPEN-%E5%B9%B3%E8%A1%A1%E7%9A%84%E5%A5%B6%E7%89%9B%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[简单的折半搜索。 唯一需要注意的是：对于选出的求相同但组合不同的方案，视作相同，这就意味着我们不能直接进行二分查找搜索区间，需要对区间的每一个元素进行检查，进行判重。 其实这样复杂度是挺大的： What is the computational efficiency? The slow part is going to be the final matching. It’s not obvious how to obtain a tight bound, but an approximation is to note that there are $O(3^{\frac{N}{2}})$ ways to partition subsets of the brown cows, and in the worst case one of these partitions may be matched up with all subsets of the white cows, giving $O(3^{\frac{N}{2}}2^{\frac{N}{2}})$ = $O(6^{\frac{N}{2}})$ time, which is good enough. 同时还有优化： Another optimization that can be made is when trying to match a brown subset with a white subset, one can choose the smaller of the two, iterate over every unbalance of that subset, and then look for that same unbalance in the other subset by doing a lookup into a hash table. This results in a faster but more complex to analyze runtime, which can be shown to be $O((1 + \sqrt {1.5})^N)$ , a bit better than $O((\sqrt 6)^N)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 21#define MAXS 100010typedef long long lint;using namespace std;;int n;int totala, totalb;int v[MAXN];bool visit[1 &lt;&lt; MAXN];struct node &#123; int v, s; node(int v = 0, int s = 0):v(v), s(s) &#123;&#125; &#125;a[MAXS], b[MAXS];bool comp1(node a, node b) &#123; return a.v &lt; b.v;&#125;bool comp2(node a, node b) &#123; return a.v &gt; b.v;&#125;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void DFS(int l, int r, int sum, int state, node* a, int&amp; total) &#123; if (l &gt; r) &#123; a[++total] = node(sum, state); return ; &#125; DFS(l + 1, r, sum + v[l], state | (1 &lt;&lt; (l - 1)), a, total); DFS(l + 1, r, sum - v[l], state | (1 &lt;&lt; (l - 1)), a, total); DFS(l + 1, r, sum, state, a, total);&#125;int main() &#123; n = read(); for (int i = 1; i &lt;= n; ++i) v[i] = read(); DFS(1, (n &gt;&gt; 1), 0, 0, a, totala); DFS((n &gt;&gt; 1) + 1, n, 0, 0, b, totalb); sort(a + 1, a + totala + 1, comp1); sort(b + 1, b + totalb + 1, comp2); lint ans = 0; int l = 1, r = 1; while (l &lt;= totala &amp;&amp; r &lt;= totalb) &#123; while (a[l].v + b[r].v &gt; 0 &amp;&amp; r &lt;= totalb) ++r; int cur = r; while (a[l].v + b[r].v == 0 &amp;&amp; r &lt;= totalb) &#123; if (!visit[a[l].s | b[r].s]) &#123; visit[a[l].s | b[r].s] = true; ++ans; &#125; ++r; &#125; if (a[l + 1].v == a[l].v) r = cur; ++l; &#125; printf("%lld\n", ans - 1);&#125;]]></content>
      <categories>
        <category>搜索</category>
        <category>折半搜索</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>折半搜索</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 4799 - [CEOI2015]世界冰球锦标赛]]></title>
    <url>%2F2019%2F01%2FLuogu-4799-CEOI2015-%E4%B8%96%E7%95%8C%E5%86%B0%E7%90%83%E9%94%A6%E6%A0%87%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[折半搜索，又称 $\operatorname{meet in the middle}$ ，是将一个大问题分成两个不相关的小问题，缩小问题规模，只需要注意最后的答案合并。 这题略简单，直接看代码即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAXN 45typedef long long lint;using namespace std;int n;lint m;lint price[MAXN];lint suma[1 &lt;&lt; 21], sumb[1 &lt;&lt; 21];int totala, totalb;lint read() &#123; char c = getchar(); lint x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void DFS(int l, int r, lint sum, lint* a, int&amp; b) &#123; if (sum &gt; m) return ; if (l &gt; r) &#123; a[++b] = sum; return ; &#125; DFS(l + 1, r, sum + price[l], a, b); DFS(l + 1, r, sum, a, b);&#125;int main() &#123; n = (int)read(); m = read(); for (int i = 1; i &lt;= n; ++i) price[i] = read(); DFS(1, n &gt;&gt; 1, 0, suma, totala); DFS((n &gt;&gt; 1) + 1, n, 0, sumb, totalb); sort(suma + 1, suma + totala + 1); lint ans = 0; for (int i = 1; i &lt;= totalb; ++i) ans += upper_bound(suma + 1, suma + totala + 1, m - sumb[i]) - suma - 1; printf("%lld\n", ans);&#125;]]></content>
      <categories>
        <category>搜索</category>
        <category>折半搜索</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>折半搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prufer序列]]></title>
    <url>%2F2019%2F01%2FPrufer%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[$\operatorname{Prufer}$ 序列是无根树的一种序列。在组合数学中， $\operatorname{Prufer}$ 序列是由一个对于顶点标过号的树转化来的序列，点数为 $n$ 的树转化来的 $\operatorname{Prufer}$ 数列长度为 $n - 2$ 。 对于一棵确定的无根树，对应着唯一确定的 $\operatorname{Prufer}$ 序列。 $\operatorname{Encode}$ 找到编号最小的度数为 $1$ 的点； 删除该节点，添加与该节点相连的节点的编号； 重复 $1, 2$ 操作，直到只剩下两个点。 $\operatorname{Decode}$ 取出 $\operatorname{Prufer}$ 序列最前面的元素 $u$ ； 在点集中找到编号最小没有在 $\operatorname{Prufer}$ 序列中出现过的元素 $v$ ； 连边 $u, v$ ，分别删除； 最后在点集剩下两个节点，给他们连边。 性质 对于一棵确定的无根树，对应着唯一确定的 $\operatorname{Prufer}$ 序列。 $\operatorname{Prufer}$ 序列中某个编号出现的次数就等于这个编号的节点在无根树中的度数$-1$ 。 定理定理一$n$ 个点的无向完全图的有标号无根树的生成树数目为：$n^{n - 2}$ 。 证明只需要证明 $\operatorname{Prufer}$ 序列与无根树唯一对应即可，思考 $\operatorname{Prufer}$ 序列的构造方式，应该不难证明。 引理一$n$ 个点的无向完全图的有标号有根数的生成树数目为： $n^{n - 1}$ 。 定理二$n$ 个点的度数依次是 $d_1, d_2, \cdots, d_n$ 的生成树方案数为：$\frac{(n - 2)!}{\prod_{i = 1}^n(d_i - 1)!}$ 。 证明就是可重集计数问题。]]></content>
      <categories>
        <category>数学</category>
        <category>组合数学</category>
        <category>Prufer序列</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>Prufer序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 2508 - [HAOI2008]圆上的整点]]></title>
    <url>%2F2019%2F01%2FLuogu-2508-HAOI2008-%E5%9C%86%E4%B8%8A%E7%9A%84%E6%95%B4%E7%82%B9%2F</url>
    <content type="text"><![CDATA[这题还是很有意思的。 $\operatorname{3Blue1Brown}$ 显然讲的比我好：隐藏在素数规律中的π，我就稍微讲一下： 首先先定义一个坐标都是整数的点 $p$ ，那么显然可以把 $p$ 看作一个向量，这里需要把它看作复平面上的。 为什么？对于一个复平面上的点 $z = a + bi$ ，其复共轭为 $\overline{z} = a - bi$ ，其相乘就是 $a^2 + b^2$ ，因为 $i = -1$ 。 已知 $r^2 = a^2 + b^2 = z\overline{z}$ ，我们现在需要组合出不同的 $z_1, z_2, \cdots, z_n$ ，如何组合？ 引入一个高斯整数的概念： 高斯整数高斯整数是这样一类数： z = a + bi , a, b \in \mathbb{Z}高斯质数所有不能被分解的高斯整数被称为高斯质数。 高斯整数是高斯质数当且仅当： $a, b$ 中有一个为 $0$ ，且另一个形如 $4n + 3$ ； $a, b$ 均不为 $0$ ，而 $a^2 + b^2$ 为质数。 回到正题，那么对于 $z\overline{z}$ 我们可以继续分解，直到分解成高斯质数为止。 由于 $r^2$ 是整数可以先将其分解质因数。 对于形如 $4n + 3$ 的质数已然是高斯质数，且其复共轭只有他自己，那么其必须成双出现否则无解； 对于形如 $4n + 1$ 的质数可以分解成两个高斯质数的乘积，若其次数为 $k$ ，那么其方案数为 $k + 1$ 。 对于 $2$ ，其不会对答案产生任何影响。因为 $2 = (1 - i)(1 + i)$ ，这两个向量是相互垂直的，对于四个象限而言是等价的。 这题比较简单， $r$ 都是整数，无须多虑，用这种方法解决问题，可以将 $n$ 扩大到 $10^{18}$ 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;typedef long long lint;using namespace std;int prime[] = &#123;0, 2, 3, 5, 61, 24251&#125;;lint n;lint read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;lint mul(lint a, lint b, lint mod) &#123; return ((a * b) - (lint)((long double)a * b / mod) * mod) % mod;&#125;lint power(lint a, lint b, lint mod) &#123; lint res = 1; while (b) &#123; if (b &amp; 1) res = mul(res, a, mod); a = mul(a, a, mod); b &gt;&gt;= 1; &#125; return res;&#125;bool isprime(lint x) &#123; if (x == 2) return true; if (x &lt;= 1 || !(x &amp; 1)) return false; for (int i = 1; i &lt;= 5 &amp;&amp; prime[i] &lt; x; ++i) &#123; lint y = x - 1; while (!(y &amp; 1)) y &gt;&gt;= 1; lint t = power(prime[i], y, x); while (t != x - 1 &amp;&amp; t != 1 &amp;&amp; y != x - 1) &#123; t = mul(t, t, x); y &lt;&lt;= 1; &#125; if ((t != 1 &amp;&amp; t != x - 1) || (t == 1 &amp;&amp; !(y &amp; 1))) return false; &#125; return true;&#125;lint irand(lint mod) &#123; return 1ll * rand() * rand() % mod;&#125;lint gcd(lint a, lint b) &#123; return !b ? a : gcd(b, a % b);&#125;lint factorize(lint x) &#123; int s = 1, t = 2; lint c = irand(x), u = irand(x), v = u; while (true) &#123; ++s; u = (mul(u, u, x) + c) % x; lint d = gcd(abs(v - u), x); if (d &gt; 1 &amp;&amp; d &lt; x) return d; if (v == u) return x; if (s == t) &#123; v = u; t &lt;&lt;= 1; &#125; &#125;&#125;void divide(lint x, vector&lt;lint&gt;&amp; factor) &#123; if (x == 1) return ; if (isprime(x)) &#123; factor.push_back(x); return ; &#125; lint p; do p = factorize(x); while (p == x); while (x % p == 0) x /= p; divide(x, factor); divide(p, factor);&#125;int main() &#123; lint n = read(); vector&lt;lint&gt; factor; divide(n, factor); lint ans = 1; for (int i = 0; i &lt; factor.size(); ++i) if (factor[i] % 4 == 1 || factor[i] % 4 == 3) &#123; lint sum = 0; while (!(n % factor[i])) &#123; n /= factor[i]; sum += 2; &#125; if (factor[i] % 4 == 1) ans = ans * (sum + 1); &#125; printf("%lld\n", ans * 4);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>质数</category>
        <category>Pollard Rho</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>随机</tag>
        <tag>质数</tag>
        <tag>高斯整数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pollard Rho]]></title>
    <url>%2F2019%2F01%2FPollard-Rho%2F</url>
    <content type="text"><![CDATA[$\operatorname{Pollard Rho}$ 是一种用于大整数分解质因数的随机化算法，其复杂度约为：$O(n^{\frac{1}{4}})$ 。 当然，前置知识是 $\operatorname{Miller Rabin}$ 算法。 原理分解质因数首先需要找到因数，我们先把因数看作一个目标点 $p$ 。 在 $1 \sim n$ 找到的概率为 $\frac{1}{n}$ ；在 $1 \sim \sqrt n$ 找到的概率为 $\frac{1}{\sqrt n}$ 。 前者复杂度显然错误，后者不如枚举。 考虑作差的形式：添加一个点 $a$ ，则 $a - p$ 和 $a + p$ 都是我们的目标点。 如果我们添加 $m$ 个点进去，那么我们将有 $2m$ 个目标点，稍微做个简化：依次加入一个点并且作差判断是否是因数，那么可以求出概率： P(F) = 1 - \prod_{i = 1}^{m - 1} \frac{n - i}{n} \\ = 1 - \frac{n!}{n^{m}(n - m)!}可以算出在 $m = \sqrt n$ 时约为 $50\%$ ，其实 $m = 2 \sqrt n$ 是就趋近于 $100\%$ ，但这样还是不够优秀。 如果找到因数的倍数也算成立，那么由于 $n$ 一定存在因数 $a$ 有 $\sqrt n$ 个倍数在范围内，那么概率为： P(F) = 1 - \prod_{i = 1}^{m - 1} \frac{\sqrt n - i}{\sqrt n} \\ = 1 - \frac{\sqrt n!}{\sqrt{n}^m(\sqrt n - m)!}那么现在 $m = \sqrt[4]{n}$ 时就约为 $50\%$ 了。 实现原理解析完了，但是实现还是有区别的。 如果两两枚举 $\sqrt[4]{n}$ 个点作差求解，复杂度仍然错误，所以需要循环 。 我们设 $g(x) = x^2 + c$ ，$c$ 是我们自己设定的常数。由于是在模 $ n$ 的意义下，显然会出现循环。如果找到循环却没有找到因数，那么我们换一个常数 $c$ 重新校验。那么现在有一个问题：如何判环？ 使用 $brent$ 判环法。首先该环并非普通的环，其形状像 $P$ ，我们先规定环的长度与起点 $v$ ，每次判断一点 $u$ 是否与 $v$ 相等，相等成环；反之若长度到达上限，起点 $v = u$ ，倍增环的长度。 代码$\operatorname{isprime}(x)$ 使用 $\operatorname{Miller Rabin}$ 算法判断。 12345678910111213141516171819202122232425262728293031323334353637383940414243typedef long long lint;lint gcd(lint a, lint b) &#123; return !b ? a : gcd(b, a % b);&#125;lint irand(lint mod) &#123; return 1ll * rand() * rand() % (mod - 1) + 1;&#125;lint factorize(lint x) &#123; int s = 1, t = 2; lint c = irand(x), u = irand(x), v = u; while (true) &#123; ++s; u = (mul(u, u, x) + c) % x; lint d = gcd(abs(v - u), x); if (d &gt; 1 &amp;&amp; d &lt; x) return d; if (v == u) return x; if (s == t) &#123; t &lt;&lt;= 1; v = u; &#125; &#125;&#125;void divide(lint x, vector&lt;lint&gt;&amp; factor) &#123; if (x &lt;= 1) return ; if (isprime(x)) &#123; factor.push_back(x); return ; &#125; lint p; do p = factorize(x); while (p == x); while (x % p == 0) x /= p; divide(x, factor); divide(p, factor);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>质数</category>
        <category>Pollard Rho</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>随机</tag>
        <tag>质数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉准则]]></title>
    <url>%2F2019%2F01%2F%E6%AC%A7%E6%8B%89%E5%87%86%E5%88%99%2F</url>
    <content type="text"><![CDATA[欧拉准则适用于判定给定整数是否是一个质数的二次剩余。 结论若 $p$ 是奇素数且 $p \nmid d$ ： $d$ 是模 $p$ 的二次剩余当且仅当： d^{\frac{p - 1}{2}} \equiv 1 \pmod{p}$d$ 是模 $p$ 的非二次剩余当且仅当： d^{\frac{p - 1}{2}} \equiv -1 \pmod{p}证明由费马小定理：$d^{p - 1} \equiv 1 \pmod{p}$ ，且 $p - 1$ 是偶数： (d^{\frac{p - 1}{2}} - 1)(d^{\frac{p - 1}{2}} + 1) \equiv 0 \pmod{p}则 $d^{\frac{p - 1}{2}} \equiv 1$ 或 $d^{\frac{p - 1}{2}} \equiv -1$ 。 证明若 $d$ 是模 $p$ 的二次剩余，则 $d^{\frac{p - 1}{2}} \equiv 1 \pmod{p}$ 由于 $x^2 \equiv d \pmod{p}$ ，$p$ 和 $d,x$ 互质： d^{\frac{p - 1}{2}} \equiv x^{p - 1} \equiv 1 \pmod{p} 证明若 $d^{\frac{p - 1}{2}} \equiv 1 \pmod{p}$ ，则$d$ 是模 $p$ 的二次剩余 $p$ 是一个奇素数，所以关于 $p$ 的原根存在。设 $a$ 是 $p$ 的一个原根，则存在$1\leq j\leq p-1$ 使得 $d=a^{j}$ 。于是： a^{j\frac{p - 1}{2}} \equiv 1 \pmod{p}​ 由于 $a$ 是 $p$ 的一个原根，所以：$(p - 1) | \frac{j(p - 1)}{2}$ 。则 $j$ 是偶数。令 $i = \frac{j}{2}$ ，有 $(a^i)^2 = a^{2i} = d$。]]></content>
      <categories>
        <category>数学</category>
        <category>数论</category>
        <category>二次剩余</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>二次剩余</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二次剩余]]></title>
    <url>%2F2019%2F01%2F%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99%2F</url>
    <content type="text"><![CDATA[二次剩余主要用来求解一下方程： x^2 \equiv d \pmod{p}此时称作 $d$ 是模 $p$ 的二次剩余。 质数二次剩余对于 $p = 2$，显然成立； 对于 $p \ne 2$，满足的 $d$ 有 $\frac{p + 1}{2}$ 个，分别为： 0^2, 1^2, \cdots, (\frac{p - 1}{2} - 1)^2, (\frac{p - 1}{2})^2运用欧拉准则可以推导。 质数乘方的二次剩余咕咕咕]]></content>
      <categories>
        <category>数学</category>
        <category>数论</category>
        <category>二次剩余</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>二次剩余</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Miller Rabin]]></title>
    <url>%2F2019%2F01%2FMiller-Rabin%2F</url>
    <content type="text"><![CDATA[$\operatorname{Miller \ Rabin}$ 算法是一种以 $O(\log n)$ 的时间校验一个数是否是质数的算法，其主要是利用了费马小定理与随机化思想。 过程费马小定理校验费马小定理：若 $p$ 是质数，有： a^{p - 1} \equiv 1 \pmod{p}费马小定理逆命题：若对于 $\forall a, a \in (1, p)$ 满足上式，那么 $p$ 是质数。 是错误的，但是正确率仍然挺高。 二次探测定理校验若 $p$ 是质数，那么 $x ^ 2 \equiv 1 \pmod{p}$ 只有两个解：$x = 1$ 或 $x = p - 1$ 。 综合校验对于 $\forall a$ ，有： a^{p - 1} \equiv 1 \pmod{p}其中： p - 1 = d\times 2^r则： a^{d \times 2^r} \equiv 1 \pmod{p} \\ (a^{d \times 2^{r - 1}})^2 \equiv 1 \pmod{p} \\ 若 $a ^ {d \times 2^{r - 1}}$ 不是 $1$ 或 $p - 1$ ，$p$ 不是质数； 若 $a^{d \times 2^{r - 1}}$ 是 $1$ ，则要继续至 $a^d$； 若 $a^{d \times 2^{r - 1}}$ 是 $p - 1$ ，显然成立。 实现时，我们反过来操作，即从 $a^d \rightarrow a^{d \times 2^{r - 1}}$ ： 若出现 $p - 1$ ，是质数； 若出现 $1$ ，则 $a^d$ 是质数； 反之不是质数。 代码这份代码所选取的 $5$ 个质数只有在 $46856248255981$ 会误判成质数，特判一下即可。 1234567891011121314151617181920212223242526272829303132333435363738typedef long long lint;int prime[] = &#123;2, 3, 5, 61, 24251&#125;;lint mul(lint a, lint b, lint mod) &#123; return (a * b - (lint)((long double)a * b / mod) * mod + mod) % mod;&#125;lint power(lint a, lint b, lint mod) &#123; lint res = 1; while (b) &#123; if (b &amp; 1) res = mul(res, a, mod); a = mul(a, a, mod); b &gt;&gt;= 1; &#125; return res;&#125;bool isprime(lint x) &#123; if (x == 2) return true; if (x &lt;= 1 || !(x &amp; 1) || x == 46856248255981ll) return false; for (int i = 1; i &lt;= 5 &amp;&amp; prime[i] &lt; x; ++i) &#123; lint y = x - 1; while (!(y &amp; 1)) y &gt;&gt;= 1; lint t = power(prime[i], y, x); while (t != 1 &amp;&amp; t != x - 1 &amp;&amp; y != x - 1) &#123; t = mul(t, t, x); y &lt;&lt;= 1; &#125; if ((t != x - 1 &amp;&amp; t != 1) || (t == 1 &amp;&amp; !(y &amp; 1))) return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>质数</category>
        <category>Miller Rabin</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>随机</tag>
        <tag>质数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 4565 - [CTSC2018]暴力写挂]]></title>
    <url>%2F2019%2F01%2FLuogu-4565-CTSC2018-%E6%9A%B4%E5%8A%9B%E5%86%99%E6%8C%82%2F</url>
    <content type="text"><![CDATA[给定两棵树 $f, g$ ，要求： \max f_u + f_v - f_{\operatorname{LCA}(u, v)} - g_{\operatorname{LCA}(u, v)}$f_i$ 是 $i$ 在 $f$ 中的深度。 这是有根树的情况，我们先把它转换成无根树： max \frac{1}{2}(\operatorname{dis}(u, \operatorname{LCA}(u, v)) + \operatorname{dis}(v, \operatorname{LCA}(u, v)) + f_u + f_v) - g_{\operatorname{LCA}(u, v)}发现这个式子，后面的 $g_{\operatorname{LCA(u, v)}}$ 非常难以解决，不如直接在 $g$ 中枚举一个点作为 $\operatorname{LCA}(u, v)$ ，并统计其不同子树中的点的答案，此时我们规定了答案点集：答案只能由 $f​$ 的这些点产生。 继续观察上式，不难发现其贡献为： $\operatorname{dis}(u, \operatorname{LCA}(u, v)) + f_u​$ 。考虑边分治，我们将 $\operatorname{dis}(u, \operatorname{LCA}(u, v)) + \operatorname{dis}(v, \operatorname{LCA}(u, v))​$ 看作一条 $u \rightarrow v​$ 的路径。那么对于边分治中心 $i​$ ，计算通过 $i​$ 的路径的最大值。 不难发现如果此时没有了答案点集的限定，问题已经解决了。那么考虑答案点集的情况，可以发现边分树形如线段树。这就意味着是可以进行线段树合并的。对于一个分治中心 $w$ 维护 $\operatorname{lmax}(w)$ 和 $\operatorname {rmax}(w)$ ，表示其左子树的 $\operatorname{dis}(u, w) + f_u$ 的最大值和右子树 $\operatorname{dis}(v, w) + f_v$ 的最大值。每次计算 $g$ 时依次添加点，该点贡献在边分树中到根的链，合并时统计答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define INF 0x3f3f3f3f3f3f3f3f#define MAXN 750010typedef long long lint;using namespace std;int n;int amount;lint mini;int root;int size[MAXN], fa[MAXN &lt;&lt; 1], ch[MAXN &lt;&lt; 1][2], level[MAXN];lint dep[MAXN];lint dis[25][MAXN], lmax[MAXN &lt;&lt; 4], rmax[MAXN &lt;&lt; 4];int lson[MAXN &lt;&lt; 4], rson[MAXN &lt;&lt; 4];int val[MAXN &lt;&lt; 1], r[MAXN &lt;&lt; 1];lint ans;bool visit[MAXN &lt;&lt; 1];int record[MAXN &lt;&lt; 4];struct data &#123; int next, to, cost; data(int next = 0, int to = 0, int cost = 0):next(next), to(to), cost(cost) &#123;&#125;&#125;q[MAXN &lt;&lt; 1];struct graph &#123; int head[MAXN], cnt; data edge[MAXN &lt;&lt; 1]; graph() &#123; memset(head, 0, sizeof(head)); cnt = 1; &#125; void connect(int u, int v, int w) &#123; edge[++cnt] = data(head[u], v, w); head[u] = cnt; &#125; void construct(int u, int v, int w) &#123; connect(u, v, w); connect(v, u, w); &#125;&#125;f, g, h;int read() &#123; char c = getchar(); int x = 0, s = 1; while (!isdigit(c)) &#123; if (c == '-') s = -1; c = getchar(); &#125; while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x * s;&#125;void rebuild(int u, int pre) &#123; for (int i = f.head[u]; i; i = f.edge[i].next) &#123; int v = f.edge[i].to, w = f.edge[i].cost; if (v == pre) continue; dep[v] = dep[u] + w; rebuild(v, u); &#125; int head = 1, tail = 0; for (int i = f.head[u]; i; i = f.edge[i].next) &#123; int v = f.edge[i].to; if (v == pre) continue; q[++tail] = f.edge[i]; &#125; while (tail - head &gt;= 2) &#123; data a = q[head++], b = q[head++]; int c = ++n; h.construct(a.to, c, a.cost); h.construct(b.to, c, b.cost); q[++tail] = data(0, c, 0); &#125; while (head &lt;= tail) &#123; h.construct(q[head].to, u, q[head].cost); ++head; &#125;&#125;void getroot(int u, int pre, int sum) &#123; size[u] = 1; for (int i = h.head[u]; i; i = h.edge[i].next) &#123; int v = h.edge[i].to; if (v == pre || visit[i &gt;&gt; 1]) continue; getroot(v, u, sum); size[u] += size[v]; int res = max(size[v], sum - size[v]); if (res &lt; mini) &#123; mini = res; root = i; &#125; &#125;&#125;void DFS(int u, int pre, int dep) &#123; for (int i = h.head[u]; i; i = h.edge[i].next) &#123; int v = h.edge[i].to, w = h.edge[i].cost; if (v == pre || visit[i &gt;&gt; 1]) continue; dis[dep][v] = dis[dep][u] + w; DFS(v, u, dep); &#125;&#125;int insert(int u) &#123; int origin = u; for (int i = level[u], last = 0; i; --i, u = fa[u], last = amount) &#123; int x = ++amount; lmax[x] = rmax[x] = -INF; record[x] = fa[u]; if (ch[fa[u]][0] == u) &#123; lson[x] = last; lmax[x] = dis[i][origin] + dep[origin]; &#125; else &#123; rson[x] = last; rmax[x] = dis[i][origin] + dep[origin]; &#125; &#125; return amount;&#125;int merge(int u, int v, lint d) &#123; if (!u || !v) return u + v; ans = max(ans, ((lmax[u] + rmax[v] + val[record[u]]) &gt;&gt; 1) - d); ans = max(ans, ((rmax[u] + lmax[v] + val[record[u]]) &gt;&gt; 1) - d); lmax[u] = max(lmax[u], lmax[v]); rmax[u] = max(rmax[u], rmax[v]); lson[u] = merge(lson[u], lson[v], d); rson[u] = merge(rson[u], rson[v], d); return u;&#125;int build(int u, int l, int sum) &#123; mini = INF; DFS(u, 0, l); getroot(u, 0, sum); if (mini == INF) &#123; level[u] = l; return u; &#125; visit[root &gt;&gt; 1] = true; int cur = ++n; val[cur] = h.edge[root].cost; int v = h.edge[root].to, w = h.edge[root ^ 1].to; int sv = size[v], sw = sum - sv; fa[ch[cur][0] = build(v, l + 1, sv)] = cur; fa[ch[cur][1] = build(w, l + 1, sw)] = cur; return cur;&#125;void solve(int u, int pre, lint d) &#123; r[u] = insert(u); ans = max(ans, dep[u] - d); for (int i = g.head[u]; i; i = g.edge[i].next) &#123; int v = g.edge[i].to; if (v == pre) continue; solve(v, u, d + g.edge[i].cost); r[u] = merge(r[u], r[v], d); &#125;&#125;int main() &#123; n = read(); for (int i = 1; i &lt; n; ++i) &#123; int u = read(), v = read(), w = read(); f.construct(u, v, w); &#125; for (int i = 1; i &lt; n; ++i) &#123; int u = read(), v = read(), w = read(); g.construct(u, v, w); &#125; rebuild(1, 0); build(1, 0, n); solve(1, 0, 0); printf("%lld\n", ans);&#125;]]></content>
      <categories>
        <category>思维</category>
        <category>分治</category>
        <category>树分治</category>
        <category>边分治</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>边分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matrix Tree 定理]]></title>
    <url>%2F2019%2F01%2FMatrix-Tree-%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[基尔霍夫矩阵定义设度数矩阵$D$ ，$\forall D[i][j] = 0\ (i \neq j), D[i][i] = deg(i)$ ，设邻接矩阵$G$。 则基尔霍夫矩阵$K = D - G$ 。 Matrix Tree定理定理基尔霍夫矩阵的 $n - 1$ 阶子式的行列式的绝对值就是最小生成树的方案数。]]></content>
      <categories>
        <category>图论</category>
        <category>生成树</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>algorithm</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性代数]]></title>
    <url>%2F2019%2F01%2F%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%2F</url>
    <content type="text"><![CDATA[简单介绍一下 $OI$ 中需要运用到的线性代数知识。 线性基础线性组合 w = a_1v_1 + a_2v_2 + \cdots a_nv_n线性相关向量空间的一组元素中，若没有向量可用有限个其他向量的线性组合表示，则称为线性无关，反之称为线性相关。 矩阵一个 $n$ 阶矩阵可以作为一个 $n$ 阶向量的线性变换。 行列式是数学中的一个函数，推导特征多项式以及基尔霍夫矩阵时用到。 他的意义是将一个 $n \times n$ 的矩阵映射到一个标量，记作 $\det{A}$ 或 $|A|$ ，其可以看作是有向面积或体积在 $n$ 维的欧几里得空间的扩展。 一个 $n$ 阶矩阵行列式的定义： |A| = \sum \limits_{\sigma \in S_n}\operatorname {sgn}(\sigma) \prod \limits_{i = 1}^n a_{i, \sigma(i)}其中， $S_n$ 表示 $1 \sim n$ 的全排列集合，$\operatorname{sgn(\sigma)}$ 表示 $\sigma$ 的逆序对个数。 直接求解复杂度显然是 $O(n \times n!)$ ，可以发现对于一个上三角矩阵： \begin {bmatrix} a_{1, 1} & a_{1, 2} & \cdots & a_{1, n} \\ 0 & a_{2, 2}& \cdots & a_{2, n} \\\ \vdots & \vdots & \ddots & \vdots \\ 0 & 0 & \cdots & a_{n, n} \end {bmatrix}其行列式为： $\prod \limits_{i = 1}^n a_{i, i}$ ，利用高斯消元消出上三角矩阵可以优化到 $O(n^3)$ 。 同时，对于一个上海森堡矩阵： \begin {bmatrix} a_{1, 1} & a_{1, 2} & \cdots & a_{1, n - 1} & a_{1, n} \\ a_{1, 2} & a_{2, 2}& \cdots & a_{2, n - 2} & a_{2, n} \\\ 0 & a_{2, 2}& \cdots & a_{3, n - 2} & a_{2, n} \\\ \vdots & \vdots & \ddots & \vdots & \vdots \\ 0 & 0 & \cdots & a_{n, n - 1} & a_{n, n} \end {bmatrix}其行列式求解为 $O(n^2)$ 。 性质 交换行列式两行，行列式变号。 若矩阵有两行（列）完全相同，则行列式为 $0$ 。 若矩阵的某一行（列）都乘上 $k$ ，行列式的值也乘上 $k$ 。 若矩阵有两行（列）成比，则行列式为 $0$ 。 若矩阵的某一行（列）加上另一行（列）的 $k$ 倍，则行列式的值不变。 初等变换 两行（列）互换： $R_i\leftrightarrow R_j$ $|A| = -|A|$ 某行（列）乘以非 $0$ 常数： $kR_i \rightarrow R_i$ $|A| = k|A|$ 某行（列）加上第 $j$ 行（列）的 $k$ 倍： $R_i + kR_j \rightarrow R_i$ $|A| = |A|$ 秩一个矩阵 $A$ 的列秩指的是 $A$ 的线性无关的纵列的极大数目，行秩指的是 $A$ 线性无关的横行的极大数目。 性质 矩阵的列秩与行秩相等。 矩阵的初等变换不改变矩阵的秩。 特征值和特征向量定义给定一个线性变换 $A$ ，其特征向量 $v$ 满足： Av = \lambda v即与原来保持在同一直线上，长度或方向也许会改变，$\lambda$ 为标量，成为特征值。 性质一个线性变换可以由其特征值和特征向量来完全表述，意即所有的特征向量组成了这向量空间的一组基底。 一个特征空间是具有相同特征值的特征向量与一个同维数的零向量的集合。 结论 一个 $n$ 阶矩阵满秩，那么 $A$ 有 $n$ 组线性无关的特征向量。 当且仅当 $|\lambda I - A| = 0$ 时，存在 $v$ 存在特征向量。 Carley Hamilton 定理$A$ 为 $n$ 阶矩阵，$I_n$ 为 $n$ 阶单位矩阵，其特征多项式定义为： p(\lambda) = \det(\lambda I_n - A)定理为： p(A) = 0]]></content>
      <categories>
        <category>数学</category>
        <category>高等</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性递推]]></title>
    <url>%2F2019%2F01%2F%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8%2F</url>
    <content type="text"><![CDATA[本文将讲述解决线性递推的不同方法。 定义 g_m = \sum \limits_{i = 1}^n f_i \times g_{k - i}求解 $g_m$ 。 矩阵加速递推对于任意一种递推式我们显然可以矩阵加速解决，构建转移矩阵： A = \begin{bmatrix} f_1 & f_2 & \cdots & f_{n - 1} & f_n \\ 1 & 0 & \cdots & 0 & 0 \\ 0 & 1 & \cdots & 0 & 0 \\ \vdots & \vdots & \ddots & \vdots & \vdots \\ 0 & 0 & \cdots & 1 & 0 \end{bmatrix}矩阵快速幂即可，复杂度 $O(m^3 \log n)$ ，好写，但代码复杂度极高，答案为： s = g_0A^n特征多项式加速递推首先有： \lambda I_n - A = \begin{bmatrix} \lambda - f_1 & f_2 & \cdots & f_{n - 1} & f_n \\ -1 & \lambda & \cdots & 0 & 0 \\ 0 & -1 & \cdots & 0 & 0 \\ \vdots & \vdots & \ddots & \vdots & \vdots \\ 0 & 0 & \cdots & -1 & \lambda \end{bmatrix}其特征多项式为： p(\lambda) = \lambda^n - \sum \limits_{i = 1}^n f_i\lambda^{n - i}根据 Carley Hamilton 定理： p(A) = A^n - \sum \limits_{i = 1}^n f_iA^{n - i} = 0\\ A^n = \sum \limits_{i = 1}^nf_iA^{n - 1} \\这就意味着，$A^k$ 可以被 $A^0 \sim A^{n - 1}$ 的矩阵表达，考虑一下过程： A^x = \sum \limits_{i = 0}^{n - 1} b_iA^i \\ A^y = \sum \limits_{i = 0}^{n - 1} c_iA^i \\ A^{x + y} = \sum \limits_{i = 0}^{n - 1} \sum \limits_{j = 0}^{n - 1}b_ic_jA^{i + j} \\ = \sum \limits_{i = 0}^{2n - 2}A^i \sum \limits_{j = \max(0, i - n)}^{\min(i,n - 1)} b_jc_{i- j} \bmod p(A)由于最后答案为 $A^m_{1, 1}$ 。​所以对于每一个 $A^i$ ，我们都只要记入 $A^i_{1, 1}$。 后面是卷积，$NTT$ 优化即可。]]></content>
      <categories>
        <category>数学</category>
        <category>高等</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>递推</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 3638 - [APIO2013]机器人]]></title>
    <url>%2F2019%2F01%2FLuogu-3638-APIO2013-%E6%9C%BA%E5%99%A8%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[挺显然的是斯坦纳树，$f_{l, r, x, y}$ 表示合成等级 $l \sim r$ 的机器人，以 $x$ 为根所需的最小代价。不改变根的转移为： f_{l, r, x} = \min \limits_{k \in [l, r)} f_{l, k, x} + f_{k + 1, r, x}区间 $DP$ 转移即可。 改变根的转移为： f_{l, r, x} = \min f_{l, r, y} + 1其中，$y$ 是推动一次可以到达 $x​$ 的点，可以预处理出来。 那么简单 $SPFA$ 转移即可。这题比较坑的是直接 $SPFA$ 会 $TLE$ ，需要 $SLF$ 优化也不能通过，需要用一种全新的优化方式：设两个队列 $q_1, q_2$ 。 $q_1$ 存的是初始节点，按 $f$ 排序，注意此处要计数排序否则很容易超时；$q_2$ 存储的是松弛操作过后可以松弛别的点的点。 优先取 $f$ 较小的节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;iostream&gt;#define INF 0x3f3f3f3f#define MAXR 505#define MAXN 10using namespace std;int n, R, C;int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;char a[MAXR][MAXR];int temp[MAXR * MAXR];bool inq[MAXR * MAXR];int f[MAXN][MAXN][MAXR * MAXR], tag[MAXR][MAXR];int head[MAXR * MAXR], cnt, total;int g[MAXR][MAXR][5];int sum[MAXR * MAXR];bool visit[MAXR][MAXR][5];struct data &#123; int next, to; data(int next = 0, int to = 0):next(next), to(to) &#123;&#125;&#125;edge[MAXR * MAXR * 4];struct node &#123; int x, y; node (int x = 0, int y = 0):x(x), y(y) &#123;&#125;&#125;;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;bool islegal(int x, int y) &#123; return x &gt;= 1 &amp;&amp; x &lt;= R &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= C;&#125;int encode(int x, int y) &#123; return tag[x][y];&#125;int DP(int x, int y, int k) &#123; if (visit[x][y][k]) return g[x][y][k] = -1; if (g[x][y][k] != -2) return g[x][y][k]; visit[x][y][k] = true; int nx = x + dx[k], ny = y + dy[k]; if (a[nx][ny] == 'x' || !islegal(nx, ny)) g[x][y][k] = encode(x, y); else if (a[nx][ny] == 'A') g[x][y][k] = DP(nx, ny, (k + 3) % 4); else if (a[nx][ny] == 'C') g[x][y][k] = DP(nx, ny, (k + 1) % 4); else g[x][y][k] = DP(nx, ny, k); visit[x][y][k] = false; return g[x][y][k];&#125;void connect(int u, int v) &#123; edge[++cnt] = data(head[u], v); head[u] = cnt;&#125;int A, B;bool comp(int a, int b) &#123; return f[A][B][a] &lt; f[A][B][b];&#125;void sort(int* f) &#123; int maxi = 0; for(int i = 1; i &lt;= total; ++i) if (f[i] != INF) maxi = max(maxi, f[i]); for(int i = 1; i &lt;= total; ++i) if (f[i] != INF) sum[f[i]]++; for(int i = 1; i &lt;= maxi; ++i) sum[i] += sum[i - 1]; for(int i = total; i &gt;= 1; --i) if (f[i] != INF) temp[sum[f[i]]--] = i; for(int i = 1; i &lt;= total; ++i) if (f[i] != INF) inq[i]=true; for(int i = 0; i &lt;= maxi; ++i) sum[i] = 0;&#125;void SPFA(int l, int r) &#123; memset(inq, 0, sizeof(inq)); queue&lt;int&gt; q1, q2; sort(f[l][r]); for (int i = 1; i &lt;= total; ++i) q1.push(temp[i]); while (!q1.empty() || !q2.empty()) &#123; int u; if (!q1.empty() &amp;&amp; (q2.empty() || f[l][r][q1.front()] &lt;= f[l][r][q2.front()])) &#123; u = q1.front(); q1.pop(); &#125; else &#123; u = q2.front(); q2.pop(); &#125; inq[u] = false; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to; if (f[l][r][v] &gt; f[l][r][u] + 1) &#123; f[l][r][v] = f[l][r][u] + 1; if (!inq[v]) &#123; inq[v] = true; q2.push(v); &#125; &#125; &#125; &#125;&#125;void init() &#123; memset(f, INF, sizeof(f)); for (int i = 1; i &lt;= R; ++i) for (int j = 1; j &lt;= C; ++j) for (int k = 0; k &lt; 4; ++k) g[i][j][k] = -2;&#125;int main() &#123; n = read(); C = read(); R = read(); init(); for (int i = 1; i &lt;= R; ++i) &#123; scanf("%s", a[i] + 1); for (int j = 1; j &lt;= C; ++j) &#123; if (a[i][j] != 'x') tag[i][j] = ++total; if (isdigit(a[i][j])) f[a[i][j] - '0'][a[i][j] - '0'][encode(i, j)] = 0; &#125; &#125; for (int i = 1; i &lt;= R; ++i) for (int j = 1; j &lt;= C; ++j) &#123; if (a[i][j] == 'x') continue; for (int k = 0; k &lt; 4; ++k) &#123; DP(i, j, k); if (g[i][j][k] != encode(i, j) &amp;&amp; g[i][j][k] != -1) connect(encode(i, j), g[i][j][k]); &#125; &#125; for (int i = 1; i &lt;= n; ++i) for (int l = 1; l + i - 1 &lt;= n; ++l) &#123; int r = l + i - 1; for (int x = 1; x &lt;= total; ++x) for (int k = l; k &lt; r; ++k) f[l][r][x] = min(f[l][r][x], f[l][k][x] + f[k + 1][r][x]); SPFA(l, r); &#125; int ans = INF; for (int i = 1; i &lt;= total; ++i) ans = min(ans, f[1][n][i]); printf("%d\n", ans == INF ? -1 : ans);&#125;]]></content>
      <tags>
        <tag>solution</tag>
        <tag>斯坦纳树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 4294 - [WC2008]游览计划]]></title>
    <url>%2F2019%2F01%2FLuogu-4294-WC2008-%E6%B8%B8%E8%A7%88%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[要求一条路径，使所有景点相连，代价最小。 思考一下不难发现是斯坦纳树的模型。斯坦纳树是这样一类问题：带边权无向图上有约为 $10$ 个点是关键点，要求选择一些边使这些点在同一个联通块内，同时要求所选的边的边权和最小。 一般对于这种问题，我们都是采用斯坦纳树解决。$f_{i, j}$ 表示以 $i$ 为根，关键点选择状态为 $j$ 的最小代价。 当根不改变时，只需要合并两个同时包含 $i$ 的联通块： f_{i, j} = \min \limits_{k \in j} f_{i, k} + f_{i, j - k} - v_i当根改变时，重新设置一个点为根： f_{i, j} = \min f_{k, j} + v_i对于第一个方程，使用状压 $DP$ 直接更新；对于第二个方程，没有明显的顺序。但发现其形式类似于 $SPFA$ 的松弛操作，利用 $SPFA$ 更新。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define MAXN 12#define INF 0x3f3f3f3fusing namespace std;int n, m, total;int f[MAXN][MAXN][1 &lt;&lt; MAXN], a[MAXN][MAXN];bool inq[MAXN][MAXN];int dx[] = &#123;0, 1, 0, -1, 0&#125;, dy[] = &#123;0, 0, 1, 0, -1&#125;;bool isarrange[MAXN][MAXN];struct data &#123; int x, y, s; data(int x = 0, int y = 0, int s = 0):x(x), y(y), s(s) &#123;&#125;&#125;g[MAXN][MAXN][1 &lt;&lt; MAXN], source;struct node &#123; int x, y; node (int x = 0, int y = 0):x(x), y(y) &#123;&#125;&#125;;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;bool islegal(int x, int y) &#123; return x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m;&#125;void SPFA(int k) &#123; memset(inq, 0, sizeof(inq)); queue&lt;node&gt; q; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) if (f[i][j][k] != INF) &#123; inq[i][j] = true; q.push(node(i, j)); &#125; while (!q.empty()) &#123; node u = q.front(); inq[u.x][u.y] = 0; q.pop(); for (int i = 1; i &lt;= 4; ++i) &#123; int x = u.x + dx[i], y = u.y + dy[i]; if (!islegal(x, y)) continue; if (f[x][y][k] &gt; f[u.x][u.y][k] + a[x][y]) &#123; f[x][y][k] = f[u.x][u.y][k] + a[x][y]; g[x][y][k] = data(u.x, u.y, k); if (!inq[x][y]) &#123; q.push(node(x, y)); inq[x][y] = true; &#125; &#125; &#125; &#125;&#125;void get(int x, int y, int s) &#123; if (!x) return ; isarrange[x][y] = true; data source = g[x][y][s]; get(source.x, source.y, source.s); if (source.s != s) get(source.x, source.y, s ^ source.s); &#125;int main() &#123; n = read(); m = read(); memset(f, INF, sizeof(f)); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; a[i][j] = read(); if (!a[i][j]) f[i][j][1 &lt;&lt; (total++)] = 0; &#125; int limit = (1 &lt;&lt; total) - 1; for (int s = 1; s &lt;= limit; ++s) &#123; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) for (int t = (s - 1) &amp; s; t; t = (t - 1) &amp; s) if (f[i][j][s] &gt; f[i][j][s - t] + f[i][j][t] - a[i][j]) &#123; f[i][j][s] = f[i][j][s - t] + f[i][j][t] - a[i][j]; g[i][j][s] = data(i, j, t); &#125; SPFA(s); &#125; int ans = INF; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) if (f[i][j][limit] &lt; ans) &#123; ans = f[i][j][limit]; source = data(i, j, limit); &#125; printf("%d\n", ans); get(source.x, source.y, source.s); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) if (!a[i][j]) printf("x"); else if (isarrange[i][j]) printf("o"); else printf("_"); puts(""); &#125;&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>斯坦纳树</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>斯坦纳树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 3978 - [TJOI2015]概率论]]></title>
    <url>%2F2019%2F01%2FLuogu-3978-TJOI2015-%E6%A6%82%E7%8E%87%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[求一棵所有互相不同构的形态等概率出现的左右子树交换视作不同的二叉树的叶子结点数的期望。 设 $f_i$ 为 $i$ 个点的树的所有形态的叶子结点的总和， $g_i$ 为 $i$ 个点的数所有形态的数目，那么答案为 $\frac{f_n}{g_n}$ 。 对于 $g$ 可以轻松的列出方程： g_0 = 1 \\ g_n = \sum \limits_{i = 0}^{n - 1}g_ig_{n - i - 1} \\打表找规律 $n$ $1$ $2$ $3$ $4$ $5$ $\cdots$ $g_n$ $1$ $2$ $5$ $4$ $42$ $\cdots$ $f_n$ $1$ $2$ $6$ $20$ $70$ $\cdots$ 发现 $g$ 即卡特兰数，$f_n = ng_{n - 1}$ 。 借鉴下 $rqy$ 的题解，关于 $f_n$ 可以这么理解： 对于一棵有 $k$ 个叶子结点的树，分别删去得到 $k$ 棵 $n - 1$ 个结点的树； 对于一棵有 $n - 1$ 个节点的树，显然有 $n$ 个位置能够插入一个叶子结点，所以其贡献 $n$ 次； 那么得到结论： $f_n = ng_{n - 1}$ ，答案为： $\frac{n(n + 1)}{2(2n - 1)}$ 。 生成函数 + 求导$f$ 通过枚举左子树叶子结点总数，右子树形态总数，相乘： f_n = 2\sum \limits_{i = 0}^{n - 1}f_ig_{n - i - 1}可以发现 $g, f$ 都满足卷积的形式，尝试用生成函数表示他们： \begin{align*} G(x)& = xG(x)^2 + 1 \\ F(x) &= 2xF(x)G(x) + x \end{align*}注意最后一项的区别基于最低非零次项。 解方程得： \begin{align*} G(x) = &\frac{1 - \sqrt{1 - 4x}}{2x} \\ F(x) = &\frac{x}{\sqrt{1 - 4x}} \\ \end{align*}发现一个等式： \int \frac{F(x)}{x}dx = -\frac{1}{2}\sqrt{1 - 4x} + C = xG(x)由于 $g$ 的定义，不难发现他就是卡特兰数，即 $g_n = \frac{\begin{pmatrix}2n \\ n\end{pmatrix}}{n + 1}$ ，那么： \begin{align*} xG(x) &= \sum \limits_{i = 1}^\infty g_{i - 1}x^i \\ (xG(x))' &= \sum \limits_{i = 0}^\infty (i + 1)g_ix^i \\ \frac{F(x)}{x} &= \sum \limits_{i = 0}^\infty (i + 1)g_ix^i \\ F(x) &= \sum \limits_{i = 0}^\infty ig_{i - 1}x^i \end{align*}可知：$f_n = ng_{n - 1}​$ ，答案为：$\frac{n(n + 1)}{2(2n - 1)}​$ 。 代码12345678910111213#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int n;int main() &#123; cin &gt;&gt; n; cout &lt;&lt; (double)(n + 1) * n / 2.0 / (double)(2 * n - 1) &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>组合数学</category>
        <category>生成函数</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>计数</tag>
        <tag>卡特兰数</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 2151 - [SDOI2009]HH去散步]]></title>
    <url>%2F2019%2F01%2FLuogu-2151-SDOI2009-HH%E5%8E%BB%E6%95%A3%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[首先，如果可以连续走一条边，那么这就是一个普通的计数问题（虽然我就是没想到这步）：建立邻接矩阵，求出其 $k$ 次幂，矩阵 $a_{i, j}$ 就是点 $i$ 到点 $j$ 的的方案数。 分析一下矩阵乘法：矩阵乘法与 $floyd$ 形式相近，图论中的邻接矩阵多与矩阵乘法有关。其形式为 $c_{i, j} = \sum \limits_{k = 1}^n a_{i, k}b_{k, j}$ 。设 $c_{i, j}$ 为 $i \rightarrow j$ 的方案数， $a_{i, k}$ 为 $i \rightarrow k$ 的方案数， $b_{k, j}$ 为 $k \rightarrow j$ 的方案数，那么显然是相乘，符合矩阵乘法形式。或许这可以看作卷积的类比？ 现在不能连续走一条边，那么考虑点边转化：将双向边看作两条有向边，对于一个点的入边和出边相连，那么就可以符合题目要求。 那么强制规定第一条边的走法，即将冗余矩阵行 $a_{1, i}, \exists (a, i)$ 赋为，之后再走 $k - 1$ 次，即进行 $k - 1$ 次矩阵快速幂 ，矩阵 $a_{1, i}, \exists (i, b)$ 就是就是答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define MAXN 55#define MAXM 61using namespace std;int total;const int mod = 45989;struct data &#123; int next, to; data(int next = 0, int to = 0):next(next), to(to) &#123;&#125;&#125;edge[MAXM &lt;&lt; 1];struct matrix &#123; int a[MAXM &lt;&lt; 1][MAXM &lt;&lt; 1]; matrix() &#123; memset(a, 0, sizeof(a)); &#125; matrix operator * (matrix b) const &#123; matrix c; for (int i = 1; i &lt;= total; ++i) for (int j = 1; j &lt;= total; ++j) for (int k = 1; k &lt;= total; ++k) c.a[i][j] = (c.a[i][j] + a[i][k] * b.a[k][j] % mod) % mod; return c; &#125;&#125;trans, res;matrix operator ^ (matrix a, int b) &#123; matrix res; for (int i = 1; i &lt;= total; ++i) res.a[i][i] = 1; while (b) &#123; if (b &amp; 1) res = res * a; a = a * a; b &gt;&gt;= 1; &#125; return res;&#125;int n, m, t, a, b;int head[MAXN], cnt = 1;bool visit[MAXN];void connect(int u, int v) &#123; edge[++cnt] = data(head[u], v); head[u] = cnt;&#125;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;int main() &#123; n = read(); m = read(); t = read(); a = read() + 1; b = read() + 1; for (int i = 1; i &lt;= m; ++i) &#123; int u = read() + 1, v = read() + 1; connect(u, v); connect(v, u); &#125; total = cnt; for (int i = head[a]; i; i = edge[i].next) res.a[1][i] = 1; for (int u = 1; u &lt;= n; ++u) for (int i = head[u]; i; i = edge[i].next) for (int j = edge[i].next; j; j = edge[j].next) trans.a[i ^ 1][j] = trans.a[j ^ 1][i] = 1; res = res * (trans ^ (t - 1)); int ans = 0; for (int i = head[b]; i; i = edge[i].next) ans = (ans + res.a[1][i ^ 1]) % mod; printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>计数</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>矩阵快速幂</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 3329 - Xorequ]]></title>
    <url>%2F2019%2F01%2FBZOJ-3329-Xorequ%2F</url>
    <content type="text"><![CDATA[这题其实是 $2$ 个问，但第 $2$ 个问似乎并没有什么思维难度还是放到数位 $DP$ 好了。 对于第一问，首先考虑题目所给的方程： x \oplus 3x = 2x \\ x \oplus 2x = 3x \\第二步移项我居然没有想到……根据第二个方程我们可以发现： $x$ 的二进制表示中不能有相邻的 $1$ 。 尝试下递推的数位 $DP$。 $f_{i, j, k}$ 表示第 $i$ 位为 $j$ ，若 $k$ 为 $1$ 则达到限制. 若当前位为 $1​$： \begin{align*} f_{i, 1, 0} &= f_{i + 1, 0, 0}\\ f_{i, 1, 1} &= f_{i + 1, 0, 1}\\ f_{i, 0, 0} &= f_{i + 1, 1, 1} + f_{i + 1, 1, 0} + f_{i + 1, 0, 1} + f_{i + 1, 0, 0}\\ \end{align*}若当前位为 $0$ ： \begin{align*} f_{i, 1, 0} &= f_{i + 1, 0, 0}\\ f_{i, 0, 1} &= f_{i + 1, 0, 1} + f_{i + 1, 0, 0}\\ f_{i, 0, 1} &= f_{i + 1, 1, 1} + f_{i + 1, 0, 1}\\ \end{align*}递推即可。 对于第二问，假设我们要求 $f_{2^n}$，由于第一位为 $1$，那么我们只需要枚举第二位为 $1$ 或 $0$ 。若第二位为 $1$ 则方案数为 $f_{2^{n - 1}}$ ，反之为 $f_{2^{n - 2}}$ ，可以发现是 $Fibonacci$ 的形式，直接矩阵快速幂加速即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt; #define MAXN 10010const int mod = 1e9 + 7; typedef long long lint; using namespace std; lint f[MAXN][2][2];int s[MAXN], l;int t;lint n; struct matrix &#123; lint a[3][3]; matrix() &#123; memset(a, 0, sizeof(a)); &#125; matrix operator * (const matrix b) const &#123; matrix c; for (int i = 1; i &lt;= 2; ++i) for (int j = 1; j &lt;= 2; ++j) for (int k = 1; k &lt;= 2; ++k) c.a[i][j] = (c.a[i][j] + a[i][k] * b.a[k][j] % mod) % mod; return c; &#125;&#125;base, trans; matrix operator ^ (matrix a, lint b) &#123; matrix res; for (int i = 1; i &lt;= 2; ++i) res.a[i][i] = 1; while (b) &#123; if (b &amp; 1) res = res * a; a = a * a; b &gt;&gt;= 1; &#125; return res;&#125; lint read() &#123; char c = getchar(); lint x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125; int get(lint x) &#123; int n = 0; while (x) &#123; s[++n] = x &amp; 1; x &gt;&gt;= 1; &#125; return n;&#125; int main() &#123; t = read(); while (t--) &#123; n = read(); int l = get(n); memset(f, 0, sizeof(f)); f[l][0][0] = 1; f[l][1][1] = 1; for (int i = l - 1; i &gt;= 1; --i) if (s[i]) &#123; f[i][1][1] = f[i + 1][0][1]; f[i][1][0] = f[i + 1][0][0]; f[i][0][0] = f[i + 1][1][1] + f[i + 1][0][0] + f[i + 1][0][1] + f[i + 1][1][0]; &#125; else &#123; f[i][1][0] = f[i + 1][0][0]; f[i][0][0] = f[i + 1][1][0] + f[i + 1][0][0]; f[i][0][1] = f[i + 1][1][1] + f[i + 1][0][1]; &#125; printf("%lld\n", f[1][0][0] + f[1][0][1] + f[1][1][0] + f[1][1][1] - 1); base.a[1][1] = 1; base.a[1][2] = 2; trans.a[1][1] = 0; trans.a[1][2] = 1; trans.a[2][1] = 1; trans.a[2][2] = 1; base = base * (trans ^ n); printf("%lld\n", base.a[1][1]); &#125;&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>数位DP</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>数位DP</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 3033 - [SDOI2013]淘金]]></title>
    <url>%2F2019%2F01%2FLuogu-3033-SDOI2013-%E6%B7%98%E9%87%91%2F</url>
    <content type="text"><![CDATA[对于行和列，可以发现在计算方案数的时候他们是等价的，可以单独考虑行或列进行求解，本处单独考虑行。 由于只进行了一次变换，意味着有一些会有一些原行 $a$ 贡献到了别的行 $b$ 上。 显然的，$b = 2^i3^j5^k7^l$ ，意味着我们可以通过枚举 $2, 3, 5, 7$ 这四个质数的指数进行数位 $DP$ 。 那么通过枚举每一位数进行转移，需要特别考虑前导 $0$ 的情况，可以计算出对于标号为 $i$ 的一行会被 $v_i$ 行贡献到。那么点 $(i, j)$ 获得的值为 $v_iv_j$ 。 现在要求的就是前 $k$ 大值。我们将 $v$ 从大到小排序，就是组合不同的 $v_i v_j$ 获得前 $k$ 大。· 这显然可以用堆来解决：先将所有的 $(v_1, v_i)$ 插入大根堆，如果 $(v_i, v_j)$ 贡献， $(v_{i + 1}, v_j)$ 加入大根堆，如此求出前 $k$ 大。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;const int mod = 1e9 + 7;#define MAXK 300100#define MAXD 15typedef long long lint;using namespace std;lint v[MAXK];struct node &#123; int x, y; node (int x = 0, int y = 0):x(x), y(y) &#123;&#125; bool operator &lt; (const node b) const &#123; return v[x] * v[y] &lt; v[b.x] * v[b.y]; &#125;&#125;;priority_queue&lt;node&gt; q;int s[MAXD], m, k, limit;lint h[MAXK][6], f[MAXD][40][26][18][15];lint n;int p[9] = &#123;0, 2, 3, 5, 7&#125;;int factor[20][6] = &#123; &#123;0, 0, 0, 0, 0&#125;, &#123;0, 0, 0, 0, 0&#125;, &#123;0, 1, 0, 0, 0&#125;, &#123;0, 0, 1, 0, 0&#125;, &#123;0, 2, 0, 0, 0&#125;, &#123;0, 0, 0, 1, 0&#125;, &#123;0, 1, 1, 0, 0&#125;, &#123;0, 0, 0, 0, 1&#125;, &#123;0, 3, 0, 0, 0&#125;, &#123;0, 0, 2, 0, 0&#125;,&#125;;bool g[MAXD][40][26][18][15];lint read() &#123; char c = getchar(); lint x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void DFS(lint s, int a, int b, int c, int d, int limit) &#123; if (s &gt; n) return ; h[++m][0] = s; h[m][1] = a; h[m][2] = b; h[m][3] = c; h[m][4] = d; for (int i = limit; i &lt;= 4; ++i) DFS(s * p[i], a + (i == 1), b + (i == 2), c + (i == 3), d + (i == 4), i);&#125;int DFS(int x, int a, int b, int c, int d, bool islimit, bool iszero) &#123; if (a &lt; 0 || b &lt; 0 || c &lt; 0 || d &lt; 0) return 0; if (!x) return !a &amp;&amp; !b &amp;&amp; !c &amp;&amp; !d; if (g[x][a][b][c][d]&amp;&amp; !islimit &amp;&amp; !iszero) return f[x][a][b][c][d]; int limitr = islimit ? s[x] : 9, limitl = iszero ? 0 : 1; lint res = 0; for (int i = limitl; i &lt;= limitr; ++i) res += DFS(x - 1, a - factor[i][1], b - factor[i][2], c - factor[i][3], d - factor[i][4], islimit &amp;&amp; i == limitr, iszero &amp;&amp; !i); if (!islimit &amp;&amp; !iszero) &#123; g[x][a][b][c][d] = true; f[x][a][b][c][d] = res; &#125; return res;&#125;int solve(int i) &#123; return DFS(limit, h[i][1], h[i][2], h[i][3], h[i][4], 1, 1);&#125;void get(lint x) &#123; limit = 0; while (x) &#123; s[++limit] = x % 10; x /= 10; &#125;&#125;bool comp(int u, int v) &#123; return u &gt; v;&#125;int main() &#123; n = read(); k = read(); DFS(1, 0, 0, 0, 0, 1); get(n); for (int i = 1; i &lt;= m; ++i) v[i] = solve(i); --v[1]; sort(v + 1, v + m + 1, comp); for (int i = 1; i &lt;= m; ++i) q.push(node(i, 1)); lint ans = 0; for (int i = 1; i &lt;= k; ++i) &#123; node u = q.top(); q.pop(); ans = (ans + v[u.x] * v[u.y] % mod) % mod; if (u.y + 1 &lt;= m) q.push(node(u.x, u.y + 1)); &#125; printf("%lld\n", ans);&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>数位DP</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 4451 - [国家集训队]整数的lqp拆分]]></title>
    <url>%2F2019%2F01%2FLuogu-4451-%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-%E6%95%B4%E6%95%B0%E7%9A%84lqp%E6%8B%86%E5%88%86%2F</url>
    <content type="text"><![CDATA[很有意思的一道纯粹生成函数的题目，当然普通的数列递推也可以做，就是显得没有那么优雅。 首先再推导一遍 $Fibonacci$ 的生成函数，加深记忆： \begin{align*} F(x) &= \sum \limits_{i} f_ix^i \\ F(x) &= \sum \limits_{i} (f_{i - 1} + f_{i - 2} + [n = 1]) \\ F(x) &= x\sum \limits_i f_ix^i + x^2\sum \limits_i f_ix^i + 1 \\ F(x) &= xF(x) + x^2F(x) + 1 \\ F(x) &= \frac{1}{1 - x - x^2} \end{align*}设$G(x) = \sum \limits_i \sum \prod \limits_{i = 1}^m f_{a_i}$ 由题意易知： \begin{align*} G &= GF + F \\ G &= \frac{F}{1 - F} \\ \end{align*}反过来推导递推公式： \begin{align*} G(x) &= \frac{x}{1 - 2x - x^2} \\ G(x) &= 2\sum \limits_i g_{i - 1}x^i + \sum \limits_i g_{i - 2}x^i + x \\ G(x) &= \sum \limits_i (2g_{i - 1} + g_{i - 2} + [n = 1])x^i \\ g_n &= 2g_{n - 1} + g_{n - 2} \\ \end{align*}$O(n)$ 的递推过于简单。 123456789101112131415161718192021222324252627#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;typedef long long lint;const int mod = 1e9 + 7;using namespace std;lint a, b;int n;int main() &#123; a = 0; b = 1; cin &gt;&gt; n; for (int i = 2; i &lt;= n; ++i) &#123; lint t = b; b = (2 * b + a) % mod; a = t; &#125; if (n &lt;= 1) printf("%d\n", n); else printf("%lld\n", b);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>组合数学</category>
        <category>生成函数</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>生成函数</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 4841 - 城市规划]]></title>
    <url>%2F2019%2F01%2FLuogu-4841-%E5%9F%8E%E5%B8%82%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[生成函数求解无向连通图数目，可以发现并不是非常好求解，同样的思路，正难则反，用总数 $-$ 无向非连通图数目，尝试列出方程： f_n = 2^{\begin{pmatrix}n \\ 2\end{pmatrix}} - \sum \limits_{i = 1}^{n - 1} \begin{pmatrix} n - 1 \\ i - 1\end{pmatrix}2^{\begin{pmatrix} n - i \\ 2\end{pmatrix}} f_i \\ \frac{f_n}{(n - 1)!} = \frac{2^{\begin{pmatrix} n\\ 2\end{pmatrix}}}{(n - 1)!} - \sum \limits_{i = 1}^{n - 1} \frac{f_i}{(i - 1)!} \cdot \frac{2^{\begin{pmatrix}n - i \\ 2 \end{pmatrix}}}{(n - i)!}我们设三个函数： F(x) = \sum \limits_{i = 1}^n \frac{f_i}{(i - 1)!} \\ G(x) = \sum \limits_{i = 1}^n \frac{2^{\begin{pmatrix} i \\ 2 \end{pmatrix}}}{(i - 1)!} \\ H(x) = \sum \limits_{i = 1}^n \frac{2^{\begin{pmatrix} i \\ 2 \end{pmatrix}}}{i!} \\那么： F = G - FH \\ F = \frac{G}{1 + H} \\多项式求逆即可。 麦克劳林级数我看到这个解法的时候过于震惊…… 由于顶点没有标号，可以直接把它看作指数型生成函数。 定义 $G(x)$ 为无向简单图的指数型生成函数， $F(x)$ 为无向简单连通图的指数型生成函数，有： G(x) = \sum \limits_{i} 2^{\begin{pmatrix} i \\ 2\end{pmatrix}}\frac{x^i}{i!} \\ F(x) = \sum \limits_{i} f_i \frac{x^i}{i!} \\这时候由于 $G(x)$ 是 $F(x)$ 的划分，所以： G(x) = \sum \limits_i \frac{F(x)^i}{i!} \\ = e^{F(x)}多项式求 $ln$ 即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;typedef long long lint;#define MAXN 400005using namespace std;const int mod = 1004535809, G = 3;int n;lint a[MAXN], b[MAXN], f[MAXN], g[MAXN], h[MAXN], hr[MAXN];lint fac[MAXN];int r[MAXN];int read() &#123; char c = getchar(); int x = 0; while (c &lt; '0' || c &gt; '9') c = getchar(); while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;int getr(int n) &#123; int limit = 1, size = 0; while (limit &lt;= n) &#123; limit &lt;&lt;= 1; ++size; &#125; for (int i = 0; i &lt; limit; ++i) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (size - 1)); return limit;&#125;lint power(lint a, lint b) &#123; lint res = 1; while (b) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;void NTT(lint* a, int n, int b) &#123; for (int i = 0; i &lt; n; ++i) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int i = 1; i &lt; n; i &lt;&lt;= 1) &#123; lint gn = power(b == 1 ? G : power(G, mod - 2), (mod - 1) / (i &lt;&lt; 1)); for (int j = 0; j &lt; n; j += (i &lt;&lt; 1)) &#123; lint g = 1; for (int k = 0; k &lt; i; ++k) &#123; lint x = a[j + k], y = a[j + k + i] * g % mod; a[j + k] = (x + y) % mod; a[j + k + i] = (x - y + mod) % mod; g = g * gn % mod; &#125; &#125; &#125; if (b == -1) &#123; lint inv = power(n, mod - 2); for (int i = 0; i &lt; n; ++i) a[i] = a[i] * inv % mod; &#125;&#125;void inverse(lint* f, int n, lint* g) &#123; if (n == 1) &#123; g[0] = power(f[0], mod - 2); return ; &#125; inverse(f, n &gt;&gt; 1, g); int limit = getr(n); for (int i = 0; i &lt; n; ++i) &#123; a[i] = f[i]; b[i] = g[i]; &#125; for (int i = n; i &lt; limit; ++i) a[i] = b[i] = 0; NTT(a, limit, 1); NTT(b, limit, 1); for (int i = 0; i &lt; limit; ++i) a[i] = b[i] * (2ll - a[i] * b[i] % mod + mod) % mod; NTT(a, limit, -1); for (int i = 0; i &lt; n; ++i) g[i] = a[i];&#125;void solve(int n) &#123; fac[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; fac[i] = i * fac[i - 1] % mod; lint v = power(2, 1ll * i * (i - 1) / 2); g[i] = v * power(fac[i - 1], mod - 2) % mod; h[i] = v * power(fac[i], mod - 2) % mod; &#125; ++h[0]; inverse(h, getr(n + 1), hr); int limit = getr(n + 1); NTT(g, limit, 1); NTT(hr, limit, 1); for (int i = 0; i &lt; limit; ++i) g[i] = g[i] * hr[i] % mod; NTT(g, limit, -1); for (int i = 0; i &lt; limit; ++i) f[i] = g[i]; printf("%lld\n", f[n] * fac[n - 1] % mod);&#125;int main() &#123; n = read(); solve(n);&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>组合数学</category>
        <category>生成函数</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>NTT</tag>
        <tag>计数</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 55D - Beautiful numbers]]></title>
    <url>%2F2019%2F01%2FCodeforces-55D-Beautiful-numbers%2F</url>
    <content type="text"><![CDATA[好像并不是很难，但是一时半会居然想不出来。 首先假装它是一个定理： 定理：若 $a | x \and a | y (x &gt; y)$ ，则 $a | (x - y)$ 。 证明：虽然很显然，但还是严谨地证一下。 定理可以转化为： x \equiv 0 \pmod{a} \\ y \equiv 0 \pmod{a}根据同余法则： x - y \equiv 0 \pmod{a} \\ x + y \equiv 0 \pmod{a} \\还是好显然。 那么就简单了：设 $x = \overline{abcdef\cdots}$ ， $f_{i, j, k}$ 表示到了第 $i$ 位， $x \bmod b = j$ ，$LCM(a, b, c, d, e, f, \cdots) = k$ ，那么 $DP$ 一下即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 2700#define MAXD 25typedef long long lint;using namespace std;lint f[MAXD][MAXN][57], s[MAXN], n, t;bool g[MAXD][MAXN][57];int r[MAXN], total;lint read() &#123; char c = getchar(); lint x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;lint gcd(lint a, lint b) &#123; return !b ? a : gcd(b, a % b);&#125;lint lcm(lint a, lint b) &#123; if (!b) return a; return a / gcd(a, b) * b;&#125;lint DFS(int d, lint x, lint y, bool islimit) &#123; if (d == 0) return !(x % y); if (g[d][x][r[y]] &amp;&amp; !islimit) return f[d][x][r[y]]; int limit = islimit ? s[d] : 9; lint res = 0; for (int i = 0; i &lt;= limit; ++i) res += DFS(d - 1, (x * 10 + i) % 2520, lcm(y, i), islimit &amp;&amp; i == limit); if (!islimit) &#123; f[d][x][r[y]] = res; g[d][x][r[y]] = true; &#125; return res;&#125;lint solve(lint x) &#123; n = 0; while (x) &#123; s[++n] = x % 10; x /= 10; &#125; return DFS(n, 0, 1, 1);&#125;int main() &#123; t = read(); for (int i = 1; i &lt;= 2520; ++i) if (2520 % i == 0) r[i] = ++total; while (t--) &#123; lint l = read(), r = read(); printf("%lld\n", solve(r) - solve(l - 1)); &#125;&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>数位DP</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 3188 - [HNOI2007]梦幻岛宝珠]]></title>
    <url>%2F2019%2F01%2FLuogu-3188-HNOI2007-%E6%A2%A6%E5%B9%BB%E5%B2%9B%E5%AE%9D%E7%8F%A0%2F</url>
    <content type="text"><![CDATA[一个特殊的 $01$ 背包问题：物品数量极少，价值和极大。 其实价值和我们的运算并无关联：最多需要加一个高精度；但代价极大意味着基于枚举代价的 $DP$ 方法无效。 同时题目给定了另外一个条件：$m = a \cdot 2^b$ ，借助这个式子，尝试将 $b$ 分层？ 对于每一层，可以把其看作一个最优子结构，对于答案统计只需要合并即可。 那么我们既可以有基于 $b$ 的第一个方程： f_{i, j} = max(f_{i, j - w} + v)这个方程计算的是：以 $b$ 进行分层，在代价为 $j \cdot2^i$ 时的最大权值。那么用普通的 $01$ 背包可以解决。 考虑当前层代价为 $j \cdot 2^i$ 由当前层 $(j - k) \cdot 2^i$ 与 上一层 $k \cdot 2^{i - 1}$ 转移而来，进行分层合并： f_{i, j} = max(f_{i, j - k} + f_{i - 1, 2k + w_{i - 1}})其中， $w_i$ 表示 $w$ 二进制下的第 $i$ 位。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 105#define MAXM 1025using namespace std;int n, w;int f[MAXN][MAXM];int read() &#123; char c = getchar(); int x = 0, s = 1; while (!isdigit(c)) &#123; if (c == '-') s = -1; c = getchar(); &#125; while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x * s;&#125;int main() &#123; while (true) &#123; memset(f, 0, sizeof(f)); n = read(); w = read(); if (n == -1) break; for (int i = 1; i &lt;= n; ++i) &#123; int x = read(), v = read(), a, b = 0; while (!(x &amp; 1)) &#123; x &gt;&gt;= 1; ++b; &#125; a = x; for (int j = 1000; j &gt;= a; --j) f[b][j] = max(f[b][j], f[b][j - a] + v); &#125; for (int i = 0; i &lt;= 30; ++i) for (int j = 1; j &lt;= 1000; ++j) f[i][j] = max(f[i][j - 1], f[i][j]); int ans = 0; for (int i = 0; i &lt;= 1000; ++i) ans = max(ans, f[0][i]); for (int i = 1; (1 &lt;&lt; i) &lt;= w; ++i) &#123; for (int j = min(1000, w &gt;&gt; i); j &gt;= 0; --j) for (int k = 0; k &lt;= j; ++k) &#123; if ((k &lt;&lt; 1) + (w &gt;&gt; (i - 1) &amp; 1) &gt; 1000) continue; f[i][j] = max(f[i][j], f[i][j - k] + f[i - 1][(k &lt;&lt; 1) | (w &gt;&gt; (i - 1) &amp; 1)]); ans = max(f[i][j], ans); &#125; &#125; printf("%d\n", ans); &#125;&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>背包</category>
        <category>01背包</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>01背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 4233 - 射命丸文的笔记]]></title>
    <url>%2F2019%2F01%2FLuogu-4233-%E5%B0%84%E5%91%BD%E4%B8%B8%E6%96%87%E7%9A%84%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[求哈密顿回路方案数除以存在哈密顿回路竞赛图的总数。 首先第一个居然是可求的，一直理解错了题意……方案数为： c =\frac{n!}{n} 2^{\frac{n(n - 1)}{2} - n}$\frac{n!}{n}$ 是元素的全排列数，又由于循环同构，所以除以 $n$ ；当已经确定好 $n$ 条边时，剩下的 $\frac{n(n - 1)}{2} - n $ 条边方向任意，方案数即 $2^{\frac{n(n - 1)}{2}}$ 。 定理：有且仅有强连通竞赛图存在哈密顿回路。 证明：只需要证明非强连通竞赛图不存在哈密顿回路即可。 对于一个非强连通竞赛图，必然存在 $i, j$ ，使得 $i$ 不能到达 $j$ 。这显然违背了哈密顿回路的定义。 那么问题转化为统计强连通竞赛图的数目，计数类问题考虑用 $DP$ 解决。 直接求出好像不可行，正难则反，尝试用总数 $-$ 不合法方案数，根据这个思路，可以列出方程： \begin{align*} f_n &= 2^{\frac{n(n - 1)}{2}} - \sum \limits_{i = 1}^{n - 1}f_i\begin{pmatrix} n \\ i\end{pmatrix}2^{\frac{(n - i)(n - i - 1)}{2}} \\ f_n &= 2^{\frac{n(n - 1)}{2}} - \sum \limits_{i = 1}^{n - 1}f_i\frac{n!}{i!(n - i)!}2^{\frac{(n - i)(n - i - 1)}{2}} \\ \frac{f_n}{n!} &= \frac{2^{\frac{n(n - 1)}{2}}}{n!} - \sum \limits_{i = 1}^{n - 1}\frac{f_i}{i!}\frac{2^{\frac{(n - i)(n - i - 1)}{2}}}{(n - i)!} \\ \end{align*}可以发现右边是卷积的形式，定义两个生成函数 $G(x) = \sum \limits_{i = 0}^n \frac{2^{\frac{i(i - 1)}{2}}}{i!}, F = \frac{f_i}{i}$ ，原方程化为： \begin{align*} F = G - FG \\ F = \frac{G}{1 + G} \\ \end{align*}多项式求逆即可解决问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 400050typedef long long lint;const int mod = 998244353, G = 3;using namespace std;int n;int r[MAXN];lint a[MAXN], b[MAXN], f[MAXN], g[MAXN], h[MAXN];int getr(int n) &#123; int limit = 1, size = 0; while (limit &lt;= n) &#123; limit &lt;&lt;= 1; ++size; &#125; for (int i = 0; i &lt; limit; ++i) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (size - 1)); return limit;&#125;lint power(lint a, lint b) &#123; lint res = 1; while (b) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;void NTT(lint* a, int n, int b) &#123; for (int i = 0; i &lt; n; ++i) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int i = 1; i &lt; n; i &lt;&lt;= 1) &#123; lint gn = power(b == 1 ? G : power(G, mod - 2), (mod - 1) / (i &lt;&lt; 1)); for (int j = 0; j &lt; n; j += (i &lt;&lt; 1)) &#123; lint g = 1; for (int k = 0; k &lt; i; ++k) &#123; lint x = a[j + k], y = a[j + k + i] * g % mod; a[j + k] = (x + y) % mod; a[j + k + i] = (x - y + mod) % mod; g = g * gn % mod; &#125; &#125; &#125; if (b == -1) &#123; lint inv = power(n, mod - 2); for (int i = 0; i &lt; n; ++i) a[i] = a[i] * inv % mod; &#125;&#125;void inverse(lint* f, int n, lint* g) &#123; if (n == 1) &#123; g[0] = power(f[0], mod - 2); return ; &#125; inverse(f, n &gt;&gt; 1, g); int limit = getr(n); for (int i = 0; i &lt; n; ++i) &#123; a[i] = f[i]; b[i] = g[i]; &#125; NTT(a, limit, 1); NTT(b, limit, 1); for (int i = 0; i &lt; limit; ++i) a[i] = b[i] * ((2ll - b[i] * a[i] % mod + mod) % mod); NTT(a, limit, -1); for (int i = 0; i &lt; n; ++i) g[i] = a[i];&#125;void initiate(int n) &#123; lint fac = 1, inv; for (int i = 1; i &lt;= n; ++i) fac = fac * i % mod; inv = power(fac, mod - 2); for (int i = n; i &gt;= 1; --i) &#123; g[i] = power(2, 1ll * i * (i - 1) / 2) * inv % mod; inv = inv * i % mod; &#125; g[0] = 1;&#125;int main() &#123; cin &gt;&gt; n; initiate(n); inverse(g, getr(n), h); g[0] = 0; int limit = getr(n &lt;&lt; 1); for (int i = n + 1; i &lt; limit; ++i) g[i] = h[i] = 0; NTT(g, limit, 1); NTT(h, limit, 1); for (int i = 0; i &lt; limit; ++i) g[i] = g[i] * h[i] % mod; NTT(g, limit, -1); lint fac = 1; for (int i = 1; i &lt;= n; ++i) &#123; if (i == 1) puts("1"); else if (i == 2) puts("-1"); else printf("%lld\n", fac% mod * power(2, 1ll * i * (i - 3) / 2) % mod * power(g[i] * fac % mod * i % mod, mod - 2) % mod); fac = fac * (i + 1) % mod; &#125;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>组合数学</category>
        <category>生成函数</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>NTT</tag>
        <tag>计数</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 5075 - [JSOI2012]分零食]]></title>
    <url>%2F2019%2F01%2FLuogu-5075-JSOI2012-%E5%88%86%E9%9B%B6%E9%A3%9F%2F</url>
    <content type="text"><![CDATA[能轻松列出 $DP​$ 方程： \begin{align*} p_i &= oi^2 + si + u\\ f_{0, 0} &= 1 \\ f_{i, j} &= \sum \limits_{k = 0}^{m}f_{i - 1, k}p_{m - k} \\ \operatorname{ans} &= \sum \limits_{i = 1}^a f_{i, m} \end{align*}可以发现后面是卷积的形式，考虑用生成函数表示方程： \begin{align*} F_0 &= 1 \\ F_i &= F_{i - 1}P \\ \end{align*}多项式快速幂 + 多项式求逆利用生成函数继续推导： \begin{align*} ans &= \sum \limits_{i = 1}^a F_i (x^m) \\ &= \sum \limits_{i = 1}^a P^i \\ &= \frac{1 - p^{a + 1}}{1 - p} \end{align*}这样就可以 $O(n \log^2 n)$ 解决问题了，同样的，可以用 $exp$ 优化成 $O(n \log n)$ 。 多项式迭代倍增 \begin{align*} G_a &= \sum \limits_{i = 1}^{a} F_i \\ G_a &= G_{\frac{a}{2}} + \sum \limits_{i = \frac{a}{2} + 1}^a F_i\\ G_a &= G_{\frac{a}{2}} + \sum \limits_{i = 1}^{\frac{a}{2}} F_{i + \frac{a}{2}}\\ \end{align*}现在需要证明：$F_iF_j = F_{i + j}$ F_i F_j = F_0^2p^i p^j = F_0p^{i + j} = F_{i + j}那么： \begin{align*} G_a &= G_{\frac{a}{2}} + F_{\frac{n}{2}}\sum \limits_{i = 1}^{\frac{n}{2}}F_i \\ G_a &= G_{\frac{a}{2}} + F_{\frac{n}{2}}G_{\frac{n}{2}} \end{align*}利用该式迭代求解即可。 代码只给出多项式快速幂 + 多项式求逆的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#define MAXN 400010typedef long long lint;using namespace std;const double PI = acos(-1.0);struct complex &#123; double x, y; complex(double x = 0, double y = 0):x(x), y(y) &#123;&#125; complex operator + (const complex a) const &#123; return complex(a.x + x, a.y + y); &#125; complex operator - (const complex a) const &#123; return complex(x - a.x, y - a.y); &#125; complex operator * (const complex a) const &#123; return complex(x * a.x - y * a.y, x * a.y + y * a.x); &#125;&#125;a[MAXN], b[MAXN];int r[MAXN], c[MAXN];int f[MAXN], g[MAXN], h[MAXN];int n, mod, A, o, s, u;int N;int getr(int n) &#123; int limit = 1, size = 0; while (limit &lt;= n) &#123; limit &lt;&lt;= 1; ++size; &#125; for (int i = 0; i &lt; limit; ++i) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (size - 1)); return limit;&#125;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;void FFT(complex* a, int n, int opt) &#123; for (int i = 0; i &lt; n; ++i) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int i = 1; i &lt; n; i &lt;&lt;= 1) &#123; complex wn(cos(PI / i), sin(PI / i) * opt); for (int j = 0; j &lt; n; j += (i &lt;&lt; 1)) &#123; complex w(1, 0); for (int k = 0; k &lt; i; ++k) &#123; complex x = a[j + k], y = w * a[j + k + i]; a[j + k] = x + y; a[j + k + i] = x - y; w = w * wn; &#125; &#125; &#125;&#125;void mul(int* f, int* g, int n, int* c) &#123; for (int i = 0; i &lt; n; ++i) &#123; a[i] = f[i]; b[i] = g[i]; &#125; FFT(a, n, 1); FFT(b, n, 1); for (int i = 0; i &lt; n; ++i) a[i] = a[i] * b[i]; FFT(a, n, -1); for (int i = 0; i &lt;= N; ++i) c[i] = (int)(a[i].x / n + 0.5) % mod;&#125;void inverse(int* f, int n, int* g) &#123; if (n == 1) &#123; g[0] = 1; return ; &#125; inverse(f, n &gt;&gt; 1, g); int limit = getr(n &lt;&lt; 1); for (int i = 0; i &lt; n; ++i) c[i] = f[i]; for (int i = n; i &lt; limit; ++i) c[i] = 0; mul(c, g, limit, c); mul(c, g, limit, c); for (int i = 0; i &lt; n; ++i) g[i] = (2 * g[i] - c[i] + mod) % mod;&#125;void power(int* f, int n, int b, int* g) &#123; for (int i = 1; i &lt; n; ++i) g[i] = 0; g[0] = 1; while (b) &#123; if (b &amp; 1) mul(g, f, n, g); mul(f, f, n, f); b &gt;&gt;= 1; &#125;&#125;void solve() &#123; for (int i = 1; i &lt;= n; ++i) f[i] = mod - (i * i * o + s * i + u) % mod; f[0] = 1; int limit = getr(n &lt;&lt; 1); inverse(f, limit, g); for (int i = 0; i &lt;= n; ++i) f[i] = mod - f[i]; f[0] = 0; limit = getr(n &lt;&lt; 1); power(f, limit, A + 1, h); for (int i = 0; i &lt;= n; ++i) h[i] = mod - h[i]; h[0] = 1; mul(h, g, limit, h); printf("%d\n", h[n]);&#125;int main() &#123; N = n = read(); mod = read(); A = read(); o = read(); s = read(); u = read(); solve();&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>组合数学</category>
        <category>生成函数</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>FFT</tag>
        <tag>生成函数</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 5093 - 图的价值]]></title>
    <url>%2F2019%2F01%2FBZOJ-5093-%E5%9B%BE%E7%9A%84%E4%BB%B7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[可以发现对于每一个点，都是互相等价的，可以先算出一个点的贡献。 度数只和每一个点对于其他点的连边有关。可以枚举关于点 $i​$ 的连边情况。其他的边可连，可不连。可以推出一个点的贡献为： 2^{\frac{(n - 1)(n - 2)}{2}}\sum \limits_{d = 0}^{n - 1}\begin{pmatrix}n - 1\\ d \end{pmatrix} d^k \\那么 $n$ 个点的贡献为： n \cdot 2^{\frac{(n - 1)(n - 2)}{2}}\sum \limits_{d = 0}^{n - 1}\begin{pmatrix}n - 1\\ d \end{pmatrix} d^k \\前面都是常数项，很好求解，不妨设 $n = n - 1$ ，求解后面： \begin{align*} &\sum \limits_{d = 0}^{n}\begin{pmatrix}n\\ d \end{pmatrix} d^k \\ = &\sum \limits_{d = 0}^n \begin{pmatrix}n \\ d \end{pmatrix} \sum \limits_{i = 0}^k \begin{Bmatrix} k \\ i\end{Bmatrix} \begin{pmatrix} d \\ i \end{pmatrix}i! \\ = &\sum \limits_{i = 0}^k \begin{Bmatrix} k \\ i\end{Bmatrix} \sum \limits_{d = 0}^n \frac{n!}{(d - i)!(n - d)!} \\ = &\sum \limits_{i = 0}^k \begin{Bmatrix} k \\ i\end{Bmatrix} \sum \limits_{d = 0}^n \frac{(n - i)!}{(d - i)!(n - d)!} \cdot \frac{n!}{(n - i)!} \\ = &\sum \limits_{i = 0}^k\begin{Bmatrix} k \\ i\end{Bmatrix} \sum \limits_{d = 0}^n \begin{pmatrix} n - i \\ n - d \end{pmatrix} \cdot n^{\underline{d}} \\ = &\sum \limits_{i = 0}^k\begin{Bmatrix} k \\ i\end{Bmatrix} 2^{n - i}n^{\underline{d}} \end{align*}现在的瓶颈就是第二类斯特林数的求解，其有一个通项公式： S^n_k = \sum \limits_{i = 0}^n \frac{(-1)^i}{i!}\frac{(n - i)^k}{(n - i)!} \\卷积形式过于显然，直接优化即可。复杂度 $O(n \log n)$ 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 4800005typedef long long lint;using namespace std;const int mod = 998244353, G = 3;int n, k;lint a[MAXN], b[MAXN];lint fac[MAXN], inf[MAXN], down[MAXN];int r[MAXN];int getr(int n) &#123; int limit = 1, size = 0; while (limit &lt;= n) &#123; limit &lt;&lt;= 1; ++size; &#125; for (int i = 0; i &lt; limit; ++i) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (size - 1)); return limit;&#125;lint power(lint a, lint b) &#123; lint res = 1; while (b) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;void NTT(lint* a, int n, int opt) &#123; for (int i = 0; i &lt; n; ++i) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int i = 1; i &lt; n; i &lt;&lt;= 1) &#123; lint gn = power(opt == 1 ? G : power(G, mod - 2), (mod - 1) / (i &lt;&lt; 1)); for (int j = 0; j &lt; n; j += (i &lt;&lt; 1)) &#123; lint g = 1; for (int k = 0; k &lt; i; ++k) &#123; lint x = a[j + k], y = a[j + k + i] * g % mod; a[j + k] = (x + y) % mod; a[j + k + i] = (x - y + mod) % mod; g = g * gn % mod; &#125; &#125; &#125; if (opt == -1) &#123; lint inv = power(n, mod - 2); for (int i = 0; i &lt; n; ++i) a[i] = a[i] * inv % mod; &#125;&#125;void initiate(int n) &#123; fac[0] = 1; for (int i = 1; i &lt;= n; ++i) fac[i] = fac[i - 1] * i % mod; inf[n] = power(fac[n], mod - 2); for (int i = n - 1; i &gt;= 0; --i) inf[i] = inf[i + 1] * (i + 1) % mod; for (int i = 0; i &lt;= n; ++i) &#123; a[i] = (((i &amp; 1) ? -1ll : 1ll) * inf[i] + mod) % mod; b[i] = power(i, n) * inf[i] % mod; &#125; int limit = getr(n &lt;&lt; 1); NTT(a, limit, 1); NTT(b, limit, 1); for (int i = 0; i &lt; limit; ++i) a[i] = a[i] * b[i] % mod; NTT(a, limit, -1);&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; k; --n; initiate(k); lint ans = 0, down = 1; for (int i = 0; i &lt;= k &amp;&amp; i &lt;= n; ++i) &#123; ans = (ans + a[i] * down % mod * power(2, n - i) % mod) % mod; down = down * (n - i) % mod; &#125; ans = ans * (n + 1) % mod * power(2, 1ll * n * (n - 1) / 2) % mod; cout &lt;&lt; ans &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>组合数学</category>
        <category>生成函数</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>NTT</tag>
        <tag>计数</tag>
        <tag>斯特林反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 4491 - [HAOI2018]染色]]></title>
    <url>%2F2019%2F01%2FLuogu-4491-%5BHAOI2018%5D%E6%9F%93%E8%89%B2%2F</url>
    <content type="text"><![CDATA[首先，颜色数量不超过 $l = min(m,\frac{s}{k})$ 种。 设 $f(x)$ 为出现次数为 $s$ 的颜色至少有 $x$ 种的方案数。如果求出 $f(x)$ ，可以用容斥原理计算： g(x) = \sum \limits_{i = x}^l (-1)^{i - x}\begin{pmatrix} i \\x \end{pmatrix} f(i) \\对于 $f(x)$ 的计算，先选出 $x$ 种颜色，每种 $s$ 个，再把剩下的 $n - xs$ 看作一个整体。根据可重集计数，其方案数为 $\frac{n!}{(s!)^x(n - xs)!}$ 。接下来再分析 $n - xs$ 的方案数，发现可以任意放 $m - x$ 种颜色，方案数为 $(m - x)^{(n - xs)}$ 种。可以得到： f(x) = \begin{pmatrix} m \\ x\end{pmatrix} \frac{n!}{(s!)^x(n-xs)!}(m - x)^{n - xs} \\观察 $g(x)$： \begin{align*} g(x) &= \sum \limits_{i = x}^l (-1)^{i - x}\begin{pmatrix} i \\x \end{pmatrix} f(i) \\ g(x) &= \sum \limits_{i = x}^l (-1)^{i - x}\frac{i!}{(i - x)!x!}f(i) \\ g(x)x! &= \sum \limits_{i = x}^l \frac{(-1)^{i - x}}{(i - x)!} \cdot i!f(i) \\ g(x)x! &= \sum \limits_{i = 0}^{l - x} \frac{(-1)^{i}}{i!} \cdot (i + x)!f(i + x) \\ \end{align*}若将 $f(x)$ 反转，其为卷积的形式： g(x)x! = \sum \limits_{i = 0}^{l - x} \frac{(-1)^{i}}{i!} \cdot (l - i - x)!f(l - i - x) \\所以最后结果需要查询 $f_{l - i}$ 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 500005typedef long long lint;using namespace std;const lint mod = 1004535809, G = 3;int r[MAXN];int n, m, s;lint w[MAXN], fac[10000006], inf[10000005];lint f[MAXN], g[MAXN];int getr(int n) &#123; int limit = 1, size = 0; while (limit &lt;= n) &#123; limit &lt;&lt;= 1; ++size; &#125; for (int i = 0; i &lt; limit; ++i) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (size - 1)); return limit;&#125;int read() &#123; char c = getchar(); int x = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x;&#125;lint power(lint a, int b) &#123; lint res = 1; while (b) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;void NTT(lint* a, int n, int opt) &#123; for (int i = 0; i &lt; n; ++i) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int i = 1; i &lt; n; i &lt;&lt;= 1) &#123; lint gn = power(opt == 1 ? G : power(G, mod - 2), (mod - 1) / (i &lt;&lt; 1)); for (int j = 0; j &lt; n; j += (i &lt;&lt; 1)) &#123; lint g = 1; for (int k = 0; k &lt; i; ++k) &#123; lint x = a[j + k], y = a[j + k + i] * g % mod; a[j + k] = (x + y) % mod; a[j + k + i] = (x - y + mod) % mod; g = g * gn % mod; &#125; &#125; &#125; if (opt == -1) &#123; lint inv = power(n, mod - 2); for (int i = 0; i &lt; n; ++i) a[i] = inv * a[i] % mod; &#125;&#125;lint C(int n, int m) &#123; if (n &lt; m) return 0; return fac[n] * inf[m] % mod * inf[n - m] % mod;&#125;void init() &#123; fac[0] = 1; int l = max(m, max(n, s)); for (int i = 1; i &lt;= l; ++i) fac[i] = fac[i - 1] * i % mod; inf[l] = power(fac[l], mod - 2); for (int i = l - 1; i &gt;= 1; --i) inf[i] = inf[i + 1] * (i + 1) % mod; inf[0] = 1;&#125;int main() &#123; n = read(); m = read(); s = read(); init(); for (int i = 0; i &lt;= m; ++i) w[i] = read(); int l = min(m, n / s); for (int i = 0; i &lt;= l; ++i) f[l - i] = C(m, i) * fac[n] % mod * power(power(fac[s], i), mod - 2) % mod * inf[n - i * s] % mod * power(m - i, (n - i * s)) % mod * fac[i] % mod; for (int i = 0; i &lt;= l; ++i) g[l - i] = (1ll * (((l - i) &amp; 1) ? -1 : 1) * inf[l - i] + mod) % mod; int limit = getr((l + 1) &lt;&lt; 1); NTT(f, limit, 1); NTT(g, limit, 1); for (int i = 0; i &lt; limit; ++i) f[i] = f[i] * g[i] % mod; NTT(f, limit, -1); lint ans = 0; for (int i = 0; i &lt;= l; ++i) ans = (ans + 1ll * w[i] * f[l - i] % mod * inf[i] % mod) % mod; cout &lt;&lt; ans &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>组合数学</category>
        <category>生成函数</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>NTT</tag>
        <tag>计数</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配色修改]]></title>
    <url>%2F2019%2F01%2F%E9%85%8D%E8%89%B2%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[本文适用于 $next$ 修改成红色系列主题。 总体色调于 _variable/base.styl 中更改颜色： 12$orange = #d73b49$grey = #FA6464 侧边 brand 颜色首先先将 custom.styl 添加如下代码 12345678910111213// Custom styles..site-meta &#123; background: $orange;&#125;.site-subtitle &#123; color: white;&#125;.archive-move-on &#123; color: $orange; background: $orange;&#125; 顶部 header 颜色于 _variable/base.styl 更改如下代码： 1234// Headband// --------------------------------------------------$headband-height = 3px$headband-bg = $orange Archive 顶部小圆点于 pages/archive.styl 修改代码： 1234567891011121314.archive-move-on &#123; position: absolute; top: 11px; left: 0; margin-left: -6px; width: 10px; height: 10px; opacity: 0.75; background: $orange; border: 1px solid white; color: $orange; border-radius: 50%; // circle();&#125; 右边回到顶部图标于 back-to-top.styl 修改代码： 1234567891011121314151617181920212223242526272829303132.back-to-top &#123; box-sizing: border-box; position: fixed; bottom: $b2t-position-bottom; right: $b2t-position-right; z-index: $zindex-5; padding: 0 6px; width: hexo-config('sidebar.scrollpercent') ? initial : 24px; background: $orange; font-size: $b2t-font-size; opacity: 0.75; color: $b2t-color; cursor: pointer; text-align: center; -webkit-transform: translateZ(0); transition-property: bottom; the-transition(); +tablet() &#123; fixbutton() if hexo-config('sidebar.onmobile'); hide() if not hexo-config('sidebar.onmobile'); &#125; +mobile() &#123; fixbutton() if hexo-config('sidebar.onmobile'); hide() if not hexo-config('sidebar.onmobile'); &#125; &amp;.back-to-top-on &#123; bottom: $b2t-position-bottom-on; &#125;&#125; Read more 按钮于 _variable/pisces.styl 修改如下代码： 12345678// Button$btn-default-radius = 2px$btn-default-bg = white$btn-default-color = $text-color$btn-default-border-color = $text-color$btn-default-hover-color = white$btn-default-hover-bg = $orange$btn-default-hover-border-color = $orange 日期下划线于 post/post-meta.styl 修改如下代码： 1234time &#123; border-bottom: 1px dashed $grey; cursor: help;&#125; 标题下划线于 post/post_title.styl 修改如下代码： 12345678910111213141516171819202122232425262728293031.posts-expand .post-title-link &#123; display: inline-block; position: relative; color: $black-light; border-bottom: none; line-height: 1.2; vertical-align: top; &amp;::before &#123; content: ""; position: absolute; width: 100%; height: 2px; bottom: 0; left: 0; background-color: $orange; visibility: hidden; transform: scaleX(0); the-transition(); &#125; &amp;:hover::before &#123; visibility: visible; transform: scaleX(1); &#125; .fa &#123; font-size: 20px; margin-left: 5px; &#125;&#125; custom直接集成了所有的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502// Custom styles..site-meta &#123; background: $orange;&#125;.site-title &#123; -webkit-transform: perspective(1px) translateZ(0); transform: perspective(1px) translateZ(0); box-shadow: 0 0 1px rgba(0, 0, 0, 0); -webkit-transition-duration: 0.3s; transition-duration: 0.3s; -webkit-transition-property: transform; transition-property: transform; &amp;:hover &#123; -webkit-transform: scale(1.1); transform: scale(1.1); &#125;&#125;.site-subtitle &#123; color: white;&#125;::selection &#123; opacity: 0.9; background: $orange; color: white;&#125;::-moz-selection &#123; background: $orange; color: white;&#125;.headband &#123; height: 3px; background: $orange;&#125;.sita-meta &#123; background: $orange;&#125;.site-subtitle &#123; color: white;&#125;.btn &#123; color: $orange; background: white; border: 2px solid $orange;&#125;.btn:hover &#123; border-color: $orange; color: white; background: $orange;&#125;/*.post-nav-next &#123; color: $orange; a &#123; color: $orange; padding-left: 5px; &#125;&#125;.post-nav-prev &#123; color: $orange; text-align: right; a &#123; color: $orange; padding-right: 5px; &#125; .fa &#123; color: $orange; margin-left: 5px; &#125;&#125;*/.post-nav-prev &#123; display: table-cell; padding: 10px 0 0 0; width: 45%; vertical-align: top; text-align: right; color: $orange; a &#123; position: relative; display: block; line-height: 25px; font-size: 14px; color: $orange; border-bottom: none; padding-right: 5px; transition:color 0.4s; -webkit-transition:color 0.4s; -webkit-transform: perspective(1px) translateZ(0); transform: perspective(1px) translateZ(0); box-shadow: 0 0 1px rgba(0, 0, 0, 0); -webkit-transition-duration: 0.4s; transition-duration: 0.4s; -webkit-transition-property: transform; transition-property: transform; &amp;:hover &#123; color: $orange; border-bottom: none; -webkit-transform: translateX(15px); transform: translateX(15px); &#125; &amp;:active &#123; top: 0px; &#125; &#125; .fa &#123; font-size: 12px; margin-right: 5px; margin-left: 5px; &#125;&#125;.post-nav-next &#123; display: table-cell; padding: 10px 0 0 0; width: 45%; color: $orange; vertical-align: top; a &#123; position: relative; display: block; line-height: 25px; font-size: 14px; color: $orange; border-bottom: none; padding-left: 5px; -webkit-transform: perspective(1px) translateZ(0); transform: perspective(1px) translateZ(0); box-shadow: 0 0 1px rgba(0, 0, 0, 0); -webkit-transition-duration: 0.4s; transition-duration: 0.4s; -webkit-transition-property: transform; transition-property: transform; &amp;:hover &#123; color: $orange; border-bottom: none; -webkit-transform: translateX(-15px); transform: translateX(-15px); /*animation: wobble-horizontal 1s;*/ /*-webkit-animation: wobble-horizontal 1s; /*Safari and Chrome*/*/ &#125; @-webkit-keyframes wobble-horizontal &#123; 16.65% &#123; -webkit-transform: translateX(8px); transform: translateX(8px); &#125; 33.3% &#123; -webkit-transform: translateX(-6px); transform: translateX(-6px); &#125; 49.95% &#123; -webkit-transform: translateX(4px); transform: translateX(4px); &#125; 66.6% &#123; -webkit-transform: translateX(-2px); transform: translateX(-2px); &#125; 83.25% &#123; -webkit-transform: translateX(1px); transform: translateX(1px); &#125; 100% &#123; -webkit-transform: translateX(0); transform: translateX(0); &#125; &#125; @keyframes wobble-horizontal &#123; 16.65% &#123; -webkit-transform: translateX(8px); transform: translateX(8px); &#125; 33.3% &#123; -webkit-transform: translateX(-6px); transform: translateX(-6px); &#125; 49.95% &#123; -webkit-transform: translateX(4px); transform: translateX(4px); &#125; 66.6% &#123; -webkit-transform: translateX(-2px); transform: translateX(-2px); &#125; 83.25% &#123; -webkit-transform: translateX(1px); transform: translateX(1px); &#125; 100% &#123; -webkit-transform: translateX(0); transform: translateX(0); &#125; &#125; &amp;:active &#123; top: 0px; &#125; &#125; .fa &#123; font-size: 12px; margin-right: 5px; &#125;&#125;.posts-expand .post-title-link &#123; display: inline-block; position: relative; color: $black-light; border-bottom: none; line-height: 1.2; vertical-align: top; -webkit-transform: perspective(1px) translateZ(0); transform: perspective(1px) translateZ(0); -webkit-transition-duration: 0.33s; transition-duration: 0.33s; -webkit-transition-property: transform; transition-property: transform; &amp;::before &#123; content: ""; position: absolute; width: 100%; height: 2px; bottom: -3px; left: 0; background-color: $orange; visibility: hidden; transform: scaleX(0); t-webkit-transition-duration: 0.33s; transition-duration: 0.33s; &#125; &amp;:hover::before &#123; visibility: visible; transform: scaleX(1); &#125; .fa &#123; font-size: 20px; margin-left: 5px; &#125; &amp;:hover &#123; -webkit-transform: scale(1.1); transform: scale(1.1); color: $orange; &#125;&#125;.posts-expand .post-meta &#123; time &#123; border-bottom: 1px dashed $grey; cursor: help; &#125;&#125;.back-to-top &#123; margin: 0 auto; background: $orange; opacity: 0.75; border-radius: 3px; display: inline-block; transition: opacity 0.3s; -webkit-transform: perspective(1px) translateZ(0); transform: perspective(1px) translateZ(0); box-shadow: 0 0 1px rgba(0, 0, 0, 0); -webkit-transition-duration: 0.3s; transition-duration: 0.3s; transition-property: bottom, opacity, transform; -webkit-transition-property: bottom, opacity, transform; the-transition(); &amp;:hover &#123; opacity: 1; -webkit-transform: scale(1.2); transform: scale(1.2); &#125;&#125;.pagination &#123; .prev, .next, .page-number &#123; @extend .page-number-basic; border-bottom: 0; border-top: 1px solid $pagination-link-border; transition-property: grey; the-transition(); &amp;:hover &#123; border-top-color: $orange; &#125; &#125; .space &#123; @extend .page-number-basic; padding: 0; margin: 0; &#125; .prev &#123; margin-left: 0; &#125; .next &#123; margin-right: 0; &#125; .page-number.current &#123; color: $pagination-active-color; background: $orange; border-top-color: $pagination-active-border; &#125;&#125;.post-meta a &#123; color: $black-dim; border-bottom: none; display: inline-block; position: relative; &amp;::before &#123; content: ""; position: absolute; width: 100%; height: 1px; bottom: 3px; left: 0; background-color: $orange; visibility: hidden; transform: scaleX(0); the-transition(); &#125; &amp;:hover::before &#123; visibility: visible; transform: scaleX(1); &#125; .fa &#123; font-size: 20px; margin-left: 5px; &#125; &amp;:hover &#123; color: $orange; &#125;&#125;.page-archive &#123; .posts-collapse &#123; .archive-move-on &#123; position: absolute; top: 11px; left: 0; margin-left: -6px; width: 10px; height: 10px; opacity: 1; background: $orange; border: 1px solid white; color: $grey; border-radius: 50%; // circle(); &#125; &#125;&#125;.posts-collapse &#123; .post-header &#123; position: relative; the-transition(); transition-property: border; border-bottom: 1px dashed $grey-light; &amp;::before &#123; content: " "; position: absolute; left: 0; top: 12px; width: 6px; height: 6px; margin-left: -4px; opacity: 0.5; background: $grey; circle(); border: 1px solid white; transition: opacity 0.3s; the-transition(); -webkit-transform: perspective(1px) translateZ(0); transform: perspective(1px) translateZ(0); box-shadow: 0 0 1px rgba(0, 0, 0, 0); -webkit-transition-duration: 0.3s; transition-duration: 0.3s; -webkit-transition-property: background, opacity, transform; transition-property: background, opacity, transform; &#125; &#125; .post-header:hover &#123; border-bottom-color: $grey; &amp;::before &#123; opacity: 1; -webkit-transform: scale(1.3); transform: scale(1.3); background: $grey; &#125; &#125;&#125;.posts-expand .post-tags &#123; margin-top: 40px; text-align: center; a &#123; color: $black-dim; display: inline-block; position: relative; border-bottom: none; margin-right: 10px; font-size: 13px; &amp;::after &#123; content: ""; position: absolute; width: 100%; height: 1px; bottom: -3px; left: 0; background-color: $orange; visibility: hidden; transform: scaleX(0); the-transition(); &#125; &amp;:hover::after &#123; visibility: visible; transform: scaleX(1); &#125; &amp;:hover &#123; color: $orange; opacity: 1; &#125; &#125;&#125;.tag-cloud &#123; text-align: center; a &#123; display: inline-block; margin: 10px; transition: color 0.3s, border-bottom-color 0.3s; -moz-transition: color 0.3s, border-bottom-color 0.3s; /* Firefox 4 */ -webkit-transition: color 0.3s, border-bottom-color 0.3s; /* Safari 和 Chrome */ -o-transition: color 0.3s, border-bottom-color 0.3s; /* Opera */ -webkit-transform: perspective(1px) translateZ(0); transform: perspective(1px) translateZ(0); box-shadow: 0 0 1px rgba(0, 0, 0, 0); -webkit-transition-duration: 0.3s; transition-duration: 0.3s; -webkit-transition-property: transform; transition-property: transform; &#125; a:hover &#123; color: $orange !important; border-bottom-color: $orange !important; -webkit-transform: scale(1.1) rotate(-5deg); transform: scale(1.1) rotate(-5deg); &#125;&#125;.category-all-page &#123; .category-list-link &#123; border-bottom: none; transition: color 0.3s, border-bottom-color 0.3s; -moz-transition: color 0.3s, border-bottom-color 0.3s; -webkit-transition: color 0.3s, border-bottom-color 0.3s; -o-transition: color 0.3s, border-bottom-color 0.3s; display: inline-block; vertical-align: middle; -webkit-transform: perspective(1px) translateZ(0); transform: perspective(1px) translateZ(0); box-shadow: 0 0 1px rgba(0, 0, 0, 0); -webkit-transition-duration: 0.3s; transition-duration: 0.3s; -webkit-transition-property: transform, color; transition-property: transform, color; &amp;:hover &#123; color: $orange; -webkit-transform: scale(1.1); transform: scale(1.1); &#125; &#125; .category-list-count &#123; color: $orange; &#125;&#125;]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拉格朗日插值]]></title>
    <url>%2F2019%2F01%2F%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%2F</url>
    <content type="text"><![CDATA[拉格朗日插值是一种算法，通过构造的方式，解决这个多项式在某一个点的取值问题。 构造尝试构造一个函数： \zeta_j(x) = \prod \limits_{i = 1, i \ne j} \frac{x - x_i}{x_j - x_i}可以发现，这个式子只有在 $x = x_j$ 时取到 $1$ ，其余时候当 $\exists j, x_j = x$ 时取 $0$ 。 L(x) = \sum \limits_{i = 1}^n y_i\zeta_i(x)由于第一个式子的性质，可以发现对于 $\forall x_i$ ， $L(x) = y_i$ 。也就是说， $L(x)$ 是穿过 $(x_i, y_i)$ 的一个函数。 通过这种构造方法出来的多项式，次数不超过 $n$ 的只有一个；次数高的有无穷多个：与 $L$ 相差 $(x - x_0)(x - x_1)\cdots(x- x_n)$ 皆可行。 查询已经构造出 $L(x)$ ，对于 $x = k$ 的查询，只需要把 $x = k$ 带入，得到的 $y$ 就是答案。 查询的复杂度是 $O(n^2)$ 的。 优化对于一种特殊情况： $x$ 的取值连续的时候（离散意义下的连续）， 有一个做法使其达到 $O(n)$ 。 使 $x_i = i$ 易于讨论，其他情况做法一样，式子化为： \zeta_j(k) = \frac{k - j}{i - j}考虑分子的形式，维护 $p_i = \prod \limits_{j = 1}^{i} k - i $ ， $\prod \limits_{j = i}^n k - i$ ，分母显然是个阶乘式子可以转化为： L(k) = \sum \limits_{i = 1}^n y_i \frac{pre_{i - 1}suf_{i + 1}}{fac_ifac_{n - i}}其中 $fac_i = i!$ 。 重心拉格朗日插值已经有： L(x) = \sum \limits_{j = 1}^n y_j\prod \limits_{i = 1, i \ne j} \frac{x - x_i}{x_j - x_i}设 $g = \prod \limits_{i = 1}^n x - x_i$ ，则: L(x) = g\sum \limits_{i = 1}^n\prod \limits_{j = 1, i \ne j} \frac{y_i }{(x_i - x_j)(x - x_i)} \\设： $t_i = \frac{y_i}{\prod \limits_{j \neq i}x_i - x_j}$ ，则： L(x) = g\sum \limits_{i = 1}^n\prod \limits_{j = 1, i \ne j} \frac{t_i }{(x - x_i)} \\这样每新加入一个点只需要计算 $t_i$ 即可。 求系数拉格朗日差值可以在 $O(n)$ 的时间内求出某一项的系数，与之相比的朴素高斯消元求系数是 $O(n^3)$ 的。 已经有： \zeta_j(x) = \prod \limits_{i = 1, i \ne j} \frac{x - x_i}{x_j - x_i}我们求解的答案为： L(x) = \sum \limits_{i = 1}^n y_i\zeta_i(x)对于 $x^k$ 有一种增量法能够求出：每次加入一个点，对于 $\frac{x - x_i}{x_j - x_i}$ 要么是已有的 $x^k$ 的系数乘上 $x^i$ ，要么是加上 $x^{k - 1}$ 的系数。 然后对于每一个 $y_i$ ，由于有 $i \neq j$ 的限制，先使 $i$ 点的贡献撤销，统计答案后加入。此处无需优化即可 $O(n)$ 。]]></content>
      <categories>
        <category>数学</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>拉格朗日插值</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[级数]]></title>
    <url>%2F2019%2F01%2F%E7%BA%A7%E6%95%B0%2F</url>
    <content type="text"><![CDATA[对于一个有穷或无穷的数列 $f_1, f_2, \cdots$ 的元素的形式和 $S$ 称为级数。显然，无穷数列的级数称为无穷级数。 无穷级数具有敛散性，无穷级数只有在收敛的时候才有和，发散的无穷级数在一般意义上没有和。 幂级数幂级数就是形如 $f(n) = \sum \limits_{n = 0}^{\infty } a_nx^n$ 的式子。 形式幂级数形式幂级数是一个数学中的抽象概念，是从幂级数中抽离出来的代数对象。形式幂级数和从多项式中剥离出来的多项式环类似，不过允许（可数）无穷多项因子相加，但不像幂级数一般要求研究是否收敛和是否有确定的取值。形式幂级数在代数和组合理论中有广泛应用。 复合运算对于形式幂级数 $A(x)$ 和 $B(x)$ ，其复合为： C(x) = A \circ B(x) = \sum \limits_i a_i(B(x))^i对数函数形式幂级数的对数函数被定义为给定级数与对应麦克劳林级数的复合： \ln(1 - A(x)) = - \sum \limits_{i = 1} \frac{A(x)^i}{i}指数函数形式幂级数的指数函数被定义为给定级数与对应麦克劳林级数的复合： \exp(A(x)) = \sum \limits \frac{A(x)^i}{i!}乘法逆元当 $A(x)B(x) = 1$ 时，称 $A(x)$ ，$B(x)$ 互为乘法逆元。 复合逆设 $f(w) = \sum \limits_{i = 1} f_iw^i$ ，$g(x) = \sum \limits_{i = 1} g_ix^i$ ，若 $f(g(x)) = x$，那么称 $f(w)$ 和 $g(x)$ 互为复合逆。 同时，$f_1g_1 = 1$，$g(f(w)) = w$ 。 泰勒级数泰勒级数就是用级数来表示一个函数。有限项的泰勒级数被称为叫做泰勒多项式。 对于一个函数 $f(x)$ ，我们可以求得其泰勒级数为：$\sum \limits_n \frac{f^{(n)}(a)}{n!}(x - a)^n$ 。 在这个级数中，$f^{(n)}(a)$ 为在位置 $a$ 处 $f$ 的 $n$ 阶导数。 泰勒级数是用来仿造一个函数的，这个函数具有这样的特点：求导简单，计算复杂。一个特别好的例子就是三角函数。显然的，对于一个三角函数和多项式来说，多项式更好求解。那么我们如果能构造出一个多项式，使其极其接近原来的函数，那么求值问题迎刃而解。 那么考虑一个问题，如何仿造一个函数？设原函数为 $f(x)$ ，仿造函数为 $g(x)$ ，若对于一点，$\forall i \in [1, +\infty] , f^{(i)} = g^{(i)}$ 那么这两个函数重合。利用这个思路，我们就可以推出泰勒级数了。 麦克劳林级数对于在自变量零点的导数求得的泰勒级数称作麦克劳林级数。 下表给出常见的麦克劳林级数： 级数 序列 范围 $\frac{1}{1 - x}$ $\sum \limits_n x^n$ $x \in (-1, 1)$ $e^x$ $\sum \limits_n \frac{x^n}{n!}$ $x \in [-\infty, \infty]$ $\ln(1 + x)$ $\sum \limits_{n = 1} \frac{(-1)^{n + 1}}{n}x^n$ $x \in (-1, 1]$ $\ln(1 - x)$ $-\sum \limits_{n = 1} \frac{x^n}{n}$ $x \in (-1, 1]$]]></content>
      <categories>
        <category>数学</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>形式幂级数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[导数]]></title>
    <url>%2F2019%2F01%2F%E5%AF%BC%E6%95%B0%2F</url>
    <content type="text"><![CDATA[导数是用来分析函数在某一点的变化率的工具。 概念导数(Derivative)是微积分学中重要的基础概念。 一个函数在某一点的导数描述了这个函数在这一点附近的变化率。导数的本质是通过极限的概念对函数进行局部的线性逼近。 当函数 ${\displaystyle f}$ 的自变量在一点 $ {\displaystyle x_{0}} $上产生一个增量 ${\displaystyle h}$ 时，函数输出值的增量与自变量增量 ${\displaystyle h}$ 的比值在 ${\displaystyle h}$ 趋于0时的极限如果存在，即为 ${\displaystyle f}$ 在 ${\displaystyle x_{0}}$ 处的导数，记作 ${\displaystyle f’(x_{0})}$ 。 定义函数意义： f'(x_0)=\lim_{\Delta x \to 0}\frac{\Delta y}{\Delta x}=\lim_{\Delta x \to 0}\frac{f(x_0+\Delta x)-f(x_0)}{\Delta x}几何意义： {\displaystyle \tan \alpha =\lim _{\Delta x\to 0}\tan \varphi =\lim _{\Delta x\to 0}{\frac {f(x_{0}+\Delta x)-f(x_{0})}{\Delta x}}}可导条件首先，要使函数 ${\displaystyle f}$ 在一点可导，那么函数一定要在这一点处连续。换言之，函数若在某点可导，则必然在该点处连续。 然而，连续性并不能保证可导性。即使函数在一点上连续，也不一定就在这一点可导。 左导数：${\displaystyle f’_{-}(x_{0})=\lim _{\Delta x\to 0^{-}}{\frac {f(x_{0}+\Delta x)-f(x_{0})}{\Delta x}}} f’_{-}(x_0)=\lim_{\Delta x \to 0^{-}}\frac{f(x_0+\Delta x)-f(x_0)}{\Delta x} $右导数： ${\displaystyle f’_{+}(x_{0})=\lim _{\Delta x\to 0^{+}}{\frac {f(x_{0}+\Delta x)-f(x_{0})}{\Delta x}}} f’_{+}(x_0)=\lim_{\Delta x \to 0^{+}}\frac{f(x_0+\Delta x)-f(x_0)}{\Delta x} $ 如果函数在一点的左右导数都存在并且相等，那么函数在该处可导。 单调性$f(b) - f(a) = \int^b_a f’(t)\mathrm{d}t$ 如果函数的导函数在某一区间内恒大于零（或恒小于零），那么函数在这一区间内单调递增（或单调递减），这种区间也称为函数的单调区间。 导函数等于零的点称为函数的驻点，在这类点上函数可能会取得极大值或极小值。进一步判断则需要知道导函数在附近的符号。 对于满足 ${\displaystyle f’(x_{0})=0}$ 的一点 ${\displaystyle x_{0}}$ ，如果存在 ${\displaystyle \delta &gt;0}$ 使得 ${\displaystyle f’}$ 在区间 ${\displaystyle (x_{0}-\delta ,x_{0}]}$ 上都大于等于零，而在区间 ${\displaystyle [x_{0},x_{0}+\delta )}$ 上都小于等于零，那么 ${\displaystyle x_{0}}$ 是一个极大值点，反之则为极小值点。 如果 ${\displaystyle f’’(x_{0})=0}$ 并且 ${\displaystyle f’’(x)}$ 在 ${\displaystyle x_{0}}$ 改变加减号，则称这个点是拐点；否则这个点不是拐点。 凹凸性可导函数的凹凸性与其导数的单调性有关。如果函数的导函数在某个区间上单调递增，那么这个区间上函数是向下凸的，反之则是向上凸的。 如果二阶导函数存在，也可以用它的正负性判断，如果在某个区间上 $f’’$ 恒大于零，则这个区间上函数是向下凸的，反之这个区间上函数是向上凸的. 基本导数如果 $f(x) = x^r$，其中 $r$ 是非零实数，那么导函数 $f’(x) = rx^{r-1}$ 。 原数 导数 $x^a$ $ax^{a - 1}$ $a^x$ $\ln a^x$ $e^x$ $e^x$ $\ln(x)$ $\frac{1}{x}$ $\log_a(x)$ $\frac{1}{x\ln a }$ $\sin(x)$ $\cos(x)$ $\tan(x)$ $\frac{1}{\cos^2(x)}$ $\cos(x)$ $-\sin(x)$ $\cot(x)$ $\frac{1}{sin^2(x)}$ $\arcsin(x)$ $\frac{1}{\sqrt{1 - x^2}}$ $\arccos(x)$ $-\frac{1}{\sqrt{1 - x^2}}$ $\arctan(x)$ $\frac{1}{1+ x^2}$ 可以发现一个有趣的事情：对于 $e^x$ 和部分三角函数的高阶求导其实是一件很容易的事情。 求导法则 \begin{align*} (af + bg)' &= af' + bg' \\ (fg)' &= f'g + fg' \\ \left(\frac{f}{g} \right)' &= \frac{f'g - fg'}{g^2} \\ \end{align*}如果有复合函数 $f(x)=h[g(x)]$，那么 $f’(x)=h’[g(x)]\cdot g’(x)$。 偏导数如果有函数 ${\displaystyle f}$ 其自变量不是单个实数，而是多于一个元素，例如： f(x,y) = x^2 + xy + y^2这时可以把其中一个元素（比如 $x$）看做参数，那么 $f$ 可以看做是关于另一个元素的参数函数： f(x,y) = f_x(y) = x^2 + xy + y^2也就是说，对于某个确定的 $x$，函数 $f_x$ 就是一个关于 $y$ 的函数。在 $x=a$ 固定的情况下，可以计算这个函数 $f_x$ 关于 $y$ 的导数。 f_a'(y) = a + 2y记作： {\displaystyle {\frac {\partial f}{\partial y}}(x,y)=x+2y}上面的极限中，除了 $x_{i}$ 外所有的自变元都是固定的，这就确定了一个一元函数： f_{a_1,\ldots,a_{i-1},a_{i+1},\ldots,a_n}(x_i) = f(a_1,\ldots,a_{i-1},x_i,a_{i+1},\ldots,a_n)因此，按定义有： {\displaystyle {\frac {df_{a_{1},\ldots ,a_{i-1},a_{i+1},\ldots ,a_{n}}}{dx_{i}}}(a_{i})={\frac {\partial f}{\partial x_{i}}}(a_{1},\ldots ,a_{n}).}方向导数方向导数是比偏导数更加广泛的概念。导数的本质是函数值增量与自变量增量之比的极限。 在多元函数 $f$ 中，可以选定一个确定的方向（以这个方向上的单位向量 $\delta$ 表示），并考虑函数在这个方向上的增量： f(x_0 + t \delta) - f(x_0)这个增量为关于 $t$ 的一元函数。函数 $f$ 的方向导数定义为这个增量与 $t$ 的比值在 $t$ 趋于 $0$ 时的极限，记为： \frac{\partial f}{\partial \delta}(x_0)方向导数表示了函数从某点开始在某个方向上的变化率。 在 $\mathbf{R}^n$ 中，如果将向量 $\delta$ 选为正规基 $\left(e_1 , e_2 , \cdots, e_n \right)$ 之中的一个，如 $e_i$，那么方向导数就是关于 $x_{i}$ 的偏导数。]]></content>
      <categories>
        <category>数学</category>
        <category>高等</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式]]></title>
    <url>%2F2019%2F01%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[多项式是一类形如 $\sum \limits_{i = 0} a_ix^i $ 的式子，本文将讨论其一些运算形式。 多项式求逆已知 $A(x)$ ，求 $A(x)B(x) \equiv 1 \pmod{x^n}$ 这个问题看上去不好求解，考虑用递归。假设我们已经求出 $A(x)B’(x) \equiv 1 \pmod{x^{\frac{n}{2}}}$ 那么： \begin{align*} A(x)B'(x) - A(x)B(x) &\equiv 1 \pmod{x^{\frac{n}{2}}} \\ A(x)(B'(x) - B(x)) &\equiv 0 \pmod{x ^ {\frac{n}{2}}} \\ B'(x) - B(x) &\equiv 0 \pmod{x ^ {\frac{n}{2}}} \\ (B'(x) - B(x)) ^ 2 &\equiv 0 \pmod{x ^ n} \\ B'(x) ^ 2 - 2B'(x)B(x) + B(x)^2 &\equiv 0 \pmod{x ^ n} \\ A(x)B'(x)^2 - 2B'(x) + B(x) &\equiv 0 \pmod{x ^ n} \\ B(x) &\equiv 2B'(x) - A(x)B'(x)^2 \pmod{x ^ n} \end{align*}现在未知量已经被我们表示出来了。可以发现 $B(x)$ 可以用卷积求解，且复杂度为 $O(n \log n)$ 。 分治 $FFT$已知 $g(x)$ ，求 $f(x) = \sum \limits_{i = 1}^n f(n - i)g(i)$ 这个可以看作前面结果对后面有影响的多项式乘法。基于这个思想，我们可以使用分治来解决问题。倘若我们已经求出了 $[l, mid]$ 的答案，那么我们记入其对 $[mid + 1, r]$ 的影响，即可解决问题。 可以发现影响是：$w(x) = \sum \limits_{i = 1}^n f(n - i)g(i)$ ，与上面是如出一辙的。但是此处的 $n = r - l + 1$ ，$f$ 是从 $l$ 开始计数的。那么可以用分治解决问题了。 多项式对数函数求 $A(x) = \ln B(x)$ 。 看上去不大可解，那么我们求导。 $A’(x) = \frac{B’(x)}{B(x)}$ 那么就可解了，只需要求逆和求导，最后不定积分回去即可。 牛顿迭代法已知 $G(F(x)) \equiv 0 \pmod{x^n}$ ，并且知道 $G(x)$ ，求 $F(x)$ 。 首先当 $n = 1$ 时，$G(F(x)) \equiv 0 \pmod{x}$ ，这个是可以求出的。 那么当我们已经求出 $G(F(x)) \equiv 0 \pmod{x^{\lceil\frac{n}{2}\rceil}}$ ，考虑在 $F_0(x)$ 处用泰勒级数推出答案。 \begin{align*} G(F(x)) & \equiv G(F_0(x)) + \sum \limits_{i = 1}^n \frac{G^{(n)}(F_0(x))}{n!}(F(x) - F_0(x))^n \\ G(F(x)) & \equiv G(F_0(x)) + G'(F_0(x))(F(x) - F_0(x)) \\ \end{align*}对第二步进行说明：当 $i &gt; 1$ 时，由于 $F(x)$ 和 $F_0(x)$ 的前 $\lceil \frac{n}{2} \rceil $ 项是相同的，那么 $(F(x) - F_0(x))^2$ 的最低的非 $0$ 的次项必然大于 $n$ ，不符合我们要求的内容，故舍去。 然后又因为 G(F(x)) \equiv 0 \pmod{x^n}所以: F(x) \equiv F_0(x)-\frac{G(F_0(x)) }{G'(F_0(x))} \pmod{x^n}多项式指数函数求 $A(x) = \exp(B(x))$ 。 由于 $\exp$ ，求导并无可能，应该考虑转化成指数函数： \ln A(x) - B(x) = 0构造函数： G(A(x)) = \ln A(x) - B(x) = 0根据牛顿迭代法： A(x) = A_0(x) - \frac{G(A_0(x))}{G'(A_0(x))} \pmod{x^n} \\ A(x) = A_0(x)(1 - \ln A_0(x) + B(x))多项式开方求 $B(x)^2 \equiv A(x) \pmod{x^n}$ 那么我们先假设我们求出 $B’(x)^2 \equiv A(x) \pmod{x^{\frac{n}{2}}}$ \begin{align*} B'(x)^2 &\equiv F(x) \pmod{x^{\frac{n}{2}}} \\ B(x)^2 &\equiv F(x) \pmod{x^{\frac{n}{2}}} \\ B(x)^2 - B'(x)^2 &\equiv 0 \pmod{x^{\frac{n}{2}}} \\ (B(x) - B'(x))(B(x) + B'(x)) &\equiv 0 \pmod{x^{\frac{n}{2}}} \\ B(x) - B'(x) &\equiv 0 \pmod{x^{\frac{n}{2}}} \\ B(x)^2 - 2B(x)B'(x) + B'(x)^2 & \equiv 0 \pmod{x^n} \\ B(x) & \equiv \frac{A(x) + B'(x)^2}{2B'(x)} \pmod{x^n} \end{align*}利用牛顿迭代法，我们先构造 $F(x)^2 \equiv A(x)$ ，目的是要求解 $F(x) \pmod{x^n}$ 设 $G(F(x)) \equiv F(x)^2 - A(x)$ ，那么 $G’(F(x)) = 2F(x)$ ，带入上面的迭代方程： \begin{align*} F(x) &= F_0(x) - \frac{F_0(x)^2 - A(x)}{2F(x)} \\ F(x) & = \frac{F_0(x)^2 + A(x)}{2F(x)} \end{align*}需要注意的是，若 $[x^0]A(x) = 1$ 才可以求解计算，否则要计算二次剩余。 然后采用相似于多项式求逆的方法求即可。注意这个算法的复杂度仍然是 $O(n \log n)$ 的，但是常数非常大。 多项式除法已知 $n$ 次多项式$F(x)$ 和 $m$ 次多项式 $ G(x)$ ，求 $Q(x)$ ，$R(x)$ ，使其满足： $Q(x)$ 次数为 $n - m$ ，$R(x)$ 次数小于 $m$ 。 $\begin{aligned}F(x) = Q(x) \times G(x) + R(x) \end{aligned}$ 如果没有 $R(x)$ 的干扰，这个式子将会好求很多！ 定义一个运算：$A^R(x) = x^nA(\frac{1}{x})$ ，即将多项式 $A(x)$ 的系数反转，可以将原式化为： \begin{align*} x^nF(\frac{1}{x}) &= x^{n}Q(\frac{1}{x})x^{n - m}G(\frac{1}{x}) + x^{n - m + 1}x^{m - 1}R(\frac{1}{x}) \\ F^R(x) &= Q^R(x)G^R(x) + x^{n - m + 1}R^R(x) \\ \end{align*}$Q(x)$ 的次数显然是不会大于 $n - m$ 的，然而 $R^R(x)$ 的最低次项为 $n - m + 1$ ，在 $\bmod{x^{n - m + 1}}$ 的意义下， $R(x)$ 并不会产生影响，所以化为： F^R(x) = Q^R(x)G^R(x) \pmod{x^{n - m + 1}}现在随便求个逆元就能得到 $Q(x)$ 了，求出之后回带一下就可以求出 $R(x)$ 。 代码最后附上使用 $vector$ 容器，并且相对而言封装好了的代码。 采用 $vector$ 真的是太优美了，与数组相比调试简单许多，代码也更精炼，唯一的缺点就是常数大：或许是不可避免的，因为为了优美强行传入 $vector$ ，一次代价就是 $O(n)$ 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#define MAXN 200010using namespace std;typedef long long lint;typedef vector&lt;lint&gt; poly;const int mod = 998244353;const int INV2 = (mod + 1) &gt;&gt; 1;const int G = 3;int r[MAXN];int read() &#123; char c = getchar(); int x = 0, s = 1; while (!isdigit(c)) &#123; if (c == '-') s = -1; c = getchar(); &#125; while (isdigit(c)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); &#125; return x * s;&#125;lint power(lint a, int b) &#123; lint res = 1; while (b) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;void NTT(poly&amp; a, int n, int b) &#123; a.resize(n); for (int i = 0; i &lt; n; ++i) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int i = 1; i &lt; n; i &lt;&lt;= 1) &#123; lint gn = power(b == 1 ? G : power(G, mod - 2), (mod - 1) / (i &lt;&lt; 1)); for (int j = 0; j &lt; n; j += (i &lt;&lt; 1)) &#123; lint g = 1; for (int k = 0; k &lt; i; ++k) &#123; lint x = a[j + k], y = a[j + k + i] * g % mod; a[j + k] = (x + y) % mod; a[j + k + i] = (x - y + mod) % mod; g = g * gn % mod; &#125; &#125; &#125; if (b == -1) &#123; lint inv = power(n, mod - 2); for (int i = 0; i &lt; n; ++i) a[i] = a[i] * inv % mod; &#125;&#125;int init(int n) &#123; int limit = 1, size = 0; while (limit &lt; n) &#123; limit &lt;&lt;= 1; ++size; &#125; for (int i = 0; i &lt; limit; ++i) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (size - 1)); return limit;&#125;poly inverse(poly a) &#123; int n = (int)a.size(); if (n == 1) return poly(1, power(a[0], mod - 2)); poly b(a); b.resize((n + 1) &gt;&gt; 1); b = inverse(b); int limit = init((int)b.size() * 2 + n); NTT(a, limit, 1); NTT(b, limit, 1); for (int i = 0; i &lt; limit; ++i) b[i] = b[i] * (2ll - a[i] * b[i] % mod + mod) % mod; NTT(b, limit, -1); b.resize(n); return b;&#125;poly operator * (poly a, poly b) &#123; int n = (int)a.size() + (int)b.size() - 1, limit = init(n); NTT(a, limit, 1); NTT(b, limit, 1); for (int i = 0; i &lt; limit; ++i) a[i] = a[i] * b[i] % mod; NTT(a, limit, -1); a.resize(n); return a;&#125;poly operator + (const poly&amp; a, const poly&amp; b) &#123; poly c(max(a.size(), b.size())); copy(a.begin(), a.end(), c.begin()); for (int i = 0; i &lt; b.size(); ++i) c[i] = (c[i] + b[i]) % mod; return c;&#125;poly operator - (const poly&amp; a, const poly&amp; b) &#123; poly c(max(a.size(), b.size())); copy(a.begin(), a.end(), c.begin()); for (int i = 0; i &lt; b.size(); ++i) c[i] = (c[i] - b[i] + mod) % mod; return c;&#125;poly operator / (poly a, poly b) &#123; int n = (int)a.size(), m = (int)b.size(); poly c(1); if (n &lt; m) return c; reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); b.resize(n - m + 1); c = inverse(b) * a; c.resize(n - m + 1); reverse(c.begin(), c.end()); return c;&#125;poly operator % (poly a, poly b) &#123; int n = (int)a.size() - 1, m = (int)b.size() - 1; poly c; if (n &lt; m) c = a; else c = a - (a / b) * b; c.resize(m); return c;&#125;poly derivative(const poly&amp; a) &#123; int n = (int)a.size(); poly b(n - 1); for (int i = 1; i &lt; n; ++i) b[i - 1] = a[i] * i % mod; return b;&#125;poly integral(const poly&amp; a) &#123; int n = (int)a.size(); poly b(n + 1); for (int i = 1; i &lt; n; ++i) b[i] = a[i - 1] * power(i, mod - 2) % mod; return b;&#125;poly ln(const poly&amp; a) &#123; poly b = integral(derivative(a) * inverse(a)); b.resize(a.size()); return b;&#125;poly exp(const poly&amp; a) &#123; int n = 1; poly one(1, 1), c(1, 1); while (n &lt; (a.size() &lt;&lt; 1)) &#123; n &lt;&lt;= 1; poly b(a), t = ln(c); b.resize(n); c = c * (one - ln(c) + b); c.resize(n); &#125; c.resize(a.size()); return c;&#125;poly operator ^ (poly&amp; a, int b) &#123; poly c = ln(a); for (int i = 0; i &lt; c.size(); ++i) c[i] = c[i] * b % mod; return exp(c);&#125;poly sqrt(poly a) &#123; int n = (int)a.size(); if (n == 1) return poly(1, int(sqrt(a[0]))); poly b(a); b.resize((n + 1) &gt;&gt; 1); b = sqrt(b); b.resize(n); poly inv = inverse(b); int limit = init((int)inv.size() + n); NTT(a, limit, 1); NTT(inv, limit, 1); for (int i = 0; i &lt; limit; ++i) a[i] = a[i] * INV2 % mod * inv[i]; NTT(a, limit, -1); for (int i = 0; i &lt; n; ++i) b[i] = (b[i] * INV2 % mod + a[i]) % mod; return b;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成函数]]></title>
    <url>%2F2019%2F01%2F%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[生成函数，又名母函数，是求解组合数学中计数问题的重要方法，其有两种形式：普通型生成函数和指数型生成函数。 普通型生成函数定理集合 $S = \{a_1, a_2, \cdots, a_n\}$ ，且限定 $a_i$ 出现的次数集合为 $M_i$ ，则其生成函数为： $\prod \limits_{i = 1}^n \sum \limits_{m \in M_i} x^m$。 对于一个数列 $f_0, f_1, \cdots, f_n$ 构造形式级幂数 $F(x) = \sum \limits_{i = 0}^\infty f_ix^i$ ，则称 $F(x)$ 为 $f$ 的生成函数。 对于数列与生成函数的相互转换，运用泰勒展开和等比数列求和。 同时声明：对于下文的 $\sum \limits_i = \sum \limits_{i = 0}^\infty$ 。 数列与生成函数给出一些生成函数的基本运算： \begin{align*} \alpha F(x) + \beta G(x) &= \sum \limits_n(\alpha f_n + \beta f_n) x^n \\ x^mF(x) &= \sum \limits_{n \geq m} f_{n - m}x^n \\ \frac{F(x) - \sum \limits_{i = 0}^{m - 1}f_ix^i}{x^m} &= \sum \limits_n f_{n + m}x^n \\ F(cx) &= \sum \limits_n f_nc^nx^n \\ F'(x) &= \sum \limits_{n} (n + 1)f_{n + 1}x^n \\ \int_0^xF(t)dt &= \sum \limits_{n > 0} \frac{f_{n - 1}}{n} x^n \\ F(x)G(x) &= \sum \limits_n (\sum \limits_{i}^nf_ig_{n - i})x^n \end{align*}通过一些变换可以归纳出以下： 数列 生成函数 $1, c, c^2, c^3, \cdots $ $\frac{1}{1 - cx}$ $\sum \limits_i \begin{pmatrix}n \\ i \end{pmatrix}x^i$ $(1 + x)^ n$ $\sum \limits_i x^i$ $\ln \frac{1}{1 - x}$ $\sum \limits_{n = 1} \frac{(-1)^{n + 1}}{n}x^n$ $\ln(1 + x)$ $-\sum \limits_{n = 1}\frac{x^n}{n}$ $\ln(1 - x)$ $\sum \limits_{i}\frac{x^i}{i!}$ $e^x$ $\sum \limits_{i}\begin{pmatrix} n + i - 1 \\n - 1 \end{pmatrix} x^k$ $\frac{1}{(1 - x)^n}$ 利用等比数列求和以及泰勒展开可以推出更多的式子。 对于已知生成函数需要求解数列的，将生成函数看作多项式，直接进行求解即可。 指数型生成函数定理多重集合 $S = \{\infty \times a_1, \infty \times a_2, \cdots, \infty \times a_n\}$ ，且限定 $a_i$ 出现的次数集合为 $M_i$ ，则其生成函数为： $\prod \limits_{i = 1}^n \sum \limits_{m \in M_i} \frac{x^m}{m!}$ ，也就是说有时候不同地方的出现是相同的，需要除以 $m!$ 。 那么指数型生成函数可以利用 $\operatorname{Taylor}$ 展开转化成：$G_e(x) = b_0 + b_1 \times \frac{x}{1!} +b_2 \times \frac{x^2}{2!} + b_3 \times \frac{x^3}{3!} + \cdots$ 。$b_i$ 是我们需要的结果。 那么 $F(x) = \sum \limits_n f_n \frac{x^n}{n!}$ 。 其意义体现在他的乘法操作上：$F(x)G(x) = \sum \limits_n (\sum \limits_{i = 0}^n \begin{pmatrix} n \\ i \end{pmatrix}f_ig_{n - i})\frac{x^n}{n}$ 。 \begin{align*} \alpha F(x) + \beta G(x) & = \sum \limits_n(\alpha f_n + \beta f_n) \frac{x^n}{n!} \\ x^mF(x) & = \sum \limits_{n \geq m} n^{\underline{m}}f_{n - m}x^n \\ \frac{F(x) - \sum \limits_{i = 0}^{m - 1}f_ix^i}{x^m} & = \frac{1}{(n + m)^{\underline{m}}}\sum \limits_n f_{n + m}\frac{x^n}{n!} \\ F(cx) & = \sum \limits_n f_nc^n\frac{x^n}{n!} \\ F'(x) & = \sum \limits_{n} f_{n + 1}\frac{x^n}{n!} \\ \int_0^xF(t)dt & = \sum \limits_{n > 0} f_{n - 1} \frac{x^n}{n!} \\ F(x)G(x) & = \sum \limits_n (\sum \limits_{i = 0}^n \begin{pmatrix} n \\ i \end{pmatrix}f_ig_{n - i})x^i \end{align*} 数列 生成函数 $\sum \limits_i \frac{x^i}{i!}$ $e^x$ $\sum \limits_i \frac{x^i}{(i - 1)!}$ $xe^x$ $\sum \limits_i \frac{c^ix^i}{i!}$ $e^{cx}$ 递推与通项公式生成函数的一大作用就是将一个数列的递推式转换成通项公式。 $\mbox{Fibonacci}$ 数列与生成函数$f_n = \begin{cases} n &amp; n \leq 1 \\ f_{n - 2} + f_{n - 1} &amp; n &gt; 1 \end{cases}$ 那么我们求出 $f$ 的生成函数： $F(x) = \sum \limits_{n} f_nx^n$ ，我们对这个式子进行一些推导： \begin{align*} F(x) &= \sum \limits_n f_nx^n \\ xF(x) &= \sum \limits_n f_nx^{n + 1} \\ F(x) - xF(x) &= x + \sum \limits_n (f_n - f_{n - 1})x^n \\ F(x) - xF(x) &= x + \sum \limits_n f_{n - 2}x^n \\ F(x) - xF(x) &= x + x^2\sum \limits_n f_n x^n \\ F(x) - xF(x) &= x + x^2F(x) \\ F(x) &= \frac{x}{1 - x - x^2} \\ F(x) &= \frac{x}{(1 - \frac{1 - \sqrt{5}}{2}x)(1 - \frac{1 + \sqrt{5}}{2}x)} \\ F(x) &= -\frac{1}{\sqrt{5}} \cdot \frac{1}{1 - \frac{1 - \sqrt{5}}{2}x} + \frac{1}{\sqrt{5}} \cdot \frac{1}{1 - \frac{1 + \sqrt{5}}{2}x} \\ f_n &= -\frac{1}{\sqrt{5}} (\frac{1 - \sqrt{5}}{2}) ^ n + \frac{1}{\sqrt{5}} (\frac{1 + \sqrt{5}}{2})^n \end{align*}对于最后一步的转化，可以看作倒二行的式子变成了两个等比数列求和的式子，逆推即可。· 上面的推到运用到了数列的知识，对于生成函数来说，并不是非常的优美。 换一种方式进行推导： \begin{align*} F(x) & = \sum \limits_n f_nx^n \\ F(x) & = \sum \limits_n (f_{n - 1} + f_{n - 2} + [n = 1])x^n \\ F(x) & = \sum \limits_nf_{n - 1}x^n + \sum \limits_n f_{n - 2}x^n + x \\ F(x) & = x\sum \limits_n f_nx^n + x^2\sum \limits_nf_nx^n + x \\ F(x) & = xF(x) + x^2F(x) + x \\ F(x) & = \frac{x}{1 - x - x^2} \\ \end{align*}也能得到相同的结果。 $\mbox{Catalan}$ 数列与生成函数$f_n = \begin{cases} 1 &amp; n = 0\\\sum \limits_{i = 0}^{n - 1}f_if_{n - i - 1} &amp; n &gt; 0 \end{cases}$ 那么依然设 $F(x) = \sum \limits_n f_nx^n$ \begin{align*} F(x) & = \sum \limits_n ([n = 0] + \sum \limits_{i = 0}^{n - 1}f_if_{n - i - 1})x^n\\ F(x) & = 1 + \sum \limits_n (\sum \limits_{i = 0}^{n - 1}f_if_{n - i - 1})x^n \\ F(x) & = 1 + xF(x)^2 \\ F(x) & = \frac{1 \pm \sqrt{1 - 4x}}{2x} \\ F(x) & = \frac{1 - \sqrt{1 - 4x}}{2x} \\ \end{align*}至于第二步，可以观察到 $\sum \limits_{i = 0}^{n - 1}f_if_{n - i - 1}$ 是一个卷积的形式，那么可以看作 $F(x)$ 相乘。至于最后一步取正还是取负。当 $x = 0$ 时，若取正其不成立。故取负。 然而这与我们平常所见的 $Catalan$ 数列的公式大相径庭，我们展开一下它。 \sqrt{1 - 4x} = \sum \limits_n \begin{pmatrix} \frac{1}{2} \\ n \end{pmatrix}(-4x)^n \\因为： \begin{align*} \begin{pmatrix} \frac{1}{2} \\ n\end{pmatrix} & = \frac{\frac{1}{2}(\frac{1}{2} - 1)\cdots (\frac{1}{2} - n + 1)}{n!} \\ & = \frac{(-1)^{n - 1} \times 1 \times 3 \times \cdots \times (2n - 3)}{2^nn!}\\ & = \frac{(-1)^{n - 1}(2n - 2)!}{2^{2n - 1}n!(n - 1)!} \\ \end{align*}则： \begin{align*} \sqrt{1 - 4x} & = \sum \limits_n \begin{pmatrix} \frac{1}{2}\\ n \end{pmatrix}(-4x)^n \\ & = -2\sum \limits_n \frac{(2n - 2)!}{n!(n - 1)!}x^n \\ \end{align*}最后： \frac{1 - \sqrt{1 - 4x}}{2x} = \sum \limits_n \frac{(2n)!}{n!(n + 1)!}x^n至此，这就变成了我们熟悉的通项公式。 组合计数有标号集合计数设集合的生成函数为 $A(x)$ ，则其组成元素的 $\operatorname{EGF}$ 为： B(x) = \sum \limits_i \frac{A(x)^n}{n!} = e^{A(x)}连通图计数设 $G(x)$ 是所有无向图： G(x) = \sum \limits_n 2^{\begin{pmatrix}n \\ 2\end{pmatrix}}\frac{x^n}{n!}设 $F(x)$ 是所有无向连通图： \begin{align*} G(x) & = \sum \limits_n \frac{F(x)^n}{n!} \\ & = e^{F(x)} \\ F(x) & = \ln G(x) \end{align*}有限制的置换计数给定集合 $S$ 和 $n$ ，求有多少个 $n$ 阶置换 $p$ ，满足 $p$ 分解后的每一个轮换大小都在 $S$ 内。 一个置换是多个轮换的集合，每一个轮换相当于一个带标号的环，根据圆排列计数，大小为 $k$ 的轮换有 $(k - 1)!$ 种，对应的 $\operatorname{EGF}$ 为： \frac{(k - 1)!x^k}{k!} = \frac{x^k}{k}置换的 $\operatorname{EGF}$ 为： \exp(\sum \limits_{n \in S}\frac{x^k}k)完全背包计数体积为 $i$ 的物品有 $a_i$ 种，每一种有无限个，那么其 $\operatorname{OGF}$ 为： (1 + x^i + x^{2i} + \cdots)^{a_i}设： A(x) = \sum \limits_{i = 1}^n a_ix^i那么答案的 $\operatorname{OGF}$ 为： \begin{align*} & \prod_{i = 1}^n (1 + x^i + x^{2i} + \cdots)^{a_i} \\ = & \prod_{i = 1}^n (\frac{1}{1 - x^i})^{a_i} \\ = & \exp(-\sum \limits_{i = 1}^n a_i \ln(1 - x^i)) \\ = & \exp(-\sum \limits_{i = 1}^n a_i \sum \limits_{j = 1}\frac{x^{ij}}{j}) \\ = & \exp(\sum \limits_{j = 1}A(x^j)) \end{align*}由于 $A(x)$ 中只有 $n - j$ 项是有用的，所以复杂度为 $O(n \log n)$ 。 有标号环的计数 $k$ 元环的数量有 $(k - 1)!$ 个，则答案的 $\operatorname{EGF}$ 为： \begin{align*} & \sum \limits_i \frac{A(x)^i}{i} \\ = & -\ln(1 - A(x)) \end{align*}无向基环树计数首先，根据 $\operatorname{Carley}$ 定理，推出有根树的 $\operatorname{EGF}$ 为： T(x) = \sum \limits_{n = 1}\frac{n^{n - 1}x^n}{n!}那么基环树显然是由 $3$ 棵以上的有根树合并而成，同时又因为无向： \begin{align*} & \frac{1}{2} \sum \limits_{k = 3}\frac{T(x)^k}{k} \\ = & -\frac{1}{2}\ln(1 - T(x)) - \frac{T(x)}{2} - \frac{T(x)^2}{4} \end{align*}]]></content>
      <categories>
        <category>数学</category>
        <category>组合数学</category>
        <category>生成函数</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
</search>
